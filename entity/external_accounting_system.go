// This file was auto-generated by Fern from our API Definition.

package entity

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mercoa-finance/go/core"
)

type SyncExternalSystemRequest struct {
	// Sync vendors from external accounting system. Default is to pull vendors from external system.
	Vendors *SyncType `json:"-" url:"vendors,omitempty"`
	// Sync bills from external accounting system. Default is to not sync bills. Invoices that already exist in both systems will not be updated, only new invoices not present in the other system will be created.
	Bills *SyncType `json:"-" url:"bills,omitempty"`
	// Sync GL accounts from external accounting system. Default is to pull GL accounts from external system. Pushing GL accounts is not supported.
	GlAccounts *SyncType `json:"-" url:"glAccounts,omitempty"`
}

type CodatCompanyCreationRequest struct {
	// If the company already exists in Codat, provide the company ID to link the company to the entity. If the company does not exist, leave this field blank and Codat will create a new company.
	CompanyID *string `json:"companyId,omitempty" url:"companyId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CodatCompanyCreationRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodatCompanyCreationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatCompanyCreationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatCompanyCreationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatCompanyCreationRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CodatCompanyResponse struct {
	CompanyID string `json:"companyId" url:"companyId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CodatCompanyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodatCompanyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatCompanyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatCompanyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatCompanyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ExternalAccountingSystemCompanyCreationRequest struct {
	Type   string
	Codat  *CodatCompanyCreationRequest
	Rutter *RutterCompanyCreationRequest
}

func (e *ExternalAccountingSystemCompanyCreationRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "codat":
		value := new(CodatCompanyCreationRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterCompanyCreationRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	}
	return nil
}

func (e ExternalAccountingSystemCompanyCreationRequest) MarshalJSON() ([]byte, error) {
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemCompanyCreationRequestVisitor interface {
	VisitCodat(*CodatCompanyCreationRequest) error
	VisitRutter(*RutterCompanyCreationRequest) error
}

func (e *ExternalAccountingSystemCompanyCreationRequest) Accept(visitor ExternalAccountingSystemCompanyCreationRequestVisitor) error {
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemCompanyResponse struct {
	Type   string
	Codat  *CodatCompanyResponse
	Rutter *RutterCompanyResponse
	None   *CodatCompanyResponse
}

func (e *ExternalAccountingSystemCompanyResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "codat":
		value := new(CodatCompanyResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterCompanyResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	case "none":
		value := new(CodatCompanyResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.None = value
	}
	return nil
}

func (e ExternalAccountingSystemCompanyResponse) MarshalJSON() ([]byte, error) {
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	if e.None != nil {
		return core.MarshalJSONWithExtraProperty(e.None, "type", "none")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemCompanyResponseVisitor interface {
	VisitCodat(*CodatCompanyResponse) error
	VisitRutter(*RutterCompanyResponse) error
	VisitNone(*CodatCompanyResponse) error
}

func (e *ExternalAccountingSystemCompanyResponse) Accept(visitor ExternalAccountingSystemCompanyResponseVisitor) error {
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	if e.None != nil {
		return visitor.VisitNone(e.None)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type RutterCompanyCreationRequest struct {
	// The access token for the existing Rutter connection. If the connection does not exist, leave this field blank and Rutter will create a new connection.
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RutterCompanyCreationRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RutterCompanyCreationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterCompanyCreationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterCompanyCreationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterCompanyCreationRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RutterCompanyResponse struct {
	AccessToken string `json:"accessToken" url:"accessToken"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RutterCompanyResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RutterCompanyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterCompanyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterCompanyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterCompanyResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SyncType string

const (
	SyncTypeNone SyncType = "none"
	SyncTypePush SyncType = "push"
	SyncTypePull SyncType = "pull"
	SyncTypeBoth SyncType = "both"
)

func NewSyncTypeFromString(s string) (SyncType, error) {
	switch s {
	case "none":
		return SyncTypeNone, nil
	case "push":
		return SyncTypePush, nil
	case "pull":
		return SyncTypePull, nil
	case "both":
		return SyncTypeBoth, nil
	}
	var t SyncType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncType) Ptr() *SyncType {
	return &s
}
