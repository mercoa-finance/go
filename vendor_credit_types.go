// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type CalculateVendorCreditUsageResponse struct {
	// Remaining amount on the invoice after vendor credits are applied in major units.
	RemainingAmount float64 `json:"remainingAmount" url:"remainingAmount"`
	// Currency code for the amount. Defaults to USD.
	Currency CurrencyCode `json:"currency" url:"currency"`
	// Vendor credits that will be applied to the invoice. The objects returned represent the states each vendor credit will be in AFTER they are applied to the invoice, not their current states.
	VendorCredits []*VendorCreditResponse `json:"vendorCredits" url:"vendorCredits"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CalculateVendorCreditUsageResponse) GetRemainingAmount() float64 {
	if c == nil {
		return 0
	}
	return c.RemainingAmount
}

func (c *CalculateVendorCreditUsageResponse) GetCurrency() CurrencyCode {
	if c == nil {
		return ""
	}
	return c.Currency
}

func (c *CalculateVendorCreditUsageResponse) GetVendorCredits() []*VendorCreditResponse {
	if c == nil {
		return nil
	}
	return c.VendorCredits
}

func (c *CalculateVendorCreditUsageResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateVendorCreditUsageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateVendorCreditUsageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateVendorCreditUsageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateVendorCreditUsageResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type FindVendorCreditResponse struct {
	// Total number of vendor credits for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more vendor credits available for the given filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*VendorCreditResponse `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindVendorCreditResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindVendorCreditResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindVendorCreditResponse) GetData() []*VendorCreditResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindVendorCreditResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindVendorCreditResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindVendorCreditResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindVendorCreditResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindVendorCreditResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type VendorCreditID = string

type VendorCreditRequest struct {
	// Memo number for the vendor credit
	MemoNumber *string `json:"memoNumber,omitempty" url:"memoNumber,omitempty"`
	// Total amount of the vendor credit in major units
	TotalAmount float64 `json:"totalAmount" url:"totalAmount"`
	// Currency code for the amount. Defaults to USD.
	Currency CurrencyCode `json:"currency" url:"currency"`
	// An optional note to attach to the vendor credit
	Note *string `json:"note,omitempty" url:"note,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditRequest) GetMemoNumber() *string {
	if v == nil {
		return nil
	}
	return v.MemoNumber
}

func (v *VendorCreditRequest) GetTotalAmount() float64 {
	if v == nil {
		return 0
	}
	return v.TotalAmount
}

func (v *VendorCreditRequest) GetCurrency() CurrencyCode {
	if v == nil {
		return ""
	}
	return v.Currency
}

func (v *VendorCreditRequest) GetNote() *string {
	if v == nil {
		return nil
	}
	return v.Note
}

func (v *VendorCreditRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditRequest) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditResponse struct {
	ID VendorCreditID `json:"id" url:"id"`
	// Memo number for the vendor credit
	MemoNumber *string `json:"memoNumber,omitempty" url:"memoNumber,omitempty"`
	// Total issued amount of the vendor credit in major units
	TotalAmount *float64 `json:"totalAmount,omitempty" url:"totalAmount,omitempty"`
	// Remaining usable amount in the vendor credit in major units
	RemainingAmount *float64 `json:"remainingAmount,omitempty" url:"remainingAmount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// ID of the vendor the vendor credit may be used for
	VendorID EntityID `json:"vendorId" url:"vendorId"`
	// ID of the payer who may use the vendor credit
	PayerID EntityID `json:"payerId" url:"payerId"`
	// ID of the entity that created this vendor credit
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// An optional note to attach to the vendor credit
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The IDs of the invoices that this vendor credit has been applied to
	InvoiceIDs []InvoiceID `json:"invoiceIds,omitempty" url:"invoiceIds,omitempty"`
	CreatedAt  time.Time   `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time   `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreditResponse) GetID() VendorCreditID {
	if v == nil {
		return ""
	}
	return v.ID
}

func (v *VendorCreditResponse) GetMemoNumber() *string {
	if v == nil {
		return nil
	}
	return v.MemoNumber
}

func (v *VendorCreditResponse) GetTotalAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.TotalAmount
}

func (v *VendorCreditResponse) GetRemainingAmount() *float64 {
	if v == nil {
		return nil
	}
	return v.RemainingAmount
}

func (v *VendorCreditResponse) GetCurrency() *CurrencyCode {
	if v == nil {
		return nil
	}
	return v.Currency
}

func (v *VendorCreditResponse) GetVendorID() EntityID {
	if v == nil {
		return ""
	}
	return v.VendorID
}

func (v *VendorCreditResponse) GetPayerID() EntityID {
	if v == nil {
		return ""
	}
	return v.PayerID
}

func (v *VendorCreditResponse) GetCreatorEntityID() *EntityID {
	if v == nil {
		return nil
	}
	return v.CreatorEntityID
}

func (v *VendorCreditResponse) GetNote() *string {
	if v == nil {
		return nil
	}
	return v.Note
}

func (v *VendorCreditResponse) GetInvoiceIDs() []InvoiceID {
	if v == nil {
		return nil
	}
	return v.InvoiceIDs
}

func (v *VendorCreditResponse) GetCreatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.CreatedAt
}

func (v *VendorCreditResponse) GetUpdatedAt() time.Time {
	if v == nil {
		return time.Time{}
	}
	return v.UpdatedAt
}

func (v *VendorCreditResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditResponse) UnmarshalJSON(data []byte) error {
	type embed VendorCreditResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCreditResponse(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditResponse) MarshalJSON() ([]byte, error) {
	type embed VendorCreditResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*v),
		CreatedAt: internal.NewDateTime(v.CreatedAt),
		UpdatedAt: internal.NewDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCreditResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
