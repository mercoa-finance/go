// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type ContractCreateRequest struct {
	// Natural language summary of the contract
	Summary string `json:"summary" url:"summary"`
	// Recurrences defining the contract's fee schedule.
	Recurrences []*ContractRecurrenceCreateRequest `json:"recurrences,omitempty" url:"recurrences,omitempty"`
	// ID of the entity that created the contract
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`
	// ID of the payer entity for this contract
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of the vendor entity for this contract
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractCreateRequest) GetSummary() string {
	if c == nil {
		return ""
	}
	return c.Summary
}

func (c *ContractCreateRequest) GetRecurrences() []*ContractRecurrenceCreateRequest {
	if c == nil {
		return nil
	}
	return c.Recurrences
}

func (c *ContractCreateRequest) GetCreatorEntityID() EntityID {
	if c == nil {
		return ""
	}
	return c.CreatorEntityID
}

func (c *ContractCreateRequest) GetPayerID() *EntityID {
	if c == nil {
		return nil
	}
	return c.PayerID
}

func (c *ContractCreateRequest) GetVendorID() *EntityID {
	if c == nil {
		return nil
	}
	return c.VendorID
}

func (c *ContractCreateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ContractCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContractCreateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractCreateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractID = string

type ContractInvoiceLineItemSchema struct {
	// Name of the line item
	Name string `json:"name" url:"name"`
	// Unit price of the line item
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// ISO 4217 currency code
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Quantity of the line item
	Quantity *float64 `json:"quantity,omitempty" url:"quantity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractInvoiceLineItemSchema) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *ContractInvoiceLineItemSchema) GetUnitPrice() *float64 {
	if c == nil {
		return nil
	}
	return c.UnitPrice
}

func (c *ContractInvoiceLineItemSchema) GetCurrency() *CurrencyCode {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *ContractInvoiceLineItemSchema) GetQuantity() *float64 {
	if c == nil {
		return nil
	}
	return c.Quantity
}

func (c *ContractInvoiceLineItemSchema) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractInvoiceLineItemSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ContractInvoiceLineItemSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContractInvoiceLineItemSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractInvoiceLineItemSchema) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractInvoiceSchema struct {
	// Line items in the invoice
	LineItems []*ContractInvoiceLineItemSchema `json:"lineItems,omitempty" url:"lineItems,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractInvoiceSchema) GetLineItems() []*ContractInvoiceLineItemSchema {
	if c == nil {
		return nil
	}
	return c.LineItems
}

func (c *ContractInvoiceSchema) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractInvoiceSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ContractInvoiceSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContractInvoiceSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractInvoiceSchema) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractJobID = string

type ContractJobStatus string

const (
	ContractJobStatusPending ContractJobStatus = "pending"
	ContractJobStatusSuccess ContractJobStatus = "success"
	ContractJobStatusFailed  ContractJobStatus = "failed"
)

func NewContractJobStatusFromString(s string) (ContractJobStatus, error) {
	switch s {
	case "pending":
		return ContractJobStatusPending, nil
	case "success":
		return ContractJobStatusSuccess, nil
	case "failed":
		return ContractJobStatusFailed, nil
	}
	var t ContractJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContractJobStatus) Ptr() *ContractJobStatus {
	return &c
}

type ContractRecurrenceCreateRequest struct {
	// RFC 5545 RRULE string
	Rrule string `json:"rrule" url:"rrule"`
	// Natural language justification for the recurrence
	Justification string `json:"justification" url:"justification"`
	// Natural language summary of the contract, filtered to only include information relevant to the recurrence
	FilteredContractSummary string `json:"filteredContractSummary" url:"filteredContractSummary"`
	// Schema of the invoices to be created by this recurrence
	InvoiceSchema *ContractInvoiceSchema `json:"invoiceSchema,omitempty" url:"invoiceSchema,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractRecurrenceCreateRequest) GetRrule() string {
	if c == nil {
		return ""
	}
	return c.Rrule
}

func (c *ContractRecurrenceCreateRequest) GetJustification() string {
	if c == nil {
		return ""
	}
	return c.Justification
}

func (c *ContractRecurrenceCreateRequest) GetFilteredContractSummary() string {
	if c == nil {
		return ""
	}
	return c.FilteredContractSummary
}

func (c *ContractRecurrenceCreateRequest) GetInvoiceSchema() *ContractInvoiceSchema {
	if c == nil {
		return nil
	}
	return c.InvoiceSchema
}

func (c *ContractRecurrenceCreateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractRecurrenceCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ContractRecurrenceCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContractRecurrenceCreateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractRecurrenceCreateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractRecurrenceID = string

type ContractRecurrenceResponse struct {
	ID         ContractRecurrenceID `json:"id" url:"id"`
	ContractID ContractID           `json:"contractId" url:"contractId"`
	// RFC 5545 RRULE string
	Rrule string `json:"rrule" url:"rrule"`
	// Natural language justification for the recurrence
	Justification string `json:"justification" url:"justification"`
	// Natural language summary of the contract, filtered to only include information relevant to the recurrence
	FilteredContractSummary string `json:"filteredContractSummary" url:"filteredContractSummary"`
	// Schema of the invoices to be created by this recurrence
	InvoiceSchema *ContractInvoiceSchema `json:"invoiceSchema,omitempty" url:"invoiceSchema,omitempty"`
	// IDs of invoices created by the recurrence
	CreatedInvoiceIDs []InvoiceID `json:"createdInvoiceIds,omitempty" url:"createdInvoiceIds,omitempty"`
	CreatedAt         time.Time   `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time   `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractRecurrenceResponse) GetID() ContractRecurrenceID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *ContractRecurrenceResponse) GetContractID() ContractID {
	if c == nil {
		return ""
	}
	return c.ContractID
}

func (c *ContractRecurrenceResponse) GetRrule() string {
	if c == nil {
		return ""
	}
	return c.Rrule
}

func (c *ContractRecurrenceResponse) GetJustification() string {
	if c == nil {
		return ""
	}
	return c.Justification
}

func (c *ContractRecurrenceResponse) GetFilteredContractSummary() string {
	if c == nil {
		return ""
	}
	return c.FilteredContractSummary
}

func (c *ContractRecurrenceResponse) GetInvoiceSchema() *ContractInvoiceSchema {
	if c == nil {
		return nil
	}
	return c.InvoiceSchema
}

func (c *ContractRecurrenceResponse) GetCreatedInvoiceIDs() []InvoiceID {
	if c == nil {
		return nil
	}
	return c.CreatedInvoiceIDs
}

func (c *ContractRecurrenceResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *ContractRecurrenceResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *ContractRecurrenceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractRecurrenceResponse) UnmarshalJSON(data []byte) error {
	type embed ContractRecurrenceResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContractRecurrenceResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractRecurrenceResponse) MarshalJSON() ([]byte, error) {
	type embed ContractRecurrenceResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ContractRecurrenceResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractResponse struct {
	ID ContractID `json:"id" url:"id"`
	// Natural language summary of the contract
	Summary string `json:"summary" url:"summary"`
	// Recurrences defining the contract's fee schedule
	Recurrences []*ContractRecurrenceResponse `json:"recurrences,omitempty" url:"recurrences,omitempty"`
	// Date of the next invoice to be created from the contract
	NextInvoiceDate *time.Time `json:"nextInvoiceDate,omitempty" url:"nextInvoiceDate,omitempty" format:"date"`
	// The ID of the entity who created this contract
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`
	// The ID of the payer entity for this contract
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// The payer entity for this contract
	Payer *CounterpartyResponse `json:"payer,omitempty" url:"payer,omitempty"`
	// The ID of the vendor entity for this contract
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// The vendor entity for this contract
	Vendor    *CounterpartyResponse `json:"vendor,omitempty" url:"vendor,omitempty"`
	CreatedAt time.Time             `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time             `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractResponse) GetID() ContractID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *ContractResponse) GetSummary() string {
	if c == nil {
		return ""
	}
	return c.Summary
}

func (c *ContractResponse) GetRecurrences() []*ContractRecurrenceResponse {
	if c == nil {
		return nil
	}
	return c.Recurrences
}

func (c *ContractResponse) GetNextInvoiceDate() *time.Time {
	if c == nil {
		return nil
	}
	return c.NextInvoiceDate
}

func (c *ContractResponse) GetCreatorEntityID() EntityID {
	if c == nil {
		return ""
	}
	return c.CreatorEntityID
}

func (c *ContractResponse) GetPayerID() *EntityID {
	if c == nil {
		return nil
	}
	return c.PayerID
}

func (c *ContractResponse) GetPayer() *CounterpartyResponse {
	if c == nil {
		return nil
	}
	return c.Payer
}

func (c *ContractResponse) GetVendorID() *EntityID {
	if c == nil {
		return nil
	}
	return c.VendorID
}

func (c *ContractResponse) GetVendor() *CounterpartyResponse {
	if c == nil {
		return nil
	}
	return c.Vendor
}

func (c *ContractResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *ContractResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *ContractResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractResponse) UnmarshalJSON(data []byte) error {
	type embed ContractResponse
	var unmarshaler = struct {
		embed
		NextInvoiceDate *internal.Date     `json:"nextInvoiceDate,omitempty"`
		CreatedAt       *internal.DateTime `json:"createdAt"`
		UpdatedAt       *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContractResponse(unmarshaler.embed)
	c.NextInvoiceDate = unmarshaler.NextInvoiceDate.TimePtr()
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractResponse) MarshalJSON() ([]byte, error) {
	type embed ContractResponse
	var marshaler = struct {
		embed
		NextInvoiceDate *internal.Date     `json:"nextInvoiceDate,omitempty"`
		CreatedAt       *internal.DateTime `json:"createdAt"`
		UpdatedAt       *internal.DateTime `json:"updatedAt"`
	}{
		embed:           embed(*c),
		NextInvoiceDate: internal.NewOptionalDate(c.NextInvoiceDate),
		CreatedAt:       internal.NewDateTime(c.CreatedAt),
		UpdatedAt:       internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ContractResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContractUpdateRequest struct {
	// Natural language summary of the contract
	Summary *string `json:"summary,omitempty" url:"summary,omitempty"`
	// Recurrences defining the contract's fee schedule. Please note that setting this will overwrite all existing recurrences.
	Recurrences []*ContractRecurrenceCreateRequest `json:"recurrences,omitempty" url:"recurrences,omitempty"`
	// ID of the entity that created the contract
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// ID of the payer entity for this contract
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of the vendor entity for this contract
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContractUpdateRequest) GetSummary() *string {
	if c == nil {
		return nil
	}
	return c.Summary
}

func (c *ContractUpdateRequest) GetRecurrences() []*ContractRecurrenceCreateRequest {
	if c == nil {
		return nil
	}
	return c.Recurrences
}

func (c *ContractUpdateRequest) GetCreatorEntityID() *EntityID {
	if c == nil {
		return nil
	}
	return c.CreatorEntityID
}

func (c *ContractUpdateRequest) GetPayerID() *EntityID {
	if c == nil {
		return nil
	}
	return c.PayerID
}

func (c *ContractUpdateRequest) GetVendorID() *EntityID {
	if c == nil {
		return nil
	}
	return c.VendorID
}

func (c *ContractUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContractUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ContractUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContractUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContractUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type FindContractResponse struct {
	// Total number of contracts found
	Count int `json:"count" url:"count"`
	// True if there are more contracts available for the given filters
	HasMore bool                `json:"hasMore" url:"hasMore"`
	Data    []*ContractResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindContractResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindContractResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindContractResponse) GetData() []*ContractResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindContractResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindContractResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindContractResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindContractResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindContractResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GenerateContractAsyncJobResponse struct {
	// Job ID
	JobID ContractJobID `json:"jobId" url:"jobId"`
	// Job status
	Status ContractJobStatus `json:"status" url:"status"`
	// Contract
	Contract *ContractResponse `json:"contract,omitempty" url:"contract,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GenerateContractAsyncJobResponse) GetJobID() ContractJobID {
	if g == nil {
		return ""
	}
	return g.JobID
}

func (g *GenerateContractAsyncJobResponse) GetStatus() ContractJobStatus {
	if g == nil {
		return ""
	}
	return g.Status
}

func (g *GenerateContractAsyncJobResponse) GetContract() *ContractResponse {
	if g == nil {
		return nil
	}
	return g.Contract
}

func (g *GenerateContractAsyncJobResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateContractAsyncJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateContractAsyncJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateContractAsyncJobResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateContractAsyncJobResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateContractAsyncResponse struct {
	// Job ID
	JobID ContractJobID `json:"jobId" url:"jobId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GenerateContractAsyncResponse) GetJobID() ContractJobID {
	if g == nil {
		return ""
	}
	return g.JobID
}

func (g *GenerateContractAsyncResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateContractAsyncResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateContractAsyncResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateContractAsyncResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateContractAsyncResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateContractRequest struct {
	// Base64 encoded PDF of contract document.
	Document string `json:"document" url:"document"`
	// ID of the entity that created the contract
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GenerateContractRequest) GetDocument() string {
	if g == nil {
		return ""
	}
	return g.Document
}

func (g *GenerateContractRequest) GetCreatorEntityID() EntityID {
	if g == nil {
		return ""
	}
	return g.CreatorEntityID
}

func (g *GenerateContractRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateContractRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateContractRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateContractRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateContractRequest) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateContractResponse struct {
	// Job ID
	JobID ContractJobID `json:"jobId" url:"jobId"`
	// Contract
	Contract *ContractResponse `json:"contract,omitempty" url:"contract,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GenerateContractResponse) GetJobID() ContractJobID {
	if g == nil {
		return ""
	}
	return g.JobID
}

func (g *GenerateContractResponse) GetContract() *ContractResponse {
	if g == nil {
		return nil
	}
	return g.Contract
}

func (g *GenerateContractResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GenerateContractResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateContractResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateContractResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateContractResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}
