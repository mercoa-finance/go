// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type CalculateFeesRequest struct {
	// Total amount in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount float64 `json:"amount" url:"amount"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// ID of the entity creating the invoice. If not provided, the fees will be calculated with the default pricing for the organization.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// ID of payment source.
	PaymentSourceID PaymentMethodID `json:"paymentSourceId" url:"paymentSourceId"`
	// ID of payment destination.
	PaymentDestinationID PaymentMethodID `json:"paymentDestinationId" url:"paymentDestinationId"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Type of payment to calculate fees for. Defaults to PAYABLE (Accounts Payable).
	Type *FeeCalculationType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CalculateFeesRequest) GetAmount() float64 {
	if c == nil {
		return 0
	}
	return c.Amount
}

func (c *CalculateFeesRequest) GetCurrency() *CurrencyCode {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *CalculateFeesRequest) GetCreatorEntityID() *EntityID {
	if c == nil {
		return nil
	}
	return c.CreatorEntityID
}

func (c *CalculateFeesRequest) GetPaymentSourceID() PaymentMethodID {
	if c == nil {
		return ""
	}
	return c.PaymentSourceID
}

func (c *CalculateFeesRequest) GetPaymentDestinationID() PaymentMethodID {
	if c == nil {
		return ""
	}
	return c.PaymentDestinationID
}

func (c *CalculateFeesRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if c == nil {
		return nil
	}
	return c.PaymentDestinationOptions
}

func (c *CalculateFeesRequest) GetType() *FeeCalculationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CalculateFeesRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateFeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateFeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateFeesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateFeesRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CalculatePaymentTimingRequest struct {
	EstimatedTiming *EstimatedTiming
	InvoiceTiming   *InvoiceTiming

	typ string
}

func (c *CalculatePaymentTimingRequest) GetEstimatedTiming() *EstimatedTiming {
	if c == nil {
		return nil
	}
	return c.EstimatedTiming
}

func (c *CalculatePaymentTimingRequest) GetInvoiceTiming() *InvoiceTiming {
	if c == nil {
		return nil
	}
	return c.InvoiceTiming
}

func (c *CalculatePaymentTimingRequest) UnmarshalJSON(data []byte) error {
	valueEstimatedTiming := new(EstimatedTiming)
	if err := json.Unmarshal(data, &valueEstimatedTiming); err == nil {
		c.typ = "EstimatedTiming"
		c.EstimatedTiming = valueEstimatedTiming
		return nil
	}
	valueInvoiceTiming := new(InvoiceTiming)
	if err := json.Unmarshal(data, &valueInvoiceTiming); err == nil {
		c.typ = "InvoiceTiming"
		c.InvoiceTiming = valueInvoiceTiming
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c CalculatePaymentTimingRequest) MarshalJSON() ([]byte, error) {
	if c.typ == "EstimatedTiming" || c.EstimatedTiming != nil {
		return json.Marshal(c.EstimatedTiming)
	}
	if c.typ == "InvoiceTiming" || c.InvoiceTiming != nil {
		return json.Marshal(c.InvoiceTiming)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CalculatePaymentTimingRequestVisitor interface {
	VisitEstimatedTiming(*EstimatedTiming) error
	VisitInvoiceTiming(*InvoiceTiming) error
}

func (c *CalculatePaymentTimingRequest) Accept(visitor CalculatePaymentTimingRequestVisitor) error {
	if c.typ == "EstimatedTiming" || c.EstimatedTiming != nil {
		return visitor.VisitEstimatedTiming(c.EstimatedTiming)
	}
	if c.typ == "InvoiceTiming" || c.InvoiceTiming != nil {
		return visitor.VisitInvoiceTiming(c.InvoiceTiming)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type CalculatePaymentTimingResponse struct {
	// Estimated date the payment will be or was processed.
	EstimatedProcessingDate time.Time `json:"estimatedProcessingDate" url:"estimatedProcessingDate"`
	// Number of business days between the estimated processing date and the estimated settlement date. This does not take into account bank holidays or weekends.
	BusinessDays int `json:"businessDays" url:"businessDays"`
	// Estimated payment time in days. This time takes into account bank holidays and weekends.
	EstimatedProcessingTime int `json:"estimatedProcessingTime" url:"estimatedProcessingTime"`
	// Estimated date the payment will be or was settled. This is the same as the request's deductionDate plus the paymentTiming.
	EstimatedSettlementDate time.Time `json:"estimatedSettlementDate" url:"estimatedSettlementDate"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CalculatePaymentTimingResponse) GetEstimatedProcessingDate() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.EstimatedProcessingDate
}

func (c *CalculatePaymentTimingResponse) GetBusinessDays() int {
	if c == nil {
		return 0
	}
	return c.BusinessDays
}

func (c *CalculatePaymentTimingResponse) GetEstimatedProcessingTime() int {
	if c == nil {
		return 0
	}
	return c.EstimatedProcessingTime
}

func (c *CalculatePaymentTimingResponse) GetEstimatedSettlementDate() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.EstimatedSettlementDate
}

func (c *CalculatePaymentTimingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculatePaymentTimingResponse) UnmarshalJSON(data []byte) error {
	type embed CalculatePaymentTimingResponse
	var unmarshaler = struct {
		embed
		EstimatedProcessingDate *internal.DateTime `json:"estimatedProcessingDate"`
		EstimatedSettlementDate *internal.DateTime `json:"estimatedSettlementDate"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CalculatePaymentTimingResponse(unmarshaler.embed)
	c.EstimatedProcessingDate = unmarshaler.EstimatedProcessingDate.Time()
	c.EstimatedSettlementDate = unmarshaler.EstimatedSettlementDate.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculatePaymentTimingResponse) MarshalJSON() ([]byte, error) {
	type embed CalculatePaymentTimingResponse
	var marshaler = struct {
		embed
		EstimatedProcessingDate *internal.DateTime `json:"estimatedProcessingDate"`
		EstimatedSettlementDate *internal.DateTime `json:"estimatedSettlementDate"`
	}{
		embed:                   embed(*c),
		EstimatedProcessingDate: internal.NewDateTime(c.EstimatedProcessingDate),
		EstimatedSettlementDate: internal.NewDateTime(c.EstimatedSettlementDate),
	}
	return json.Marshal(marshaler)
}

func (c *CalculatePaymentTimingResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EstimatedTiming struct {
	// Date the payment is scheduled to be deducted from the payer's account. Use this field if the payment has not yet been deducted.
	EstimatedDeductionDate *time.Time `json:"estimatedDeductionDate,omitempty" url:"estimatedDeductionDate,omitempty"`
	// Date the payment was processed. Use this field if the payment has already been deducted.
	ProcessedAt *time.Time `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	// ID of payment source.
	PaymentSourceID PaymentMethodID `json:"paymentSourceId" url:"paymentSourceId"`
	// ID of payment destination.
	PaymentDestinationID PaymentMethodID `json:"paymentDestinationId" url:"paymentDestinationId"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EstimatedTiming) GetEstimatedDeductionDate() *time.Time {
	if e == nil {
		return nil
	}
	return e.EstimatedDeductionDate
}

func (e *EstimatedTiming) GetProcessedAt() *time.Time {
	if e == nil {
		return nil
	}
	return e.ProcessedAt
}

func (e *EstimatedTiming) GetPaymentSourceID() PaymentMethodID {
	if e == nil {
		return ""
	}
	return e.PaymentSourceID
}

func (e *EstimatedTiming) GetPaymentDestinationID() PaymentMethodID {
	if e == nil {
		return ""
	}
	return e.PaymentDestinationID
}

func (e *EstimatedTiming) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if e == nil {
		return nil
	}
	return e.PaymentDestinationOptions
}

func (e *EstimatedTiming) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EstimatedTiming) UnmarshalJSON(data []byte) error {
	type embed EstimatedTiming
	var unmarshaler = struct {
		embed
		EstimatedDeductionDate *internal.DateTime `json:"estimatedDeductionDate,omitempty"`
		ProcessedAt            *internal.DateTime `json:"processedAt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EstimatedTiming(unmarshaler.embed)
	e.EstimatedDeductionDate = unmarshaler.EstimatedDeductionDate.TimePtr()
	e.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EstimatedTiming) MarshalJSON() ([]byte, error) {
	type embed EstimatedTiming
	var marshaler = struct {
		embed
		EstimatedDeductionDate *internal.DateTime `json:"estimatedDeductionDate,omitempty"`
		ProcessedAt            *internal.DateTime `json:"processedAt,omitempty"`
	}{
		embed:                  embed(*e),
		EstimatedDeductionDate: internal.NewOptionalDateTime(e.EstimatedDeductionDate),
		ProcessedAt:            internal.NewOptionalDateTime(e.ProcessedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EstimatedTiming) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Type of payment to calculate fees for.
type FeeCalculationType string

const (
	FeeCalculationTypePayable    FeeCalculationType = "PAYABLE"
	FeeCalculationTypeReceivable FeeCalculationType = "RECEIVABLE"
)

func NewFeeCalculationTypeFromString(s string) (FeeCalculationType, error) {
	switch s {
	case "PAYABLE":
		return FeeCalculationTypePayable, nil
	case "RECEIVABLE":
		return FeeCalculationTypeReceivable, nil
	}
	var t FeeCalculationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeeCalculationType) Ptr() *FeeCalculationType {
	return &f
}

type InvoiceTiming struct {
	InvoiceID InvoiceID `json:"invoiceId" url:"invoiceId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTiming) GetInvoiceID() InvoiceID {
	if i == nil {
		return ""
	}
	return i.InvoiceID
}

func (i *InvoiceTiming) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTiming) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceTiming
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceTiming(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTiming) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}
