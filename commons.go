// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
)

type Address struct {
	AddressLine1 string  `json:"addressLine1" url:"addressLine1"`
	AddressLine2 *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City         string  `json:"city" url:"city"`
	// State or province code. Must be in the format XX.
	StateOrProvince string `json:"stateOrProvince" url:"stateOrProvince"`
	// Postal code. Must be in the format XXXXX or XXXXX-XXXX.
	PostalCode string  `json:"postalCode" url:"postalCode"`
	Country    *string `json:"country,omitempty" url:"country,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetAddressLine1() string {
	if a == nil {
		return ""
	}
	return a.AddressLine1
}

func (a *Address) GetAddressLine2() *string {
	if a == nil {
		return nil
	}
	return a.AddressLine2
}

func (a *Address) GetCity() string {
	if a == nil {
		return ""
	}
	return a.City
}

func (a *Address) GetStateOrProvince() string {
	if a == nil {
		return ""
	}
	return a.StateOrProvince
}

func (a *Address) GetPostalCode() string {
	if a == nil {
		return ""
	}
	return a.PostalCode
}

func (a *Address) GetCountry() *string {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BirthDate struct {
	Day   *string `json:"day,omitempty" url:"day,omitempty"`
	Month *string `json:"month,omitempty" url:"month,omitempty"`
	Year  *string `json:"year,omitempty" url:"year,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BirthDate) GetDay() *string {
	if b == nil {
		return nil
	}
	return b.Day
}

func (b *BirthDate) GetMonth() *string {
	if b == nil {
		return nil
	}
	return b.Month
}

func (b *BirthDate) GetYear() *string {
	if b == nil {
		return nil
	}
	return b.Year
}

func (b *BirthDate) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BirthDate) UnmarshalJSON(data []byte) error {
	type unmarshaler BirthDate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BirthDate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BirthDate) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type DocumentResponse struct {
	// ID of the document. If not provided, this is a dynamic document that is generated on the fly.
	ID       *string      `json:"id,omitempty" url:"id,omitempty"`
	MimeType string       `json:"mimeType" url:"mimeType"`
	Type     DocumentType `json:"type" url:"type"`
	URI      string       `json:"uri" url:"uri"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentResponse) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DocumentResponse) GetMimeType() string {
	if d == nil {
		return ""
	}
	return d.MimeType
}

func (d *DocumentResponse) GetType() DocumentType {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DocumentResponse) GetURI() string {
	if d == nil {
		return ""
	}
	return d.URI
}

func (d *DocumentResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentType string

const (
	DocumentTypeInvoice       DocumentType = "INVOICE"
	DocumentTypeTenNinetyNine DocumentType = "TEN_NINETY_NINE"
	DocumentTypeW9            DocumentType = "W9"
	DocumentTypeCheck         DocumentType = "CHECK"
	DocumentTypeBankStatement DocumentType = "BANK_STATEMENT"
	DocumentTypeContract      DocumentType = "CONTRACT"
	DocumentTypeOther         DocumentType = "OTHER"
)

func NewDocumentTypeFromString(s string) (DocumentType, error) {
	switch s {
	case "INVOICE":
		return DocumentTypeInvoice, nil
	case "TEN_NINETY_NINE":
		return DocumentTypeTenNinetyNine, nil
	case "W9":
		return DocumentTypeW9, nil
	case "CHECK":
		return DocumentTypeCheck, nil
	case "BANK_STATEMENT":
		return DocumentTypeBankStatement, nil
	case "CONTRACT":
		return DocumentTypeContract, nil
	case "OTHER":
		return DocumentTypeOther, nil
	}
	var t DocumentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DocumentType) Ptr() *DocumentType {
	return &d
}

type FullName struct {
	FirstName  string  `json:"firstName" url:"firstName"`
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	LastName   string  `json:"lastName" url:"lastName"`
	Suffix     *string `json:"suffix,omitempty" url:"suffix,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FullName) GetFirstName() string {
	if f == nil {
		return ""
	}
	return f.FirstName
}

func (f *FullName) GetMiddleName() *string {
	if f == nil {
		return nil
	}
	return f.MiddleName
}

func (f *FullName) GetLastName() string {
	if f == nil {
		return ""
	}
	return f.LastName
}

func (f *FullName) GetSuffix() *string {
	if f == nil {
		return nil
	}
	return f.Suffix
}

func (f *FullName) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FullName) UnmarshalJSON(data []byte) error {
	type unmarshaler FullName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FullName(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FullName) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IndividualGovernmentID struct {
	// Full Social Security Number. Must be in the format 123-45-6789.
	Ssn string `json:"ssn" url:"ssn"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualGovernmentID) GetSsn() string {
	if i == nil {
		return ""
	}
	return i.Ssn
}

func (i *IndividualGovernmentID) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualGovernmentID) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualGovernmentID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualGovernmentID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualGovernmentID) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

func NewOrderDirectionFromString(s string) (OrderDirection, error) {
	switch s {
	case "ASC":
		return OrderDirectionAsc, nil
	case "DESC":
		return OrderDirectionDesc, nil
	}
	var t OrderDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderDirection) Ptr() *OrderDirection {
	return &o
}

type PhoneNumber struct {
	CountryCode string `json:"countryCode" url:"countryCode"`
	Number      string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhoneNumber) GetCountryCode() string {
	if p == nil {
		return ""
	}
	return p.CountryCode
}

func (p *PhoneNumber) GetNumber() string {
	if p == nil {
		return ""
	}
	return p.Number
}

func (p *PhoneNumber) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneNumber(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumber) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type StringOrStringArray struct {
	String     string
	StringList []string

	typ string
}

func (s *StringOrStringArray) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *StringOrStringArray) GetStringList() []string {
	if s == nil {
		return nil
	}
	return s.StringList
}

func (s *StringOrStringArray) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typ = "StringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StringOrStringArray) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "StringList" || s.StringList != nil {
		return json.Marshal(s.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StringOrStringArrayVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *StringOrStringArray) Accept(visitor StringOrStringArrayVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "StringList" || s.StringList != nil {
		return visitor.VisitStringList(s.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}
