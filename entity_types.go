// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type AccountType string

const (
	AccountTypeBusiness   AccountType = "business"
	AccountTypeIndividual AccountType = "individual"
)

func NewAccountTypeFromString(s string) (AccountType, error) {
	switch s {
	case "business":
		return AccountTypeBusiness, nil
	case "individual":
		return AccountTypeIndividual, nil
	}
	var t AccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountType) Ptr() *AccountType {
	return &a
}

type AmountTrigger struct {
	Amount   float64      `json:"amount" url:"amount"`
	Currency CurrencyCode `json:"currency" url:"currency"`
	// The comparison operator to use when comparing the amount to the trigger amount. Defaults to gte.
	Comparison *Comparison `json:"comparison,omitempty" url:"comparison,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AmountTrigger) GetAmount() float64 {
	if a == nil {
		return 0
	}
	return a.Amount
}

func (a *AmountTrigger) GetCurrency() CurrencyCode {
	if a == nil {
		return ""
	}
	return a.Currency
}

func (a *AmountTrigger) GetComparison() *Comparison {
	if a == nil {
		return nil
	}
	return a.Comparison
}

func (a *AmountTrigger) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AmountTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler AmountTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AmountTrigger(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AmountTrigger) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyHistoryResponse struct {
	// The ID of the approval policy history
	ID       string                    `json:"id" url:"id"`
	Policies []*ApprovalPolicyResponse `json:"policies,omitempty" url:"policies,omitempty"`
	// The user ID of the user who edited the approval policy
	UserID    EntityUserID `json:"userId" url:"userId"`
	CreatedAt time.Time    `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalPolicyHistoryResponse) GetID() string {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *ApprovalPolicyHistoryResponse) GetPolicies() []*ApprovalPolicyResponse {
	if a == nil {
		return nil
	}
	return a.Policies
}

func (a *ApprovalPolicyHistoryResponse) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *ApprovalPolicyHistoryResponse) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *ApprovalPolicyHistoryResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyHistoryResponse) UnmarshalJSON(data []byte) error {
	type embed ApprovalPolicyHistoryResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalPolicyHistoryResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyHistoryResponse) MarshalJSON() ([]byte, error) {
	type embed ApprovalPolicyHistoryResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalPolicyHistoryResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyID = string

type ApprovalPolicyRequest struct {
	// List of triggers that will cause this policy to be evaluated. If no triggers are provided, the policy will be evaluated for all invoices.
	Trigger []*Trigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule    *Rule      `json:"rule,omitempty" url:"rule,omitempty"`
	// The policy ID of the previous approval policy in the chain of policies. Use 'root' if no upstreamPolicyId is intended to be set.
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalPolicyRequest) GetTrigger() []*Trigger {
	if a == nil {
		return nil
	}
	return a.Trigger
}

func (a *ApprovalPolicyRequest) GetRule() *Rule {
	if a == nil {
		return nil
	}
	return a.Rule
}

func (a *ApprovalPolicyRequest) GetUpstreamPolicyID() ApprovalPolicyID {
	if a == nil {
		return ""
	}
	return a.UpstreamPolicyID
}

func (a *ApprovalPolicyRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyResponse struct {
	ID               ApprovalPolicyID `json:"id" url:"id"`
	Trigger          []*Trigger       `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule            `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`
	CreatedAt        time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt        time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalPolicyResponse) GetID() ApprovalPolicyID {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *ApprovalPolicyResponse) GetTrigger() []*Trigger {
	if a == nil {
		return nil
	}
	return a.Trigger
}

func (a *ApprovalPolicyResponse) GetRule() *Rule {
	if a == nil {
		return nil
	}
	return a.Rule
}

func (a *ApprovalPolicyResponse) GetUpstreamPolicyID() ApprovalPolicyID {
	if a == nil {
		return ""
	}
	return a.UpstreamPolicyID
}

func (a *ApprovalPolicyResponse) GetCreatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedAt
}

func (a *ApprovalPolicyResponse) GetUpdatedAt() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.UpdatedAt
}

func (a *ApprovalPolicyResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyResponse) UnmarshalJSON(data []byte) error {
	type embed ApprovalPolicyResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalPolicyResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyResponse) MarshalJSON() ([]byte, error) {
	type embed ApprovalPolicyResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: internal.NewDateTime(a.CreatedAt),
		UpdatedAt: internal.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalPolicyResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyUpdateRequest struct {
	Trigger          []*Trigger        `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule             `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID *ApprovalPolicyID `json:"upstreamPolicyId,omitempty" url:"upstreamPolicyId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalPolicyUpdateRequest) GetTrigger() []*Trigger {
	if a == nil {
		return nil
	}
	return a.Trigger
}

func (a *ApprovalPolicyUpdateRequest) GetRule() *Rule {
	if a == nil {
		return nil
	}
	return a.Rule
}

func (a *ApprovalPolicyUpdateRequest) GetUpstreamPolicyID() *ApprovalPolicyID {
	if a == nil {
		return nil
	}
	return a.UpstreamPolicyID
}

func (a *ApprovalPolicyUpdateRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyUpdateRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApproverRule struct {
	// Number of approvals required to approve an invoice
	NumApprovers int `json:"numApprovers" url:"numApprovers"`
	// List of users or roles that should be used to determine eligible approvers
	IdentifierList *IdentifierList `json:"identifierList,omitempty" url:"identifierList,omitempty"`
	// If true, the policy will automatically assign approvers to the invoice. If more than one approver is eligible, the policy will assign all eligible approvers to the invoice.
	AutoAssign *bool `json:"autoAssign,omitempty" url:"autoAssign,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApproverRule) GetNumApprovers() int {
	if a == nil {
		return 0
	}
	return a.NumApprovers
}

func (a *ApproverRule) GetIdentifierList() *IdentifierList {
	if a == nil {
		return nil
	}
	return a.IdentifierList
}

func (a *ApproverRule) GetAutoAssign() *bool {
	if a == nil {
		return nil
	}
	return a.AutoAssign
}

func (a *ApproverRule) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApproverRule) UnmarshalJSON(data []byte) error {
	type unmarshaler ApproverRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApproverRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApproverRule) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutomaticRule struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutomaticRule) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutomaticRule) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomaticRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomaticRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomaticRule) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BulkConnectedEntity struct {
	// The ID of the entity to connect to.
	ID EntityID `json:"id" url:"id"`
	// If true, the created entities will be linked to the connected entity as a payor (customer).
	LinkCreatedAsPayor bool `json:"linkCreatedAsPayor" url:"linkCreatedAsPayor"`
	// If true, the created entities will be linked to the connected entity as a payee (vendor).
	LinkCreatedAsPayee bool `json:"linkCreatedAsPayee" url:"linkCreatedAsPayee"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkConnectedEntity) GetID() EntityID {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BulkConnectedEntity) GetLinkCreatedAsPayor() bool {
	if b == nil {
		return false
	}
	return b.LinkCreatedAsPayor
}

func (b *BulkConnectedEntity) GetLinkCreatedAsPayee() bool {
	if b == nil {
		return false
	}
	return b.LinkCreatedAsPayee
}

func (b *BulkConnectedEntity) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkConnectedEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkConnectedEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkConnectedEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkConnectedEntity) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkEntityCreationFromObject struct {
	ConnectedEntity *BulkConnectedEntity     `json:"connectedEntity,omitempty" url:"connectedEntity,omitempty"`
	Entities        []*EntityCreationRequest `json:"entities,omitempty" url:"entities,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkEntityCreationFromObject) GetConnectedEntity() *BulkConnectedEntity {
	if b == nil {
		return nil
	}
	return b.ConnectedEntity
}

func (b *BulkEntityCreationFromObject) GetEntities() []*EntityCreationRequest {
	if b == nil {
		return nil
	}
	return b.Entities
}

func (b *BulkEntityCreationFromObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkEntityCreationFromObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkEntityCreationFromObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkEntityCreationFromObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkEntityCreationFromObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkEntityCreationFromObjectResponse struct {
	// The ID of the entity that was created. If the entity was not created, this will be undefined
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// If provided, this is the foreign ID of the entity that was created.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// The error message if the entity was not created
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkEntityCreationFromObjectResponse) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BulkEntityCreationFromObjectResponse) GetForeignID() *string {
	if b == nil {
		return nil
	}
	return b.ForeignID
}

func (b *BulkEntityCreationFromObjectResponse) GetError() *string {
	if b == nil {
		return nil
	}
	return b.Error
}

func (b *BulkEntityCreationFromObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkEntityCreationFromObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkEntityCreationFromObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkEntityCreationFromObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkEntityCreationFromObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkEntityCreationRequest struct {
	BulkEntityCreationFromObject *BulkEntityCreationFromObject

	typ string
}

func (b *BulkEntityCreationRequest) GetBulkEntityCreationFromObject() *BulkEntityCreationFromObject {
	if b == nil {
		return nil
	}
	return b.BulkEntityCreationFromObject
}

func (b *BulkEntityCreationRequest) UnmarshalJSON(data []byte) error {
	valueBulkEntityCreationFromObject := new(BulkEntityCreationFromObject)
	if err := json.Unmarshal(data, &valueBulkEntityCreationFromObject); err == nil {
		b.typ = "BulkEntityCreationFromObject"
		b.BulkEntityCreationFromObject = valueBulkEntityCreationFromObject
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BulkEntityCreationRequest) MarshalJSON() ([]byte, error) {
	if b.typ == "BulkEntityCreationFromObject" || b.BulkEntityCreationFromObject != nil {
		return json.Marshal(b.BulkEntityCreationFromObject)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BulkEntityCreationRequestVisitor interface {
	VisitBulkEntityCreationFromObject(*BulkEntityCreationFromObject) error
}

func (b *BulkEntityCreationRequest) Accept(visitor BulkEntityCreationRequestVisitor) error {
	if b.typ == "BulkEntityCreationFromObject" || b.BulkEntityCreationFromObject != nil {
		return visitor.VisitBulkEntityCreationFromObject(b.BulkEntityCreationFromObject)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", b)
}

type BulkEntityCreationResponse struct {
	Data []*BulkEntityCreationFromObjectResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkEntityCreationResponse) GetData() []*BulkEntityCreationFromObjectResponse {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BulkEntityCreationResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkEntityCreationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkEntityCreationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkEntityCreationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkEntityCreationResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessProfileRequest struct {
	// Email address for the business. Required for KYB.
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	// Phone number for the business. Required for KYB.
	Phone           *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs *string      `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	// Website URL for the business. Must be in the format http://www.example.com. Required for KYB if description is not provided.
	Website *string `json:"website,omitempty" url:"website,omitempty"`
	// Description of the business. Required for KYB if website is not provided.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Address for the business. Required for KYB.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// Tax ID for the business. Currently only EIN is supported. Required for KYB.
	TaxID *TaxID `json:"taxId,omitempty" url:"taxId,omitempty"`
	// Date of business formation
	FormationDate *time.Time `json:"formationDate,omitempty" url:"formationDate,omitempty"`
	// Industry code for the business. Required to collect funds.
	IndustryCodes *IndustryCodes `json:"industryCodes,omitempty" url:"industryCodes,omitempty"`
	// Average monthly transaction volume for the business. Required to collect funds.
	AverageMonthlyTransactionVolume *float64 `json:"averageMonthlyTransactionVolume,omitempty" url:"averageMonthlyTransactionVolume,omitempty"`
	// Average transaction size for the business. Required to collect funds.
	AverageTransactionSize *float64 `json:"averageTransactionSize,omitempty" url:"averageTransactionSize,omitempty"`
	// Maximum transaction size for the business. Required to collect funds.
	MaxTransactionSize *float64 `json:"maxTransactionSize,omitempty" url:"maxTransactionSize,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessProfileRequest) GetEmail() *string {
	if b == nil {
		return nil
	}
	return b.Email
}

func (b *BusinessProfileRequest) GetLegalBusinessName() string {
	if b == nil {
		return ""
	}
	return b.LegalBusinessName
}

func (b *BusinessProfileRequest) GetBusinessType() *BusinessType {
	if b == nil {
		return nil
	}
	return b.BusinessType
}

func (b *BusinessProfileRequest) GetPhone() *PhoneNumber {
	if b == nil {
		return nil
	}
	return b.Phone
}

func (b *BusinessProfileRequest) GetDoingBusinessAs() *string {
	if b == nil {
		return nil
	}
	return b.DoingBusinessAs
}

func (b *BusinessProfileRequest) GetWebsite() *string {
	if b == nil {
		return nil
	}
	return b.Website
}

func (b *BusinessProfileRequest) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BusinessProfileRequest) GetAddress() *Address {
	if b == nil {
		return nil
	}
	return b.Address
}

func (b *BusinessProfileRequest) GetTaxID() *TaxID {
	if b == nil {
		return nil
	}
	return b.TaxID
}

func (b *BusinessProfileRequest) GetFormationDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.FormationDate
}

func (b *BusinessProfileRequest) GetIndustryCodes() *IndustryCodes {
	if b == nil {
		return nil
	}
	return b.IndustryCodes
}

func (b *BusinessProfileRequest) GetAverageMonthlyTransactionVolume() *float64 {
	if b == nil {
		return nil
	}
	return b.AverageMonthlyTransactionVolume
}

func (b *BusinessProfileRequest) GetAverageTransactionSize() *float64 {
	if b == nil {
		return nil
	}
	return b.AverageTransactionSize
}

func (b *BusinessProfileRequest) GetMaxTransactionSize() *float64 {
	if b == nil {
		return nil
	}
	return b.MaxTransactionSize
}

func (b *BusinessProfileRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessProfileRequest) UnmarshalJSON(data []byte) error {
	type embed BusinessProfileRequest
	var unmarshaler = struct {
		embed
		FormationDate *internal.DateTime `json:"formationDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BusinessProfileRequest(unmarshaler.embed)
	b.FormationDate = unmarshaler.FormationDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileRequest) MarshalJSON() ([]byte, error) {
	type embed BusinessProfileRequest
	var marshaler = struct {
		embed
		FormationDate *internal.DateTime `json:"formationDate,omitempty"`
	}{
		embed:         embed(*b),
		FormationDate: internal.NewOptionalDateTime(b.FormationDate),
	}
	return json.Marshal(marshaler)
}

func (b *BusinessProfileRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessProfileResponse struct {
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	Phone             *PhoneNumber  `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs   *string       `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	Website           *string       `json:"website,omitempty" url:"website,omitempty"`
	Description       *string       `json:"description,omitempty" url:"description,omitempty"`
	Address           *Address      `json:"address,omitempty" url:"address,omitempty"`
	// True if all representatives have been provided for this business.
	OwnersProvided                  *bool          `json:"ownersProvided,omitempty" url:"ownersProvided,omitempty"`
	TaxIDProvided                   bool           `json:"taxIDProvided" url:"taxIDProvided"`
	TaxID                           *TaxID         `json:"taxId,omitempty" url:"taxId,omitempty"`
	FormationDate                   *time.Time     `json:"formationDate,omitempty" url:"formationDate,omitempty"`
	IndustryCodes                   *IndustryCodes `json:"industryCodes,omitempty" url:"industryCodes,omitempty"`
	AverageMonthlyTransactionVolume *float64       `json:"averageMonthlyTransactionVolume,omitempty" url:"averageMonthlyTransactionVolume,omitempty"`
	AverageTransactionSize          *float64       `json:"averageTransactionSize,omitempty" url:"averageTransactionSize,omitempty"`
	MaxTransactionSize              *float64       `json:"maxTransactionSize,omitempty" url:"maxTransactionSize,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BusinessProfileResponse) GetEmail() *string {
	if b == nil {
		return nil
	}
	return b.Email
}

func (b *BusinessProfileResponse) GetLegalBusinessName() string {
	if b == nil {
		return ""
	}
	return b.LegalBusinessName
}

func (b *BusinessProfileResponse) GetBusinessType() *BusinessType {
	if b == nil {
		return nil
	}
	return b.BusinessType
}

func (b *BusinessProfileResponse) GetPhone() *PhoneNumber {
	if b == nil {
		return nil
	}
	return b.Phone
}

func (b *BusinessProfileResponse) GetDoingBusinessAs() *string {
	if b == nil {
		return nil
	}
	return b.DoingBusinessAs
}

func (b *BusinessProfileResponse) GetWebsite() *string {
	if b == nil {
		return nil
	}
	return b.Website
}

func (b *BusinessProfileResponse) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BusinessProfileResponse) GetAddress() *Address {
	if b == nil {
		return nil
	}
	return b.Address
}

func (b *BusinessProfileResponse) GetOwnersProvided() *bool {
	if b == nil {
		return nil
	}
	return b.OwnersProvided
}

func (b *BusinessProfileResponse) GetTaxIDProvided() bool {
	if b == nil {
		return false
	}
	return b.TaxIDProvided
}

func (b *BusinessProfileResponse) GetTaxID() *TaxID {
	if b == nil {
		return nil
	}
	return b.TaxID
}

func (b *BusinessProfileResponse) GetFormationDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.FormationDate
}

func (b *BusinessProfileResponse) GetIndustryCodes() *IndustryCodes {
	if b == nil {
		return nil
	}
	return b.IndustryCodes
}

func (b *BusinessProfileResponse) GetAverageMonthlyTransactionVolume() *float64 {
	if b == nil {
		return nil
	}
	return b.AverageMonthlyTransactionVolume
}

func (b *BusinessProfileResponse) GetAverageTransactionSize() *float64 {
	if b == nil {
		return nil
	}
	return b.AverageTransactionSize
}

func (b *BusinessProfileResponse) GetMaxTransactionSize() *float64 {
	if b == nil {
		return nil
	}
	return b.MaxTransactionSize
}

func (b *BusinessProfileResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessProfileResponse) UnmarshalJSON(data []byte) error {
	type embed BusinessProfileResponse
	var unmarshaler = struct {
		embed
		FormationDate *internal.DateTime `json:"formationDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BusinessProfileResponse(unmarshaler.embed)
	b.FormationDate = unmarshaler.FormationDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileResponse) MarshalJSON() ([]byte, error) {
	type embed BusinessProfileResponse
	var marshaler = struct {
		embed
		FormationDate *internal.DateTime `json:"formationDate,omitempty"`
	}{
		embed:         embed(*b),
		FormationDate: internal.NewOptionalDateTime(b.FormationDate),
	}
	return json.Marshal(marshaler)
}

func (b *BusinessProfileResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessType string

const (
	BusinessTypeSoleProprietorship        BusinessType = "soleProprietorship"
	BusinessTypeUnincorporatedAssociation BusinessType = "unincorporatedAssociation"
	BusinessTypeTrust                     BusinessType = "trust"
	BusinessTypePublicCorporation         BusinessType = "publicCorporation"
	BusinessTypePrivateCorporation        BusinessType = "privateCorporation"
	BusinessTypeLlc                       BusinessType = "llc"
	BusinessTypePartnership               BusinessType = "partnership"
	BusinessTypeUnincorporatedNonProfit   BusinessType = "unincorporatedNonProfit"
	BusinessTypeIncorporatedNonProfit     BusinessType = "incorporatedNonProfit"
)

func NewBusinessTypeFromString(s string) (BusinessType, error) {
	switch s {
	case "soleProprietorship":
		return BusinessTypeSoleProprietorship, nil
	case "unincorporatedAssociation":
		return BusinessTypeUnincorporatedAssociation, nil
	case "trust":
		return BusinessTypeTrust, nil
	case "publicCorporation":
		return BusinessTypePublicCorporation, nil
	case "privateCorporation":
		return BusinessTypePrivateCorporation, nil
	case "llc":
		return BusinessTypeLlc, nil
	case "partnership":
		return BusinessTypePartnership, nil
	case "unincorporatedNonProfit":
		return BusinessTypeUnincorporatedNonProfit, nil
	case "incorporatedNonProfit":
		return BusinessTypeIncorporatedNonProfit, nil
	}
	var t BusinessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessType) Ptr() *BusinessType {
	return &b
}

type CardLinkTokenResponse struct {
	Token     string `json:"token" url:"token"`
	AccountID string `json:"accountId" url:"accountId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardLinkTokenResponse) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CardLinkTokenResponse) GetAccountID() string {
	if c == nil {
		return ""
	}
	return c.AccountID
}

func (c *CardLinkTokenResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardLinkTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CardLinkTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardLinkTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardLinkTokenResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatchallTrigger struct {
	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatchallTrigger) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatchallTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler CatchallTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatchallTrigger(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatchallTrigger) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Comparison string

const (
	ComparisonEq  Comparison = "eq"
	ComparisonGt  Comparison = "gt"
	ComparisonGte Comparison = "gte"
	ComparisonLt  Comparison = "lt"
	ComparisonLte Comparison = "lte"
)

func NewComparisonFromString(s string) (Comparison, error) {
	switch s {
	case "eq":
		return ComparisonEq, nil
	case "gt":
		return ComparisonGt, nil
	case "gte":
		return ComparisonGte, nil
	case "lt":
		return ComparisonLt, nil
	case "lte":
		return ComparisonLte, nil
	}
	var t Comparison
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Comparison) Ptr() *Comparison {
	return &c
}

type CounterpartyCustomizationAccount struct {
	// The ID the counterparty has assigned to this account.
	AccountID string `json:"accountId" url:"accountId"`
	// The postal code the counterparty has assigned to this account.
	PostalCode *string `json:"postalCode,omitempty" url:"postalCode,omitempty"`
	// The name on the account the counterparty has assigned to this account.
	NameOnAccount *string `json:"nameOnAccount,omitempty" url:"nameOnAccount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartyCustomizationAccount) GetAccountID() string {
	if c == nil {
		return ""
	}
	return c.AccountID
}

func (c *CounterpartyCustomizationAccount) GetPostalCode() *string {
	if c == nil {
		return nil
	}
	return c.PostalCode
}

func (c *CounterpartyCustomizationAccount) GetNameOnAccount() *string {
	if c == nil {
		return nil
	}
	return c.NameOnAccount
}

func (c *CounterpartyCustomizationAccount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyCustomizationAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyCustomizationAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyCustomizationAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyCustomizationAccount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyCustomizationRequest struct {
	CounterpartyID EntityID `json:"counterpartyId" url:"counterpartyId"`
	// The list of accounts the entity has with the counterparty.
	Accounts []*CounterpartyCustomizationAccount `json:"accounts,omitempty" url:"accounts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartyCustomizationRequest) GetCounterpartyID() EntityID {
	if c == nil {
		return ""
	}
	return c.CounterpartyID
}

func (c *CounterpartyCustomizationRequest) GetAccounts() []*CounterpartyCustomizationAccount {
	if c == nil {
		return nil
	}
	return c.Accounts
}

func (c *CounterpartyCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyCustomizationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyCustomizationRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyInvoiceMetricsResponse struct {
	TotalCount  int                                         `json:"totalCount" url:"totalCount"`
	TotalAmount float64                                     `json:"totalAmount" url:"totalAmount"`
	Statuses    []*CounterpartyInvoiceMetricsStatusResponse `json:"statuses,omitempty" url:"statuses,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartyInvoiceMetricsResponse) GetTotalCount() int {
	if c == nil {
		return 0
	}
	return c.TotalCount
}

func (c *CounterpartyInvoiceMetricsResponse) GetTotalAmount() float64 {
	if c == nil {
		return 0
	}
	return c.TotalAmount
}

func (c *CounterpartyInvoiceMetricsResponse) GetStatuses() []*CounterpartyInvoiceMetricsStatusResponse {
	if c == nil {
		return nil
	}
	return c.Statuses
}

func (c *CounterpartyInvoiceMetricsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyInvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyInvoiceMetricsStatusResponse struct {
	Status      InvoiceStatus `json:"status" url:"status"`
	TotalCount  int           `json:"totalCount" url:"totalCount"`
	TotalAmount float64       `json:"totalAmount" url:"totalAmount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartyInvoiceMetricsStatusResponse) GetStatus() InvoiceStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *CounterpartyInvoiceMetricsStatusResponse) GetTotalCount() int {
	if c == nil {
		return 0
	}
	return c.TotalCount
}

func (c *CounterpartyInvoiceMetricsStatusResponse) GetTotalAmount() float64 {
	if c == nil {
		return 0
	}
	return c.TotalAmount
}

func (c *CounterpartyInvoiceMetricsStatusResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyInvoiceMetricsStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsStatusResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsStatusResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyNetworkType string

const (
	CounterpartyNetworkTypeEntity  CounterpartyNetworkType = "ENTITY"
	CounterpartyNetworkTypeNetwork CounterpartyNetworkType = "NETWORK"
)

func NewCounterpartyNetworkTypeFromString(s string) (CounterpartyNetworkType, error) {
	switch s {
	case "ENTITY":
		return CounterpartyNetworkTypeEntity, nil
	case "NETWORK":
		return CounterpartyNetworkTypeNetwork, nil
	}
	var t CounterpartyNetworkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CounterpartyNetworkType) Ptr() *CounterpartyNetworkType {
	return &c
}

type CounterpartyResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`
	// If the entity searching for counterparties has any accounts configured in the Payee/Payor relationship, they will be returned
	Accounts         []*CounterpartyCustomizationAccount `json:"accounts,omitempty" url:"accounts,omitempty"`
	PaymentMethods   []*PaymentMethodResponse            `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	CounterpartyType []CounterpartyNetworkType           `json:"counterpartyType,omitempty" url:"counterpartyType,omitempty"`
	InvoiceMetrics   *CounterpartyInvoiceMetricsResponse `json:"invoiceMetrics,omitempty" url:"invoiceMetrics,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CounterpartyResponse) GetID() EntityID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CounterpartyResponse) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CounterpartyResponse) GetEmail() string {
	if c == nil {
		return ""
	}
	return c.Email
}

func (c *CounterpartyResponse) GetForeignID() *string {
	if c == nil {
		return nil
	}
	return c.ForeignID
}

func (c *CounterpartyResponse) GetEmailTo() *string {
	if c == nil {
		return nil
	}
	return c.EmailTo
}

func (c *CounterpartyResponse) GetEmailToAlias() []string {
	if c == nil {
		return nil
	}
	return c.EmailToAlias
}

func (c *CounterpartyResponse) GetIsCustomer() bool {
	if c == nil {
		return false
	}
	return c.IsCustomer
}

func (c *CounterpartyResponse) GetAccountType() AccountType {
	if c == nil {
		return ""
	}
	return c.AccountType
}

func (c *CounterpartyResponse) GetProfile() *ProfileResponse {
	if c == nil {
		return nil
	}
	return c.Profile
}

func (c *CounterpartyResponse) GetLogo() *string {
	if c == nil {
		return nil
	}
	return c.Logo
}

func (c *CounterpartyResponse) GetStatus() EntityStatus {
	if c == nil {
		return ""
	}
	return c.Status
}

func (c *CounterpartyResponse) GetAcceptedTos() bool {
	if c == nil {
		return false
	}
	return c.AcceptedTos
}

func (c *CounterpartyResponse) GetIsPayor() bool {
	if c == nil {
		return false
	}
	return c.IsPayor
}

func (c *CounterpartyResponse) GetIsPayee() bool {
	if c == nil {
		return false
	}
	return c.IsPayee
}

func (c *CounterpartyResponse) GetIsNetworkPayor() bool {
	if c == nil {
		return false
	}
	return c.IsNetworkPayor
}

func (c *CounterpartyResponse) GetIsNetworkPayee() bool {
	if c == nil {
		return false
	}
	return c.IsNetworkPayee
}

func (c *CounterpartyResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CounterpartyResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CounterpartyResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CounterpartyResponse) GetAccounts() []*CounterpartyCustomizationAccount {
	if c == nil {
		return nil
	}
	return c.Accounts
}

func (c *CounterpartyResponse) GetPaymentMethods() []*PaymentMethodResponse {
	if c == nil {
		return nil
	}
	return c.PaymentMethods
}

func (c *CounterpartyResponse) GetCounterpartyType() []CounterpartyNetworkType {
	if c == nil {
		return nil
	}
	return c.CounterpartyType
}

func (c *CounterpartyResponse) GetInvoiceMetrics() *CounterpartyInvoiceMetricsResponse {
	if c == nil {
		return nil
	}
	return c.InvoiceMetrics
}

func (c *CounterpartyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyResponse) UnmarshalJSON(data []byte) error {
	type embed CounterpartyResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CounterpartyResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyResponse) MarshalJSON() ([]byte, error) {
	type embed CounterpartyResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CounterpartyResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Ein struct {
	// Must be in the format XX-XXXXXXX.
	Number string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Ein) GetNumber() string {
	if e == nil {
		return ""
	}
	return e.Number
}

func (e *Ein) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Ein) UnmarshalJSON(data []byte) error {
	type unmarshaler Ein
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Ein(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Ein) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateID = string

type EmailTemplateRequest struct {
	TemplateType EmailTemplateType `json:"templateType" url:"templateType"`
	// The name of the email template.
	Name string `json:"name" url:"name"`
	// The subject of the email template.
	Subject string `json:"subject" url:"subject"`
	// The HTML content of the email template.
	Content string `json:"content" url:"content"`
	// If true, this email template will be used as the default template for new invoices.
	IsDefault *bool `json:"isDefault,omitempty" url:"isDefault,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailTemplateRequest) GetTemplateType() EmailTemplateType {
	if e == nil {
		return ""
	}
	return e.TemplateType
}

func (e *EmailTemplateRequest) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EmailTemplateRequest) GetSubject() string {
	if e == nil {
		return ""
	}
	return e.Subject
}

func (e *EmailTemplateRequest) GetContent() string {
	if e == nil {
		return ""
	}
	return e.Content
}

func (e *EmailTemplateRequest) GetIsDefault() *bool {
	if e == nil {
		return nil
	}
	return e.IsDefault
}

func (e *EmailTemplateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailTemplateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailTemplateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailTemplateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailTemplateRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateResponse struct {
	ID EmailTemplateID `json:"id" url:"id"`
	// The ID of the entity that this email template is associated with.
	EntityID     EntityID          `json:"entityId" url:"entityId"`
	TemplateType EmailTemplateType `json:"templateType" url:"templateType"`
	// The name of the email template.
	Name string `json:"name" url:"name"`
	// The subject of the email template.
	Subject string `json:"subject" url:"subject"`
	// The HTML content of the email template.
	Content string `json:"content" url:"content"`
	// True if this email template is the default template for new invoices.
	IsDefault bool `json:"isDefault" url:"isDefault"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailTemplateResponse) GetID() EmailTemplateID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EmailTemplateResponse) GetEntityID() EntityID {
	if e == nil {
		return ""
	}
	return e.EntityID
}

func (e *EmailTemplateResponse) GetTemplateType() EmailTemplateType {
	if e == nil {
		return ""
	}
	return e.TemplateType
}

func (e *EmailTemplateResponse) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EmailTemplateResponse) GetSubject() string {
	if e == nil {
		return ""
	}
	return e.Subject
}

func (e *EmailTemplateResponse) GetContent() string {
	if e == nil {
		return ""
	}
	return e.Content
}

func (e *EmailTemplateResponse) GetIsDefault() bool {
	if e == nil {
		return false
	}
	return e.IsDefault
}

func (e *EmailTemplateResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailTemplateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailTemplateResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateType string

const (
	EmailTemplateTypePayment      EmailTemplateType = "PAYMENT"
	EmailTemplateTypeDisbursement EmailTemplateType = "DISBURSEMENT"
)

func NewEmailTemplateTypeFromString(s string) (EmailTemplateType, error) {
	switch s {
	case "PAYMENT":
		return EmailTemplateTypePayment, nil
	case "DISBURSEMENT":
		return EmailTemplateTypeDisbursement, nil
	}
	var t EmailTemplateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailTemplateType) Ptr() *EmailTemplateType {
	return &e
}

type EntityAddPayeesRequest struct {
	// List of payee entity IDs or foreign IDs to associate with the entity
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`
	// List of customizations to apply to the payees. If the payee is not currently a counterparty of the entity, the counterparty will be created with the provided customizations.
	Customizations []*CounterpartyCustomizationRequest `json:"customizations,omitempty" url:"customizations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityAddPayeesRequest) GetPayees() []EntityID {
	if e == nil {
		return nil
	}
	return e.Payees
}

func (e *EntityAddPayeesRequest) GetCustomizations() []*CounterpartyCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Customizations
}

func (e *EntityAddPayeesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddPayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayeesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayeesRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityAddPayorsRequest struct {
	// List of payor entity IDs or foreign IDs to associate with the entity
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`
	// List of customizations to apply to the payors. If the payor is not currently a counterparty of the entity, the counterparty will be created with the provided customizations.
	Customizations []*CounterpartyCustomizationRequest `json:"customizations,omitempty" url:"customizations,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityAddPayorsRequest) GetPayors() []EntityID {
	if e == nil {
		return nil
	}
	return e.Payors
}

func (e *EntityAddPayorsRequest) GetCustomizations() []*CounterpartyCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Customizations
}

func (e *EntityAddPayorsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddPayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayorsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayorsRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCloneRequest struct {
	// The ID or ForeignId of the entity to clone.
	CreateFromID EntityID `json:"createFromId" url:"createFromId"`
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// Base64 data URL of the entity logo. Must be in the `data:image/*;base64,XXXX` format. We recommend a PNG image under 100KB. Supported file types are `png`, `jpeg`, `gif`, `svg`.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityCloneRequest) GetCreateFromID() EntityID {
	if e == nil {
		return ""
	}
	return e.CreateFromID
}

func (e *EntityCloneRequest) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityCloneRequest) GetEmailTo() *string {
	if e == nil {
		return nil
	}
	return e.EmailTo
}

func (e *EntityCloneRequest) GetEmailToAlias() []string {
	if e == nil {
		return nil
	}
	return e.EmailToAlias
}

func (e *EntityCloneRequest) GetLogo() *string {
	if e == nil {
		return nil
	}
	return e.Logo
}

func (e *EntityCloneRequest) GetMetadata() map[string]string {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityCloneRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCloneRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCloneRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCloneRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCloneRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCreationRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  bool            `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType     `json:"accountType" url:"accountType"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// If this entity will be receiving payments, set this to true.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// Control if this entity should be available as a payor to any entity on your platform. If set to false, this entity will only be available as a payor to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayor *bool `json:"isNetworkPayor,omitempty" url:"isNetworkPayor,omitempty"`
	// Control if this entity should be available as a payee to any entity on your platform. If set to false, this entity will only be available as a payee to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayee *bool `json:"isNetworkPayee,omitempty" url:"isNetworkPayee,omitempty"`
	// Base64 data URL of the entity logo. Must be in the `data:image/*;base64,XXXX` format. We recommend a PNG image under 100KB. Supported file types are `png`, `jpeg`, `gif`, `svg`.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityCreationRequest) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityCreationRequest) GetEmailTo() *string {
	if e == nil {
		return nil
	}
	return e.EmailTo
}

func (e *EntityCreationRequest) GetEmailToAlias() []string {
	if e == nil {
		return nil
	}
	return e.EmailToAlias
}

func (e *EntityCreationRequest) GetIsCustomer() bool {
	if e == nil {
		return false
	}
	return e.IsCustomer
}

func (e *EntityCreationRequest) GetAccountType() AccountType {
	if e == nil {
		return ""
	}
	return e.AccountType
}

func (e *EntityCreationRequest) GetProfile() *ProfileRequest {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *EntityCreationRequest) GetIsPayor() bool {
	if e == nil {
		return false
	}
	return e.IsPayor
}

func (e *EntityCreationRequest) GetIsPayee() bool {
	if e == nil {
		return false
	}
	return e.IsPayee
}

func (e *EntityCreationRequest) GetIsNetworkPayor() *bool {
	if e == nil {
		return nil
	}
	return e.IsNetworkPayor
}

func (e *EntityCreationRequest) GetIsNetworkPayee() *bool {
	if e == nil {
		return nil
	}
	return e.IsNetworkPayee
}

func (e *EntityCreationRequest) GetLogo() *string {
	if e == nil {
		return nil
	}
	return e.Logo
}

func (e *EntityCreationRequest) GetMetadata() map[string]string {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityCreationRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCreationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCreationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCreationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCreationRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCustomizationRequest struct {
	Metadata           []*MetadataCustomizationRequest      `json:"metadata,omitempty" url:"metadata,omitempty"`
	PaymentSource      []*PaymentMethodCustomizationRequest `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	BackupDisbursement []*PaymentMethodCustomizationRequest `json:"backupDisbursement,omitempty" url:"backupDisbursement,omitempty"`
	PaymentDestination []*PaymentMethodCustomizationRequest `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	Ocr                *OcrCustomizationRequest             `json:"ocr,omitempty" url:"ocr,omitempty"`
	Notifications      *NotificationCustomizationRequest    `json:"notifications,omitempty" url:"notifications,omitempty"`
	Workflow           *WorkflowCustomizationRequest        `json:"workflow,omitempty" url:"workflow,omitempty"`
	Fees               *FeeCustomizationRequest             `json:"fees,omitempty" url:"fees,omitempty"`
	RolePermissions    *RolePermissionRequest               `json:"rolePermissions,omitempty" url:"rolePermissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityCustomizationRequest) GetMetadata() []*MetadataCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityCustomizationRequest) GetPaymentSource() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.PaymentSource
}

func (e *EntityCustomizationRequest) GetBackupDisbursement() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.BackupDisbursement
}

func (e *EntityCustomizationRequest) GetPaymentDestination() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.PaymentDestination
}

func (e *EntityCustomizationRequest) GetOcr() *OcrCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Ocr
}

func (e *EntityCustomizationRequest) GetNotifications() *NotificationCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Notifications
}

func (e *EntityCustomizationRequest) GetWorkflow() *WorkflowCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Workflow
}

func (e *EntityCustomizationRequest) GetFees() *FeeCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Fees
}

func (e *EntityCustomizationRequest) GetRolePermissions() *RolePermissionRequest {
	if e == nil {
		return nil
	}
	return e.RolePermissions
}

func (e *EntityCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCustomizationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCustomizationRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCustomizationResponse struct {
	Metadata           []*MetadataCustomizationRequest      `json:"metadata,omitempty" url:"metadata,omitempty"`
	PaymentSource      []*PaymentMethodCustomizationRequest `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	BackupDisbursement []*PaymentMethodCustomizationRequest `json:"backupDisbursement,omitempty" url:"backupDisbursement,omitempty"`
	PaymentDestination []*PaymentMethodCustomizationRequest `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	Ocr                *OcrCustomizationResponse            `json:"ocr,omitempty" url:"ocr,omitempty"`
	Notifications      *NotificationCustomizationRequest    `json:"notifications,omitempty" url:"notifications,omitempty"`
	Workflow           *WorkflowCustomizationRequest        `json:"workflow,omitempty" url:"workflow,omitempty"`
	Fees               *FeeCustomizationRequest             `json:"fees,omitempty" url:"fees,omitempty"`
	RolePermissions    RolePermissionRequest                `json:"rolePermissions,omitempty" url:"rolePermissions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityCustomizationResponse) GetMetadata() []*MetadataCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityCustomizationResponse) GetPaymentSource() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.PaymentSource
}

func (e *EntityCustomizationResponse) GetBackupDisbursement() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.BackupDisbursement
}

func (e *EntityCustomizationResponse) GetPaymentDestination() []*PaymentMethodCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.PaymentDestination
}

func (e *EntityCustomizationResponse) GetOcr() *OcrCustomizationResponse {
	if e == nil {
		return nil
	}
	return e.Ocr
}

func (e *EntityCustomizationResponse) GetNotifications() *NotificationCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Notifications
}

func (e *EntityCustomizationResponse) GetWorkflow() *WorkflowCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Workflow
}

func (e *EntityCustomizationResponse) GetFees() *FeeCustomizationRequest {
	if e == nil {
		return nil
	}
	return e.Fees
}

func (e *EntityCustomizationResponse) GetRolePermissions() RolePermissionRequest {
	if e == nil {
		return nil
	}
	return e.RolePermissions
}

func (e *EntityCustomizationResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCustomizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCustomizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCustomizationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCustomizationResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEvent struct {
	// The ID of the event
	ID EntityEventID `json:"id" url:"id"`
	// The payment method data at the time of the event
	Data *EntityResponse `json:"data,omitempty" url:"data,omitempty"`
	// The list of webhook IDs associated with this event
	WebhookIDs []string `json:"webhookIds,omitempty" url:"webhookIds,omitempty"`
	// The ID of the user who triggered the event
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`
	// The ID of the entity that updated the payment method
	UpdatedByEntityID *EntityID `json:"updatedByEntityId,omitempty" url:"updatedByEntityId,omitempty"`
	// The timestamp when the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEvent) GetID() EntityEventID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EntityEvent) GetData() *EntityResponse {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EntityEvent) GetWebhookIDs() []string {
	if e == nil {
		return nil
	}
	return e.WebhookIDs
}

func (e *EntityEvent) GetUserID() *EntityUserID {
	if e == nil {
		return nil
	}
	return e.UserID
}

func (e *EntityEvent) GetUpdatedByEntityID() *EntityID {
	if e == nil {
		return nil
	}
	return e.UpdatedByEntityID
}

func (e *EntityEvent) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EntityEvent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEvent) UnmarshalJSON(data []byte) error {
	type embed EntityEvent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityEvent(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEvent) MarshalJSON() ([]byte, error) {
	type embed EntityEvent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityEvent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEventID = string

type EntityEventsResponse struct {
	Data    []*EntityEvent `json:"data,omitempty" url:"data,omitempty"`
	Count   int            `json:"count" url:"count"`
	HasMore bool           `json:"hasMore" url:"hasMore"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEventsResponse) GetData() []*EntityEvent {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EntityEventsResponse) GetCount() int {
	if e == nil {
		return 0
	}
	return e.Count
}

func (e *EntityEventsResponse) GetHasMore() bool {
	if e == nil {
		return false
	}
	return e.HasMore
}

func (e *EntityEventsResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEventsResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayeesRequest struct {
	// List of payee entity IDs or foreign IDs to hide
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityHidePayeesRequest) GetPayees() []EntityID {
	if e == nil {
		return nil
	}
	return e.Payees
}

func (e *EntityHidePayeesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityHidePayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayeesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayeesRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayorsRequest struct {
	// List of payor entity IDs or foreign IDs to hide
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityHidePayorsRequest) GetPayors() []EntityID {
	if e == nil {
		return nil
	}
	return e.Payors
}

func (e *EntityHidePayorsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityHidePayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayorsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayorsRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityID = string

type EntityMetadataResponse struct {
	Key   string   `json:"key" url:"key"`
	Value []string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityMetadataResponse) GetKey() string {
	if e == nil {
		return ""
	}
	return e.Key
}

func (e *EntityMetadataResponse) GetValue() []string {
	if e == nil {
		return nil
	}
	return e.Value
}

func (e *EntityMetadataResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityMetadataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityMetadataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityMetadataResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityMetadataResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityOnboardingLinkType string

const (
	EntityOnboardingLinkTypePayee EntityOnboardingLinkType = "PAYEE"
	EntityOnboardingLinkTypePayor EntityOnboardingLinkType = "PAYOR"
)

func NewEntityOnboardingLinkTypeFromString(s string) (EntityOnboardingLinkType, error) {
	switch s {
	case "PAYEE":
		return EntityOnboardingLinkTypePayee, nil
	case "PAYOR":
		return EntityOnboardingLinkTypePayor, nil
	}
	var t EntityOnboardingLinkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityOnboardingLinkType) Ptr() *EntityOnboardingLinkType {
	return &e
}

type EntityRequest struct {
	EntityCreationRequest *EntityCreationRequest
	EntityCloneRequest    *EntityCloneRequest

	typ string
}

func (e *EntityRequest) GetEntityCreationRequest() *EntityCreationRequest {
	if e == nil {
		return nil
	}
	return e.EntityCreationRequest
}

func (e *EntityRequest) GetEntityCloneRequest() *EntityCloneRequest {
	if e == nil {
		return nil
	}
	return e.EntityCloneRequest
}

func (e *EntityRequest) UnmarshalJSON(data []byte) error {
	valueEntityCreationRequest := new(EntityCreationRequest)
	if err := json.Unmarshal(data, &valueEntityCreationRequest); err == nil {
		e.typ = "EntityCreationRequest"
		e.EntityCreationRequest = valueEntityCreationRequest
		return nil
	}
	valueEntityCloneRequest := new(EntityCloneRequest)
	if err := json.Unmarshal(data, &valueEntityCloneRequest); err == nil {
		e.typ = "EntityCloneRequest"
		e.EntityCloneRequest = valueEntityCloneRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EntityRequest) MarshalJSON() ([]byte, error) {
	if e.typ == "EntityCreationRequest" || e.EntityCreationRequest != nil {
		return json.Marshal(e.EntityCreationRequest)
	}
	if e.typ == "EntityCloneRequest" || e.EntityCloneRequest != nil {
		return json.Marshal(e.EntityCloneRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EntityRequestVisitor interface {
	VisitEntityCreationRequest(*EntityCreationRequest) error
	VisitEntityCloneRequest(*EntityCloneRequest) error
}

func (e *EntityRequest) Accept(visitor EntityRequestVisitor) error {
	if e.typ == "EntityCreationRequest" || e.EntityCreationRequest != nil {
		return visitor.VisitEntityCreationRequest(e.EntityCreationRequest)
	}
	if e.typ == "EntityCloneRequest" || e.EntityCloneRequest != nil {
		return visitor.VisitEntityCloneRequest(e.EntityCloneRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EntityResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityResponse) GetID() EntityID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EntityResponse) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityResponse) GetEmail() string {
	if e == nil {
		return ""
	}
	return e.Email
}

func (e *EntityResponse) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityResponse) GetEmailTo() *string {
	if e == nil {
		return nil
	}
	return e.EmailTo
}

func (e *EntityResponse) GetEmailToAlias() []string {
	if e == nil {
		return nil
	}
	return e.EmailToAlias
}

func (e *EntityResponse) GetIsCustomer() bool {
	if e == nil {
		return false
	}
	return e.IsCustomer
}

func (e *EntityResponse) GetAccountType() AccountType {
	if e == nil {
		return ""
	}
	return e.AccountType
}

func (e *EntityResponse) GetProfile() *ProfileResponse {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *EntityResponse) GetLogo() *string {
	if e == nil {
		return nil
	}
	return e.Logo
}

func (e *EntityResponse) GetStatus() EntityStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EntityResponse) GetAcceptedTos() bool {
	if e == nil {
		return false
	}
	return e.AcceptedTos
}

func (e *EntityResponse) GetIsPayor() bool {
	if e == nil {
		return false
	}
	return e.IsPayor
}

func (e *EntityResponse) GetIsPayee() bool {
	if e == nil {
		return false
	}
	return e.IsPayee
}

func (e *EntityResponse) GetIsNetworkPayor() bool {
	if e == nil {
		return false
	}
	return e.IsNetworkPayor
}

func (e *EntityResponse) GetIsNetworkPayee() bool {
	if e == nil {
		return false
	}
	return e.IsNetworkPayee
}

func (e *EntityResponse) GetMetadata() map[string]string {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityResponse) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EntityResponse) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *EntityResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityResponse) UnmarshalJSON(data []byte) error {
	type embed EntityResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityResponse) MarshalJSON() ([]byte, error) {
	type embed EntityResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityStatus string

const (
	EntityStatusUnverified EntityStatus = "unverified"
	EntityStatusPending    EntityStatus = "pending"
	EntityStatusResubmit   EntityStatus = "resubmit"
	EntityStatusReview     EntityStatus = "review"
	EntityStatusVerified   EntityStatus = "verified"
	EntityStatusFailed     EntityStatus = "failed"
)

func NewEntityStatusFromString(s string) (EntityStatus, error) {
	switch s {
	case "unverified":
		return EntityStatusUnverified, nil
	case "pending":
		return EntityStatusPending, nil
	case "resubmit":
		return EntityStatusResubmit, nil
	case "review":
		return EntityStatusReview, nil
	case "verified":
		return EntityStatusVerified, nil
	case "failed":
		return EntityStatusFailed, nil
	}
	var t EntityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityStatus) Ptr() *EntityStatus {
	return &e
}

type EntityUpdateRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  *bool           `json:"isCustomer,omitempty" url:"isCustomer,omitempty"`
	AccountType *AccountType    `json:"accountType,omitempty" url:"accountType,omitempty"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor *bool `json:"isPayor,omitempty" url:"isPayor,omitempty"`
	// If this entity will be receiving payments, set this to true.
	IsPayee *bool `json:"isPayee,omitempty" url:"isPayee,omitempty"`
	// Control if this entity should be available as a payor to any entity on your platform. If set to false, this entity will only be available as a payor to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayor *bool `json:"isNetworkPayor,omitempty" url:"isNetworkPayor,omitempty"`
	// Control if this entity should be available as a payee to any entity on your platform. If set to false, this entity will only be available as a payee to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayee *bool `json:"isNetworkPayee,omitempty" url:"isNetworkPayee,omitempty"`
	// Base64 data URL of the entity logo. Must be in the `data:image/*;base64,XXXX` format. We recommend a PNG image under 100KB. Supported file types are `png`, `jpeg`, `gif`, `svg`.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity that this entity is connected to. This is used to trigger notifications to the connected entity when this entity is updated.
	ConnectedEntityID *EntityID `json:"connectedEntityId,omitempty" url:"connectedEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityUpdateRequest) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityUpdateRequest) GetEmailTo() *string {
	if e == nil {
		return nil
	}
	return e.EmailTo
}

func (e *EntityUpdateRequest) GetEmailToAlias() []string {
	if e == nil {
		return nil
	}
	return e.EmailToAlias
}

func (e *EntityUpdateRequest) GetIsCustomer() *bool {
	if e == nil {
		return nil
	}
	return e.IsCustomer
}

func (e *EntityUpdateRequest) GetAccountType() *AccountType {
	if e == nil {
		return nil
	}
	return e.AccountType
}

func (e *EntityUpdateRequest) GetProfile() *ProfileRequest {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *EntityUpdateRequest) GetIsPayor() *bool {
	if e == nil {
		return nil
	}
	return e.IsPayor
}

func (e *EntityUpdateRequest) GetIsPayee() *bool {
	if e == nil {
		return nil
	}
	return e.IsPayee
}

func (e *EntityUpdateRequest) GetIsNetworkPayor() *bool {
	if e == nil {
		return nil
	}
	return e.IsNetworkPayor
}

func (e *EntityUpdateRequest) GetIsNetworkPayee() *bool {
	if e == nil {
		return nil
	}
	return e.IsNetworkPayee
}

func (e *EntityUpdateRequest) GetLogo() *string {
	if e == nil {
		return nil
	}
	return e.Logo
}

func (e *EntityUpdateRequest) GetMetadata() map[string]string {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityUpdateRequest) GetConnectedEntityID() *EntityID {
	if e == nil {
		return nil
	}
	return e.ConnectedEntityID
}

func (e *EntityUpdateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUpdateRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserID = string

type EntityUserRequest struct {
	// The ID used to identify this user in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string `json:"email,omitempty" url:"email,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	// List of roles. A role can be any string. For example: "payer", "approver", "viewer"
	Roles []string `json:"roles,omitempty" url:"roles,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityUserRequest) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityUserRequest) GetEmail() *string {
	if e == nil {
		return nil
	}
	return e.Email
}

func (e *EntityUserRequest) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EntityUserRequest) GetRoles() []string {
	if e == nil {
		return nil
	}
	return e.Roles
}

func (e *EntityUserRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUserRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserResponse struct {
	ID EntityUserID `json:"id" url:"id"`
	// The ID used to identify this user in your system.
	ForeignID *string   `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string   `json:"email,omitempty" url:"email,omitempty"`
	Name      *string   `json:"name,omitempty" url:"name,omitempty"`
	Roles     []string  `json:"roles,omitempty" url:"roles,omitempty"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityUserResponse) GetID() EntityUserID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EntityUserResponse) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityUserResponse) GetEmail() *string {
	if e == nil {
		return nil
	}
	return e.Email
}

func (e *EntityUserResponse) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EntityUserResponse) GetRoles() []string {
	if e == nil {
		return nil
	}
	return e.Roles
}

func (e *EntityUserResponse) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EntityUserResponse) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *EntityUserResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUserResponse) UnmarshalJSON(data []byte) error {
	type embed EntityUserResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityUserResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserResponse) MarshalJSON() ([]byte, error) {
	type embed EntityUserResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityUserResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityWithPaymentMethodResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata       map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt      time.Time                `json:"createdAt" url:"createdAt"`
	UpdatedAt      time.Time                `json:"updatedAt" url:"updatedAt"`
	PaymentMethods []*PaymentMethodResponse `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityWithPaymentMethodResponse) GetID() EntityID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EntityWithPaymentMethodResponse) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityWithPaymentMethodResponse) GetEmail() string {
	if e == nil {
		return ""
	}
	return e.Email
}

func (e *EntityWithPaymentMethodResponse) GetForeignID() *string {
	if e == nil {
		return nil
	}
	return e.ForeignID
}

func (e *EntityWithPaymentMethodResponse) GetEmailTo() *string {
	if e == nil {
		return nil
	}
	return e.EmailTo
}

func (e *EntityWithPaymentMethodResponse) GetEmailToAlias() []string {
	if e == nil {
		return nil
	}
	return e.EmailToAlias
}

func (e *EntityWithPaymentMethodResponse) GetIsCustomer() bool {
	if e == nil {
		return false
	}
	return e.IsCustomer
}

func (e *EntityWithPaymentMethodResponse) GetAccountType() AccountType {
	if e == nil {
		return ""
	}
	return e.AccountType
}

func (e *EntityWithPaymentMethodResponse) GetProfile() *ProfileResponse {
	if e == nil {
		return nil
	}
	return e.Profile
}

func (e *EntityWithPaymentMethodResponse) GetLogo() *string {
	if e == nil {
		return nil
	}
	return e.Logo
}

func (e *EntityWithPaymentMethodResponse) GetStatus() EntityStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EntityWithPaymentMethodResponse) GetAcceptedTos() bool {
	if e == nil {
		return false
	}
	return e.AcceptedTos
}

func (e *EntityWithPaymentMethodResponse) GetIsPayor() bool {
	if e == nil {
		return false
	}
	return e.IsPayor
}

func (e *EntityWithPaymentMethodResponse) GetIsPayee() bool {
	if e == nil {
		return false
	}
	return e.IsPayee
}

func (e *EntityWithPaymentMethodResponse) GetIsNetworkPayor() bool {
	if e == nil {
		return false
	}
	return e.IsNetworkPayor
}

func (e *EntityWithPaymentMethodResponse) GetIsNetworkPayee() bool {
	if e == nil {
		return false
	}
	return e.IsNetworkPayee
}

func (e *EntityWithPaymentMethodResponse) GetMetadata() map[string]string {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EntityWithPaymentMethodResponse) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EntityWithPaymentMethodResponse) GetUpdatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.UpdatedAt
}

func (e *EntityWithPaymentMethodResponse) GetPaymentMethods() []*PaymentMethodResponse {
	if e == nil {
		return nil
	}
	return e.PaymentMethods
}

func (e *EntityWithPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityWithPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed EntityWithPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityWithPaymentMethodResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityWithPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed EntityWithPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
		UpdatedAt: internal.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityWithPaymentMethodResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FindCounterpartiesResponse struct {
	// Total number of counterparties for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more counterparties available for the given filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*CounterpartyResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindCounterpartiesResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindCounterpartiesResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindCounterpartiesResponse) GetData() []*CounterpartyResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindCounterpartiesResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindCounterpartiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindCounterpartiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindCounterpartiesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindCounterpartiesResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindEntityResponse struct {
	// Total number of entities for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more entities available for the given filters.
	HasMore bool                               `json:"hasMore" url:"hasMore"`
	Data    []*EntityWithPaymentMethodResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindEntityResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindEntityResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindEntityResponse) GetData() []*EntityWithPaymentMethodResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindEntityResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindEntityUserResponse struct {
	// Total number of users for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more users available for the given filters.
	HasMore bool                  `json:"hasMore" url:"hasMore"`
	Data    []*EntityUserResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindEntityUserResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindEntityUserResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindEntityUserResponse) GetData() []*EntityUserResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindEntityUserResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindEntityUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityUserResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityUserResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindNotificationResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*NotificationResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindNotificationResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindNotificationResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindNotificationResponse) GetData() []*NotificationResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindNotificationResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindNotificationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindNotificationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindNotificationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindNotificationResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IdentifierList struct {
	Type string
	// List of entity user roles that should be used to determine approvers
	RolesList []string
	// List of entity user IDs that should be used to determine approvers
	UserList []EntityUserID
}

func (i *IdentifierList) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IdentifierList) GetRolesList() []string {
	if i == nil {
		return nil
	}
	return i.RolesList
}

func (i *IdentifierList) GetUserList() []EntityUserID {
	if i == nil {
		return nil
	}
	return i.UserList
}

func (i *IdentifierList) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "rolesList":
		var valueUnmarshaler struct {
			RolesList []string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.RolesList = valueUnmarshaler.RolesList
	case "userList":
		var valueUnmarshaler struct {
			UserList []EntityUserID `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.UserList = valueUnmarshaler.UserList
	}
	return nil
}

func (i IdentifierList) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.RolesList != nil {
		var marshaler = struct {
			Type      string   `json:"type"`
			RolesList []string `json:"value,omitempty"`
		}{
			Type:      "rolesList",
			RolesList: i.RolesList,
		}
		return json.Marshal(marshaler)
	}
	if i.UserList != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			UserList []EntityUserID `json:"value,omitempty"`
		}{
			Type:     "userList",
			UserList: i.UserList,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IdentifierListVisitor interface {
	VisitRolesList([]string) error
	VisitUserList([]EntityUserID) error
}

func (i *IdentifierList) Accept(visitor IdentifierListVisitor) error {
	if i.RolesList != nil {
		return visitor.VisitRolesList(i.RolesList)
	}
	if i.UserList != nil {
		return visitor.VisitUserList(i.UserList)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *IdentifierList) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.RolesList != nil {
		fields = append(fields, "rolesList")
	}
	if i.UserList != nil {
		fields = append(fields, "userList")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

type IndividualProfileRequest struct {
	Email        *string                 `json:"email,omitempty" url:"email,omitempty"`
	Name         *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone        *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Address      *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate    *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualProfileRequest) GetEmail() *string {
	if i == nil {
		return nil
	}
	return i.Email
}

func (i *IndividualProfileRequest) GetName() *FullName {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *IndividualProfileRequest) GetPhone() *PhoneNumber {
	if i == nil {
		return nil
	}
	return i.Phone
}

func (i *IndividualProfileRequest) GetAddress() *Address {
	if i == nil {
		return nil
	}
	return i.Address
}

func (i *IndividualProfileRequest) GetBirthDate() *BirthDate {
	if i == nil {
		return nil
	}
	return i.BirthDate
}

func (i *IndividualProfileRequest) GetGovernmentID() *IndividualGovernmentID {
	if i == nil {
		return nil
	}
	return i.GovernmentID
}

func (i *IndividualProfileRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualProfileResponse struct {
	Email                *string      `json:"email,omitempty" url:"email,omitempty"`
	Name                 *FullName    `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	Address              *Address     `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool         `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool         `json:"governmentIDProvided" url:"governmentIDProvided"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndividualProfileResponse) GetEmail() *string {
	if i == nil {
		return nil
	}
	return i.Email
}

func (i *IndividualProfileResponse) GetName() *FullName {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *IndividualProfileResponse) GetPhone() *PhoneNumber {
	if i == nil {
		return nil
	}
	return i.Phone
}

func (i *IndividualProfileResponse) GetAddress() *Address {
	if i == nil {
		return nil
	}
	return i.Address
}

func (i *IndividualProfileResponse) GetBirthDateProvided() bool {
	if i == nil {
		return false
	}
	return i.BirthDateProvided
}

func (i *IndividualProfileResponse) GetGovernmentIDProvided() bool {
	if i == nil {
		return false
	}
	return i.GovernmentIDProvided
}

func (i *IndividualProfileResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndustryCodes struct {
	Mcc *string `json:"mcc,omitempty" url:"mcc,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IndustryCodes) GetMcc() *string {
	if i == nil {
		return nil
	}
	return i.Mcc
}

func (i *IndustryCodes) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndustryCodes) UnmarshalJSON(data []byte) error {
	type unmarshaler IndustryCodes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndustryCodes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndustryCodes) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LineItemAvailabilities string

const (
	LineItemAvailabilitiesDisabled LineItemAvailabilities = "DISABLED"
	LineItemAvailabilitiesOptional LineItemAvailabilities = "OPTIONAL"
	LineItemAvailabilitiesRequired LineItemAvailabilities = "REQUIRED"
)

func NewLineItemAvailabilitiesFromString(s string) (LineItemAvailabilities, error) {
	switch s {
	case "DISABLED":
		return LineItemAvailabilitiesDisabled, nil
	case "OPTIONAL":
		return LineItemAvailabilitiesOptional, nil
	case "REQUIRED":
		return LineItemAvailabilitiesRequired, nil
	}
	var t LineItemAvailabilities
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LineItemAvailabilities) Ptr() *LineItemAvailabilities {
	return &l
}

type MetadataTrigger struct {
	// The metadata key to match
	Key string `json:"key" url:"key"`
	// The metadata value the invoice must have to trigger this policy
	Value []string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetadataTrigger) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MetadataTrigger) GetValue() []string {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MetadataTrigger) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataTrigger(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataTrigger) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NotificationID = string

type NotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this entity
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`
	// List of user IDs that should receive notifications in addition to the default users for this notification type
	AdditionalUsers []EntityUserID `json:"additionalUsers,omitempty" url:"additionalUsers,omitempty"`
	// Set to true if the selected notification type should be sent to the counterparty if this is a payable invoice.
	NotifyPayeeCounterparty *bool `json:"notifyPayeeCounterparty,omitempty" url:"notifyPayeeCounterparty,omitempty"`
	// Set to true if the selected notification type should be sent to the counterparty if this is a receivable invoice.
	NotifyPayorCounterparty *bool `json:"notifyPayorCounterparty,omitempty" url:"notifyPayorCounterparty,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationPolicyRequest) GetDisabled() *bool {
	if n == nil {
		return nil
	}
	return n.Disabled
}

func (n *NotificationPolicyRequest) GetAdditionalRoles() []string {
	if n == nil {
		return nil
	}
	return n.AdditionalRoles
}

func (n *NotificationPolicyRequest) GetAdditionalUsers() []EntityUserID {
	if n == nil {
		return nil
	}
	return n.AdditionalUsers
}

func (n *NotificationPolicyRequest) GetNotifyPayeeCounterparty() *bool {
	if n == nil {
		return nil
	}
	return n.NotifyPayeeCounterparty
}

func (n *NotificationPolicyRequest) GetNotifyPayorCounterparty() *bool {
	if n == nil {
		return nil
	}
	return n.NotifyPayorCounterparty
}

func (n *NotificationPolicyRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyRequest) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this entity
	Disabled bool `json:"disabled" url:"disabled"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`
	// List of user IDs that should receive notifications in addition to the default users for this notification type
	AdditionalUsers []EntityUserID `json:"additionalUsers,omitempty" url:"additionalUsers,omitempty"`
	// True if the selected notification type should be sent to the counterparty if this is a payable invoice.
	NotifyPayeeCounterparty bool `json:"notifyPayeeCounterparty" url:"notifyPayeeCounterparty"`
	// True if the selected notification type should be sent to the counterparty if this is a receivable invoice.
	NotifyPayorCounterparty bool             `json:"notifyPayorCounterparty" url:"notifyPayorCounterparty"`
	Type                    NotificationType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationPolicyResponse) GetDisabled() bool {
	if n == nil {
		return false
	}
	return n.Disabled
}

func (n *NotificationPolicyResponse) GetAdditionalRoles() []string {
	if n == nil {
		return nil
	}
	return n.AdditionalRoles
}

func (n *NotificationPolicyResponse) GetAdditionalUsers() []EntityUserID {
	if n == nil {
		return nil
	}
	return n.AdditionalUsers
}

func (n *NotificationPolicyResponse) GetNotifyPayeeCounterparty() bool {
	if n == nil {
		return false
	}
	return n.NotifyPayeeCounterparty
}

func (n *NotificationPolicyResponse) GetNotifyPayorCounterparty() bool {
	if n == nil {
		return false
	}
	return n.NotifyPayorCounterparty
}

func (n *NotificationPolicyResponse) GetType() NotificationType {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NotificationPolicyResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyResponse) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationResponse struct {
	ID NotificationID `json:"id" url:"id"`
	// The invoice ID that this notification is related to. This field is only present for notifications related to invoices.
	InvoiceID *InvoiceID         `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`
	Type      NotificationType   `json:"type" url:"type"`
	Status    NotificationStatus `json:"status" url:"status"`
	CreatedAt time.Time          `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationResponse) GetID() NotificationID {
	if n == nil {
		return ""
	}
	return n.ID
}

func (n *NotificationResponse) GetInvoiceID() *InvoiceID {
	if n == nil {
		return nil
	}
	return n.InvoiceID
}

func (n *NotificationResponse) GetType() NotificationType {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *NotificationResponse) GetStatus() NotificationStatus {
	if n == nil {
		return ""
	}
	return n.Status
}

func (n *NotificationResponse) GetCreatedAt() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.CreatedAt
}

func (n *NotificationResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationResponse) UnmarshalJSON(data []byte) error {
	type embed NotificationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationResponse(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationResponse) MarshalJSON() ([]byte, error) {
	type embed NotificationResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*n),
		CreatedAt: internal.NewDateTime(n.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationResponse) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationStatus string

const (
	NotificationStatusPending NotificationStatus = "PENDING"
	NotificationStatusSent    NotificationStatus = "SENT"
	NotificationStatusRead    NotificationStatus = "READ"
	NotificationStatusFailed  NotificationStatus = "FAILED"
)

func NewNotificationStatusFromString(s string) (NotificationStatus, error) {
	switch s {
	case "PENDING":
		return NotificationStatusPending, nil
	case "SENT":
		return NotificationStatusSent, nil
	case "READ":
		return NotificationStatusRead, nil
	case "FAILED":
		return NotificationStatusFailed, nil
	}
	var t NotificationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationStatus) Ptr() *NotificationStatus {
	return &n
}

type NotificationType string

const (
	NotificationTypeInvoiceApprovalNeeded           NotificationType = "INVOICE_APPROVAL_NEEDED"
	NotificationTypeInvoiceApproved                 NotificationType = "INVOICE_APPROVED"
	NotificationTypeInvoiceRejected                 NotificationType = "INVOICE_REJECTED"
	NotificationTypeInvoiceScheduled                NotificationType = "INVOICE_SCHEDULED"
	NotificationTypeInvoicePending                  NotificationType = "INVOICE_PENDING"
	NotificationTypeInvoicePaid                     NotificationType = "INVOICE_PAID"
	NotificationTypeInvoiceCanceled                 NotificationType = "INVOICE_CANCELED"
	NotificationTypeInvoiceCreated                  NotificationType = "INVOICE_CREATED"
	NotificationTypeInvoiceEmailed                  NotificationType = "INVOICE_EMAILED"
	NotificationTypeInvoiceFailed                   NotificationType = "INVOICE_FAILED"
	NotificationTypeCounterpartyOnboardingCompleted NotificationType = "COUNTERPARTY_ONBOARDING_COMPLETED"
)

func NewNotificationTypeFromString(s string) (NotificationType, error) {
	switch s {
	case "INVOICE_APPROVAL_NEEDED":
		return NotificationTypeInvoiceApprovalNeeded, nil
	case "INVOICE_APPROVED":
		return NotificationTypeInvoiceApproved, nil
	case "INVOICE_REJECTED":
		return NotificationTypeInvoiceRejected, nil
	case "INVOICE_SCHEDULED":
		return NotificationTypeInvoiceScheduled, nil
	case "INVOICE_PENDING":
		return NotificationTypeInvoicePending, nil
	case "INVOICE_PAID":
		return NotificationTypeInvoicePaid, nil
	case "INVOICE_CANCELED":
		return NotificationTypeInvoiceCanceled, nil
	case "INVOICE_CREATED":
		return NotificationTypeInvoiceCreated, nil
	case "INVOICE_EMAILED":
		return NotificationTypeInvoiceEmailed, nil
	case "INVOICE_FAILED":
		return NotificationTypeInvoiceFailed, nil
	case "COUNTERPARTY_ONBOARDING_COMPLETED":
		return NotificationTypeCounterpartyOnboardingCompleted, nil
	}
	var t NotificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationType) Ptr() *NotificationType {
	return &n
}

type NotificationUpdateRequest struct {
	Status *NotificationStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NotificationUpdateRequest) GetStatus() *NotificationStatus {
	if n == nil {
		return nil
	}
	return n.Status
}

func (n *NotificationUpdateRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationUpdateRequest) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type ProfileRequest struct {
	// If this entity is a business, set this field
	Business *BusinessProfileRequest `json:"business,omitempty" url:"business,omitempty"`
	// If this entity is a individual, set this field
	Individual *IndividualProfileRequest `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProfileRequest) GetBusiness() *BusinessProfileRequest {
	if p == nil {
		return nil
	}
	return p.Business
}

func (p *ProfileRequest) GetIndividual() *IndividualProfileRequest {
	if p == nil {
		return nil
	}
	return p.Individual
}

func (p *ProfileRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileResponse struct {
	// Will be set if the entity is a business
	Business *BusinessProfileResponse `json:"business,omitempty" url:"business,omitempty"`
	// Will be set if the entity is a individual
	Individual *IndividualProfileResponse `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProfileResponse) GetBusiness() *BusinessProfileResponse {
	if p == nil {
		return nil
	}
	return p.Business
}

func (p *ProfileResponse) GetIndividual() *IndividualProfileResponse {
	if p == nil {
		return nil
	}
	return p.Individual
}

func (p *ProfileResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RepresentativeID = string

type RepresentativeRequest struct {
	Name *FullName `json:"name,omitempty" url:"name,omitempty"`
	// Either phone or email is required.
	Phone *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	// Either phone or email is required.
	Email            *string                 `json:"email,omitempty" url:"email,omitempty"`
	Address          *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate        *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID     *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`
	Responsibilities *Responsibilities       `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RepresentativeRequest) GetName() *FullName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RepresentativeRequest) GetPhone() *PhoneNumber {
	if r == nil {
		return nil
	}
	return r.Phone
}

func (r *RepresentativeRequest) GetEmail() *string {
	if r == nil {
		return nil
	}
	return r.Email
}

func (r *RepresentativeRequest) GetAddress() *Address {
	if r == nil {
		return nil
	}
	return r.Address
}

func (r *RepresentativeRequest) GetBirthDate() *BirthDate {
	if r == nil {
		return nil
	}
	return r.BirthDate
}

func (r *RepresentativeRequest) GetGovernmentID() *IndividualGovernmentID {
	if r == nil {
		return nil
	}
	return r.GovernmentID
}

func (r *RepresentativeRequest) GetResponsibilities() *Responsibilities {
	if r == nil {
		return nil
	}
	return r.Responsibilities
}

func (r *RepresentativeRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RepresentativeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepresentativeRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeRequest) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RepresentativeResponse struct {
	ID                   RepresentativeID  `json:"id" url:"id"`
	Name                 *FullName         `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber      `json:"phone,omitempty" url:"phone,omitempty"`
	Email                *string           `json:"email,omitempty" url:"email,omitempty"`
	Address              *Address          `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool              `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool              `json:"governmentIDProvided" url:"governmentIDProvided"`
	Responsibilities     *Responsibilities `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`
	CreatedOn            time.Time         `json:"createdOn" url:"createdOn"`
	UpdatedOn            time.Time         `json:"updatedOn" url:"updatedOn"`
	DisabledOn           *time.Time        `json:"disabledOn,omitempty" url:"disabledOn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RepresentativeResponse) GetID() RepresentativeID {
	if r == nil {
		return ""
	}
	return r.ID
}

func (r *RepresentativeResponse) GetName() *FullName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RepresentativeResponse) GetPhone() *PhoneNumber {
	if r == nil {
		return nil
	}
	return r.Phone
}

func (r *RepresentativeResponse) GetEmail() *string {
	if r == nil {
		return nil
	}
	return r.Email
}

func (r *RepresentativeResponse) GetAddress() *Address {
	if r == nil {
		return nil
	}
	return r.Address
}

func (r *RepresentativeResponse) GetBirthDateProvided() bool {
	if r == nil {
		return false
	}
	return r.BirthDateProvided
}

func (r *RepresentativeResponse) GetGovernmentIDProvided() bool {
	if r == nil {
		return false
	}
	return r.GovernmentIDProvided
}

func (r *RepresentativeResponse) GetResponsibilities() *Responsibilities {
	if r == nil {
		return nil
	}
	return r.Responsibilities
}

func (r *RepresentativeResponse) GetCreatedOn() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.CreatedOn
}

func (r *RepresentativeResponse) GetUpdatedOn() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.UpdatedOn
}

func (r *RepresentativeResponse) GetDisabledOn() *time.Time {
	if r == nil {
		return nil
	}
	return r.DisabledOn
}

func (r *RepresentativeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeResponse) UnmarshalJSON(data []byte) error {
	type embed RepresentativeResponse
	var unmarshaler = struct {
		embed
		CreatedOn  *internal.DateTime `json:"createdOn"`
		UpdatedOn  *internal.DateTime `json:"updatedOn"`
		DisabledOn *internal.DateTime `json:"disabledOn,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RepresentativeResponse(unmarshaler.embed)
	r.CreatedOn = unmarshaler.CreatedOn.Time()
	r.UpdatedOn = unmarshaler.UpdatedOn.Time()
	r.DisabledOn = unmarshaler.DisabledOn.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeResponse) MarshalJSON() ([]byte, error) {
	type embed RepresentativeResponse
	var marshaler = struct {
		embed
		CreatedOn  *internal.DateTime `json:"createdOn"`
		UpdatedOn  *internal.DateTime `json:"updatedOn"`
		DisabledOn *internal.DateTime `json:"disabledOn,omitempty"`
	}{
		embed:      embed(*r),
		CreatedOn:  internal.NewDateTime(r.CreatedOn),
		UpdatedOn:  internal.NewDateTime(r.UpdatedOn),
		DisabledOn: internal.NewOptionalDateTime(r.DisabledOn),
	}
	return json.Marshal(marshaler)
}

func (r *RepresentativeResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RepresentativeUpdateRequest struct {
	Name             *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone            *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Email            *string                 `json:"email,omitempty" url:"email,omitempty"`
	Address          *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate        *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID     *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`
	Responsibilities *Responsibilities       `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RepresentativeUpdateRequest) GetName() *FullName {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RepresentativeUpdateRequest) GetPhone() *PhoneNumber {
	if r == nil {
		return nil
	}
	return r.Phone
}

func (r *RepresentativeUpdateRequest) GetEmail() *string {
	if r == nil {
		return nil
	}
	return r.Email
}

func (r *RepresentativeUpdateRequest) GetAddress() *Address {
	if r == nil {
		return nil
	}
	return r.Address
}

func (r *RepresentativeUpdateRequest) GetBirthDate() *BirthDate {
	if r == nil {
		return nil
	}
	return r.BirthDate
}

func (r *RepresentativeUpdateRequest) GetGovernmentID() *IndividualGovernmentID {
	if r == nil {
		return nil
	}
	return r.GovernmentID
}

func (r *RepresentativeUpdateRequest) GetResponsibilities() *Responsibilities {
	if r == nil {
		return nil
	}
	return r.Responsibilities
}

func (r *RepresentativeUpdateRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RepresentativeUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepresentativeUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeUpdateRequest) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Responsibilities struct {
	JobTitle *string `json:"jobTitle,omitempty" url:"jobTitle,omitempty"`
	// Indicates whether this individual has significant management responsibilities within the business
	IsController *bool `json:"isController,omitempty" url:"isController,omitempty"`
	// Indicates whether this individual has an ownership stake of at least 25% in the business
	IsOwner *bool `json:"isOwner,omitempty" url:"isOwner,omitempty"`
	// Percentage of ownership in the business. Must be between 0 and 100.
	OwnershipPercentage *int `json:"ownershipPercentage,omitempty" url:"ownershipPercentage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Responsibilities) GetJobTitle() *string {
	if r == nil {
		return nil
	}
	return r.JobTitle
}

func (r *Responsibilities) GetIsController() *bool {
	if r == nil {
		return nil
	}
	return r.IsController
}

func (r *Responsibilities) GetIsOwner() *bool {
	if r == nil {
		return nil
	}
	return r.IsOwner
}

func (r *Responsibilities) GetOwnershipPercentage() *int {
	if r == nil {
		return nil
	}
	return r.OwnershipPercentage
}

func (r *Responsibilities) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Responsibilities) UnmarshalJSON(data []byte) error {
	type unmarshaler Responsibilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Responsibilities(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Responsibilities) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Rule struct {
	Type string
	// A rule that will assign approvers to an invoice.
	Approver *ApproverRule
	// A rule that will automatically approve an invoice, regardless of any other rules that were triggered.
	Automatic *AutomaticRule
}

func (r *Rule) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *Rule) GetApprover() *ApproverRule {
	if r == nil {
		return nil
	}
	return r.Approver
}

func (r *Rule) GetAutomatic() *AutomaticRule {
	if r == nil {
		return nil
	}
	return r.Automatic
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "approver":
		value := new(ApproverRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Approver = value
	case "automatic":
		value := new(AutomaticRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Automatic = value
	}
	return nil
}

func (r Rule) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Approver != nil {
		return internal.MarshalJSONWithExtraProperty(r.Approver, "type", "approver")
	}
	if r.Automatic != nil {
		return internal.MarshalJSONWithExtraProperty(r.Automatic, "type", "automatic")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RuleVisitor interface {
	VisitApprover(*ApproverRule) error
	VisitAutomatic(*AutomaticRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	if r.Approver != nil {
		return visitor.VisitApprover(r.Approver)
	}
	if r.Automatic != nil {
		return visitor.VisitAutomatic(r.Automatic)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *Rule) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Approver != nil {
		fields = append(fields, "approver")
	}
	if r.Automatic != nil {
		fields = append(fields, "automatic")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

type TaxID struct {
	Ein *Ein `json:"ein,omitempty" url:"ein,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaxID) GetEin() *Ein {
	if t == nil {
		return nil
	}
	return t.Ein
}

func (t *TaxID) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxID) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxID) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationEntityOptions struct {
	// If true, will require entity to undergo KYB to use Mercoa payment rails and will capture required KYB data in the portal.
	EnableMercoaPayments *bool `json:"enableMercoaPayments,omitempty" url:"enableMercoaPayments,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationEntityOptions) GetEnableMercoaPayments() *bool {
	if t == nil {
		return nil
	}
	return t.EnableMercoaPayments
}

func (t *TokenGenerationEntityOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationEntityOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationEntityOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationEntityOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationEntityOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationInvoiceOptions struct {
	// Defaults to OPTIONAL. If set to REQUIRED, the user will be required to provide at least one line item when creating an invoice. If set to DISABLED, the user will not be able to provide line items when creating an invoice.
	LineItems *LineItemAvailabilities `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	Status    []InvoiceStatus         `json:"status,omitempty" url:"status,omitempty"`
	// If true, recurring invoice templates will be available to the user.
	Recurring *bool `json:"recurring,omitempty" url:"recurring,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationInvoiceOptions) GetLineItems() *LineItemAvailabilities {
	if t == nil {
		return nil
	}
	return t.LineItems
}

func (t *TokenGenerationInvoiceOptions) GetStatus() []InvoiceStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TokenGenerationInvoiceOptions) GetRecurring() *bool {
	if t == nil {
		return nil
	}
	return t.Recurring
}

func (t *TokenGenerationInvoiceOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationInvoiceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationInvoiceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationInvoiceOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationInvoiceOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationOptions struct {
	// Expressed in seconds or a string describing a time span. The default is 1h.
	ExpiresIn *string                        `json:"expiresIn,omitempty" url:"expiresIn,omitempty"`
	Invoice   *TokenGenerationInvoiceOptions `json:"invoice,omitempty" url:"invoice,omitempty"`
	Pages     *TokenGenerationPagesOptions   `json:"pages,omitempty" url:"pages,omitempty"`
	Style     *TokenGenerationStyleOptions   `json:"style,omitempty" url:"style,omitempty"`
	Vendors   *TokenGenerationVendorOptions  `json:"vendors,omitempty" url:"vendors,omitempty"`
	Entity    *TokenGenerationEntityOptions  `json:"entity,omitempty" url:"entity,omitempty"`
	// Optional session ID to use for the token. If not provided, this token will not be associated with a session.
	SessionID *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationOptions) GetExpiresIn() *string {
	if t == nil {
		return nil
	}
	return t.ExpiresIn
}

func (t *TokenGenerationOptions) GetInvoice() *TokenGenerationInvoiceOptions {
	if t == nil {
		return nil
	}
	return t.Invoice
}

func (t *TokenGenerationOptions) GetPages() *TokenGenerationPagesOptions {
	if t == nil {
		return nil
	}
	return t.Pages
}

func (t *TokenGenerationOptions) GetStyle() *TokenGenerationStyleOptions {
	if t == nil {
		return nil
	}
	return t.Style
}

func (t *TokenGenerationOptions) GetVendors() *TokenGenerationVendorOptions {
	if t == nil {
		return nil
	}
	return t.Vendors
}

func (t *TokenGenerationOptions) GetEntity() *TokenGenerationEntityOptions {
	if t == nil {
		return nil
	}
	return t.Entity
}

func (t *TokenGenerationOptions) GetSessionID() *string {
	if t == nil {
		return nil
	}
	return t.SessionID
}

func (t *TokenGenerationOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationPagesOptions struct {
	PaymentMethods  *bool `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	Representatives *bool `json:"representatives,omitempty" url:"representatives,omitempty"`
	Notifications   *bool `json:"notifications,omitempty" url:"notifications,omitempty"`
	Counterparties  *bool `json:"counterparties,omitempty" url:"counterparties,omitempty"`
	Approvals       *bool `json:"approvals,omitempty" url:"approvals,omitempty"`
	EmailLog        *bool `json:"emailLog,omitempty" url:"emailLog,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationPagesOptions) GetPaymentMethods() *bool {
	if t == nil {
		return nil
	}
	return t.PaymentMethods
}

func (t *TokenGenerationPagesOptions) GetRepresentatives() *bool {
	if t == nil {
		return nil
	}
	return t.Representatives
}

func (t *TokenGenerationPagesOptions) GetNotifications() *bool {
	if t == nil {
		return nil
	}
	return t.Notifications
}

func (t *TokenGenerationPagesOptions) GetCounterparties() *bool {
	if t == nil {
		return nil
	}
	return t.Counterparties
}

func (t *TokenGenerationPagesOptions) GetApprovals() *bool {
	if t == nil {
		return nil
	}
	return t.Approvals
}

func (t *TokenGenerationPagesOptions) GetEmailLog() *bool {
	if t == nil {
		return nil
	}
	return t.EmailLog
}

func (t *TokenGenerationPagesOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationPagesOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationPagesOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationPagesOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationPagesOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationStyleOptions struct {
	PrimaryColor string `json:"primaryColor" url:"primaryColor"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationStyleOptions) GetPrimaryColor() string {
	if t == nil {
		return ""
	}
	return t.PrimaryColor
}

func (t *TokenGenerationStyleOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationStyleOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationStyleOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationStyleOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationStyleOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationVendorOptions struct {
	// If true, the user will not be able to create new vendors.
	DisableCreation *bool         `json:"disableCreation,omitempty" url:"disableCreation,omitempty"`
	Network         VendorNetwork `json:"network" url:"network"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenGenerationVendorOptions) GetDisableCreation() *bool {
	if t == nil {
		return nil
	}
	return t.DisableCreation
}

func (t *TokenGenerationVendorOptions) GetNetwork() VendorNetwork {
	if t == nil {
		return ""
	}
	return t.Network
}

func (t *TokenGenerationVendorOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationVendorOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationVendorOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationVendorOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationVendorOptions) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Trigger struct {
	Type     string
	Amount   *AmountTrigger
	Vendor   *VendorTrigger
	Metadata *MetadataTrigger
	// A catchall trigger will trigger if no other triggers match.
	Catchall *CatchallTrigger
}

func (t *Trigger) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Trigger) GetAmount() *AmountTrigger {
	if t == nil {
		return nil
	}
	return t.Amount
}

func (t *Trigger) GetVendor() *VendorTrigger {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *Trigger) GetMetadata() *MetadataTrigger {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *Trigger) GetCatchall() *CatchallTrigger {
	if t == nil {
		return nil
	}
	return t.Catchall
}

func (t *Trigger) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "amount":
		value := new(AmountTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Amount = value
	case "vendor":
		value := new(VendorTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Vendor = value
	case "metadata":
		value := new(MetadataTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Metadata = value
	case "catchall":
		value := new(CatchallTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Catchall = value
	}
	return nil
}

func (t Trigger) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Amount != nil {
		return internal.MarshalJSONWithExtraProperty(t.Amount, "type", "amount")
	}
	if t.Vendor != nil {
		return internal.MarshalJSONWithExtraProperty(t.Vendor, "type", "vendor")
	}
	if t.Metadata != nil {
		return internal.MarshalJSONWithExtraProperty(t.Metadata, "type", "metadata")
	}
	if t.Catchall != nil {
		return internal.MarshalJSONWithExtraProperty(t.Catchall, "type", "catchall")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TriggerVisitor interface {
	VisitAmount(*AmountTrigger) error
	VisitVendor(*VendorTrigger) error
	VisitMetadata(*MetadataTrigger) error
	VisitCatchall(*CatchallTrigger) error
}

func (t *Trigger) Accept(visitor TriggerVisitor) error {
	if t.Amount != nil {
		return visitor.VisitAmount(t.Amount)
	}
	if t.Vendor != nil {
		return visitor.VisitVendor(t.Vendor)
	}
	if t.Metadata != nil {
		return visitor.VisitMetadata(t.Metadata)
	}
	if t.Catchall != nil {
		return visitor.VisitCatchall(t.Catchall)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Trigger) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Amount != nil {
		fields = append(fields, "amount")
	}
	if t.Vendor != nil {
		fields = append(fields, "vendor")
	}
	if t.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if t.Catchall != nil {
		fields = append(fields, "catchall")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type UserNotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this user
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// Set to true if the selected notification type should be sent as a digest. Default is false.
	Digest *bool `json:"digest,omitempty" url:"digest,omitempty"`
	// Set to true if the selected notification type should be sent immediately. Default is true.
	Immediate *bool `json:"immediate,omitempty" url:"immediate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserNotificationPolicyRequest) GetDisabled() *bool {
	if u == nil {
		return nil
	}
	return u.Disabled
}

func (u *UserNotificationPolicyRequest) GetDigest() *bool {
	if u == nil {
		return nil
	}
	return u.Digest
}

func (u *UserNotificationPolicyRequest) GetImmediate() *bool {
	if u == nil {
		return nil
	}
	return u.Immediate
}

func (u *UserNotificationPolicyRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserNotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyRequest) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserNotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this user
	Disabled bool `json:"disabled" url:"disabled"`
	// True if the selected notification type is sent as a digest.
	Digest bool `json:"digest" url:"digest"`
	// True if the selected notification type is sent immediately.
	Immediate bool             `json:"immediate" url:"immediate"`
	Type      NotificationType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserNotificationPolicyResponse) GetDisabled() bool {
	if u == nil {
		return false
	}
	return u.Disabled
}

func (u *UserNotificationPolicyResponse) GetDigest() bool {
	if u == nil {
		return false
	}
	return u.Digest
}

func (u *UserNotificationPolicyResponse) GetImmediate() bool {
	if u == nil {
		return false
	}
	return u.Immediate
}

func (u *UserNotificationPolicyResponse) GetType() NotificationType {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UserNotificationPolicyResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserNotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VendorNetwork string

const (
	VendorNetworkAll      VendorNetwork = "all"
	VendorNetworkPlatform VendorNetwork = "platform"
	VendorNetworkEntity   VendorNetwork = "entity"
)

func NewVendorNetworkFromString(s string) (VendorNetwork, error) {
	switch s {
	case "all":
		return VendorNetworkAll, nil
	case "platform":
		return VendorNetworkPlatform, nil
	case "entity":
		return VendorNetworkEntity, nil
	}
	var t VendorNetwork
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VendorNetwork) Ptr() *VendorNetwork {
	return &v
}

type VendorPortalOptions struct {
	// The tabs to display in the vendor portal. If not provided, all tabs will be displayed.
	Tabs []VendorPortalTab `json:"tabs,omitempty" url:"tabs,omitempty"`
	// The default tab to display in the vendor portal. If not provided, the HOME tab will be displayed.
	DefaultTab *VendorPortalTab `json:"defaultTab,omitempty" url:"defaultTab,omitempty"`
	// The welcome message to display in the vendor portal. If not provided, no welcome message will be displayed.
	WelcomeMessage *string `json:"welcomeMessage,omitempty" url:"welcomeMessage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorPortalOptions) GetTabs() []VendorPortalTab {
	if v == nil {
		return nil
	}
	return v.Tabs
}

func (v *VendorPortalOptions) GetDefaultTab() *VendorPortalTab {
	if v == nil {
		return nil
	}
	return v.DefaultTab
}

func (v *VendorPortalOptions) GetWelcomeMessage() *string {
	if v == nil {
		return nil
	}
	return v.WelcomeMessage
}

func (v *VendorPortalOptions) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorPortalOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorPortalOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorPortalOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorPortalOptions) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorPortalTab string

const (
	VendorPortalTabHome           VendorPortalTab = "HOME"
	VendorPortalTabProfile        VendorPortalTab = "PROFILE"
	VendorPortalTabInvoices       VendorPortalTab = "INVOICES"
	VendorPortalTabPaymentMethods VendorPortalTab = "PAYMENT_METHODS"
	VendorPortalTabVendorCredits  VendorPortalTab = "VENDOR_CREDITS"
)

func NewVendorPortalTabFromString(s string) (VendorPortalTab, error) {
	switch s {
	case "HOME":
		return VendorPortalTabHome, nil
	case "PROFILE":
		return VendorPortalTabProfile, nil
	case "INVOICES":
		return VendorPortalTabInvoices, nil
	case "PAYMENT_METHODS":
		return VendorPortalTabPaymentMethods, nil
	case "VENDOR_CREDITS":
		return VendorPortalTabVendorCredits, nil
	}
	var t VendorPortalTab
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VendorPortalTab) Ptr() *VendorPortalTab {
	return &v
}

type VendorTrigger struct {
	VendorIDs []EntityID `json:"vendorIds,omitempty" url:"vendorIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorTrigger) GetVendorIDs() []EntityID {
	if v == nil {
		return nil
	}
	return v.VendorIDs
}

func (v *VendorTrigger) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorTrigger(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorTrigger) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
