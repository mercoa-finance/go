// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
)

type OcrAsyncResponse struct {
	JobID OcrJobID `json:"jobId" url:"jobId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrAsyncResponse) GetJobID() OcrJobID {
	if o == nil {
		return ""
	}
	return o.JobID
}

func (o *OcrAsyncResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAsyncResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAsyncResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAsyncResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAsyncResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrJobID = string

type OcrJobResponse struct {
	JobID OcrJobID `json:"jobId" url:"jobId"`
	// The IDs of any OCR jobs that are processing other subdocuments of the same document.
	LinkedJobIDs []OcrJobID `json:"linkedJobIds,omitempty" url:"linkedJobIds,omitempty"`
	// The status of the OCR job.
	Status OcrJobStatus `json:"status" url:"status"`
	// The start and end page numbers of the corresponding subdocument (zero-indexed, inclusive). If not provided, the document was not split during OCR.
	PageRange *OcrPageRange `json:"pageRange,omitempty" url:"pageRange,omitempty"`
	Data      *OcrResponse  `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrJobResponse) GetJobID() OcrJobID {
	if o == nil {
		return ""
	}
	return o.JobID
}

func (o *OcrJobResponse) GetLinkedJobIDs() []OcrJobID {
	if o == nil {
		return nil
	}
	return o.LinkedJobIDs
}

func (o *OcrJobResponse) GetStatus() OcrJobStatus {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *OcrJobResponse) GetPageRange() *OcrPageRange {
	if o == nil {
		return nil
	}
	return o.PageRange
}

func (o *OcrJobResponse) GetData() *OcrResponse {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OcrJobResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrJobResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrJobResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrJobStatus string

const (
	OcrJobStatusPending OcrJobStatus = "pending"
	OcrJobStatusSuccess OcrJobStatus = "success"
	OcrJobStatusFailed  OcrJobStatus = "failed"
)

func NewOcrJobStatusFromString(s string) (OcrJobStatus, error) {
	switch s {
	case "pending":
		return OcrJobStatusPending, nil
	case "success":
		return OcrJobStatusSuccess, nil
	case "failed":
		return OcrJobStatusFailed, nil
	}
	var t OcrJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrJobStatus) Ptr() *OcrJobStatus {
	return &o
}

type OcrPageRange struct {
	Start int `json:"start" url:"start"`
	End   int `json:"end" url:"end"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrPageRange) GetStart() int {
	if o == nil {
		return 0
	}
	return o.Start
}

func (o *OcrPageRange) GetEnd() int {
	if o == nil {
		return 0
	}
	return o.End
}

func (o *OcrPageRange) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrPageRange) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrPageRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrPageRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrPageRange) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrRequest struct {
	// MIME type of the image. Supported types are image/png, image/jpeg, and application/pdf.
	MimeType string `json:"mimeType" url:"mimeType"`
	// Base64 encoded image or PDF. PNG, JPG, WEBP, and PDF are supported. 10MB max.
	Image string `json:"image" url:"image"`
	// Limit OCR vendor search to a specific network
	VendorNetwork *VendorNetwork `json:"vendorNetwork,omitempty" url:"vendorNetwork,omitempty"`
	// When using the Entity vendor network, specify the entity to use. EntityId on an auth token will take precedence over this parameter.
	EntityID *EntityID `json:"entityId,omitempty" url:"entityId,omitempty"`
	// If true, attempt to split the document into subdocuments before processing. Default is false. If a document is split into subdocuments, the linked OCR jobs will be accessible via the linkedJobIds field on each OCR job response.
	SplitDocument *bool `json:"splitDocument,omitempty" url:"splitDocument,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrRequest) GetMimeType() string {
	if o == nil {
		return ""
	}
	return o.MimeType
}

func (o *OcrRequest) GetImage() string {
	if o == nil {
		return ""
	}
	return o.Image
}

func (o *OcrRequest) GetVendorNetwork() *VendorNetwork {
	if o == nil {
		return nil
	}
	return o.VendorNetwork
}

func (o *OcrRequest) GetEntityID() *EntityID {
	if o == nil {
		return nil
	}
	return o.EntityID
}

func (o *OcrRequest) GetSplitDocument() *bool {
	if o == nil {
		return nil
	}
	return o.SplitDocument
}

func (o *OcrRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrRequest) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponse struct {
	JobID       OcrJobID              `json:"jobId" url:"jobId"`
	Invoice     *InvoiceResponse      `json:"invoice" url:"invoice"`
	Vendor      *CounterpartyResponse `json:"vendor" url:"vendor"`
	Check       *CheckResponse        `json:"check,omitempty" url:"check,omitempty"`
	BankAccount *BankAccountResponse  `json:"bankAccount,omitempty" url:"bankAccount,omitempty"`
	Payer       *EntityResponse       `json:"payer,omitempty" url:"payer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResponse) GetJobID() OcrJobID {
	if o == nil {
		return ""
	}
	return o.JobID
}

func (o *OcrResponse) GetInvoice() *InvoiceResponse {
	if o == nil {
		return nil
	}
	return o.Invoice
}

func (o *OcrResponse) GetVendor() *CounterpartyResponse {
	if o == nil {
		return nil
	}
	return o.Vendor
}

func (o *OcrResponse) GetCheck() *CheckResponse {
	if o == nil {
		return nil
	}
	return o.Check
}

func (o *OcrResponse) GetBankAccount() *BankAccountResponse {
	if o == nil {
		return nil
	}
	return o.BankAccount
}

func (o *OcrResponse) GetPayer() *EntityResponse {
	if o == nil {
		return nil
	}
	return o.Payer
}

func (o *OcrResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}
