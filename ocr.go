// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mercoa-finance/go/core"
)

type OcrAsyncResponse struct {
	JobID OcrJobID `json:"jobId" url:"jobId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OcrAsyncResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrAsyncResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrAsyncResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrAsyncResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrAsyncResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrJobResponse struct {
	JobID  OcrJobID     `json:"jobId" url:"jobId"`
	Status OcrJobStatus `json:"status" url:"status"`
	Data   *OcrResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OcrJobResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrJobResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrJobResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrJobStatus string

const (
	OcrJobStatusPending OcrJobStatus = "pending"
	OcrJobStatusSuccess OcrJobStatus = "success"
	OcrJobStatusFailed  OcrJobStatus = "failed"
)

func NewOcrJobStatusFromString(s string) (OcrJobStatus, error) {
	switch s {
	case "pending":
		return OcrJobStatusPending, nil
	case "success":
		return OcrJobStatusSuccess, nil
	case "failed":
		return OcrJobStatusFailed, nil
	}
	var t OcrJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrJobStatus) Ptr() *OcrJobStatus {
	return &o
}

type OcrRequest struct {
	// MIME type of the image. Supported types are image/png, image/jpeg, and application/pdf.
	MimeType string `json:"mimeType" url:"mimeType"`
	// Base64 encoded image or PDF. PNG, JPG, WEBP, and PDF are supported. 10MB max.
	Image string `json:"image" url:"image"`
	// Limit OCR vendor search to a specific network
	VendorNetwork *VendorNetwork `json:"vendorNetwork,omitempty" url:"vendorNetwork,omitempty"`
	// When using the Entity vendor network, specify the entity to use if. EntityId on an auth token will take precedence over this parameter.
	EntityID *EntityID `json:"entityId,omitempty" url:"entityId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OcrRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OcrResponse struct {
	JobID       OcrJobID              `json:"jobId" url:"jobId"`
	Invoice     *InvoiceResponse      `json:"invoice,omitempty" url:"invoice,omitempty"`
	Vendor      *CounterpartyResponse `json:"vendor,omitempty" url:"vendor,omitempty"`
	Check       *CheckResponse        `json:"check,omitempty" url:"check,omitempty"`
	BankAccount *BankAccountResponse  `json:"bankAccount,omitempty" url:"bankAccount,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OcrResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}
