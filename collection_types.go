// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type ActionBase struct {
	ID ActionID `json:"id" url:"id"`
	// The UTC timestamp for when this action is scheduled for execution. Actual execution may be delayed by a few minutes due to processing time.
	ScheduledExecutionTime time.Time `json:"scheduledExecutionTime" url:"scheduledExecutionTime"`
	// The current lifecycle state of the action. SUGGESTED actions are pending approval, APPROVED actions will be executed, and COMPLETED actions have been executed.
	Status ActionStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionBase) GetID() ActionID {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *ActionBase) GetScheduledExecutionTime() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.ScheduledExecutionTime
}

func (a *ActionBase) GetStatus() ActionStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *ActionBase) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionBase) UnmarshalJSON(data []byte) error {
	type embed ActionBase
	var unmarshaler = struct {
		embed
		ScheduledExecutionTime *internal.DateTime `json:"scheduledExecutionTime"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ActionBase(unmarshaler.embed)
	a.ScheduledExecutionTime = unmarshaler.ScheduledExecutionTime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionBase) MarshalJSON() ([]byte, error) {
	type embed ActionBase
	var marshaler = struct {
		embed
		ScheduledExecutionTime *internal.DateTime `json:"scheduledExecutionTime"`
	}{
		embed:                  embed(*a),
		ScheduledExecutionTime: internal.NewDateTime(a.ScheduledExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (a *ActionBase) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionID = string

type ActionResponse struct {
	Type  string
	Email *EmailCollectionActionResponse
}

func (a *ActionResponse) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionResponse) GetEmail() *EmailCollectionActionResponse {
	if a == nil {
		return nil
	}
	return a.Email
}

func (a *ActionResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "email":
		value := new(EmailCollectionActionResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Email = value
	}
	return nil
}

func (a ActionResponse) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Email != nil {
		return internal.MarshalJSONWithExtraProperty(a.Email, "type", "email")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ActionResponseVisitor interface {
	VisitEmail(*EmailCollectionActionResponse) error
}

func (a *ActionResponse) Accept(visitor ActionResponseVisitor) error {
	if a.Email != nil {
		return visitor.VisitEmail(a.Email)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *ActionResponse) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Email != nil {
		fields = append(fields, "email")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

type ActionStatus string

const (
	ActionStatusSuggested ActionStatus = "SUGGESTED"
	ActionStatusApproved  ActionStatus = "APPROVED"
	ActionStatusCompleted ActionStatus = "COMPLETED"
)

func NewActionStatusFromString(s string) (ActionStatus, error) {
	switch s {
	case "SUGGESTED":
		return ActionStatusSuggested, nil
	case "APPROVED":
		return ActionStatusApproved, nil
	case "COMPLETED":
		return ActionStatusCompleted, nil
	}
	var t ActionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionStatus) Ptr() *ActionStatus {
	return &a
}

type EmailCollectionActionResponse struct {
	ID ActionID `json:"id" url:"id"`
	// The UTC timestamp for when this action is scheduled for execution. Actual execution may be delayed by a few minutes due to processing time.
	ScheduledExecutionTime time.Time `json:"scheduledExecutionTime" url:"scheduledExecutionTime"`
	// The current lifecycle state of the action. SUGGESTED actions are pending approval, APPROVED actions will be executed, and COMPLETED actions have been executed.
	Status ActionStatus `json:"status" url:"status"`
	// The subject of the email
	Subject string `json:"subject" url:"subject"`
	// The body of the email in plaintext
	Body string `json:"body" url:"body"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailCollectionActionResponse) GetID() ActionID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EmailCollectionActionResponse) GetScheduledExecutionTime() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.ScheduledExecutionTime
}

func (e *EmailCollectionActionResponse) GetStatus() ActionStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EmailCollectionActionResponse) GetSubject() string {
	if e == nil {
		return ""
	}
	return e.Subject
}

func (e *EmailCollectionActionResponse) GetBody() string {
	if e == nil {
		return ""
	}
	return e.Body
}

func (e *EmailCollectionActionResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailCollectionActionResponse) UnmarshalJSON(data []byte) error {
	type embed EmailCollectionActionResponse
	var unmarshaler = struct {
		embed
		ScheduledExecutionTime *internal.DateTime `json:"scheduledExecutionTime"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmailCollectionActionResponse(unmarshaler.embed)
	e.ScheduledExecutionTime = unmarshaler.ScheduledExecutionTime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailCollectionActionResponse) MarshalJSON() ([]byte, error) {
	type embed EmailCollectionActionResponse
	var marshaler = struct {
		embed
		ScheduledExecutionTime *internal.DateTime `json:"scheduledExecutionTime"`
	}{
		embed:                  embed(*e),
		ScheduledExecutionTime: internal.NewDateTime(e.ScheduledExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (e *EmailCollectionActionResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailMessageResponse struct {
	// The subject of the email
	Subject string `json:"subject" url:"subject"`
	// The body of the email in plaintext
	Body string `json:"body" url:"body"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailMessageResponse) GetSubject() string {
	if e == nil {
		return ""
	}
	return e.Subject
}

func (e *EmailMessageResponse) GetBody() string {
	if e == nil {
		return ""
	}
	return e.Body
}

func (e *EmailMessageResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailMessageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailMessageResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type UpdateNextActionRequest struct {
	// Natural language feedback to update the collection agent's next action
	Feedback string `json:"feedback" url:"feedback"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateNextActionRequest) GetFeedback() string {
	if u == nil {
		return ""
	}
	return u.Feedback
}

func (u *UpdateNextActionRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateNextActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateNextActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateNextActionRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateNextActionRequest) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
