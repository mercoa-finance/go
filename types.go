// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mercoa-finance/go/core"
	time "time"
)

type BankAddress struct {
	Address             string `json:"address" url:"address"`
	City                string `json:"city" url:"city"`
	State               string `json:"state" url:"state"`
	PostalCode          string `json:"postalCode" url:"postalCode"`
	PostalCodeExtension string `json:"postalCodeExtension" url:"postalCodeExtension"`

	_rawJSON json.RawMessage
}

func (b *BankAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAddress(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAddress) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Address struct {
	AddressLine1 string  `json:"addressLine1" url:"addressLine1"`
	AddressLine2 *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City         string  `json:"city" url:"city"`
	// State or province code. Must be in the format XX.
	StateOrProvince string  `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode      string  `json:"postalCode" url:"postalCode"`
	Country         *string `json:"country,omitempty" url:"country,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BirthDate struct {
	Day   *string `json:"day,omitempty" url:"day,omitempty"`
	Month *string `json:"month,omitempty" url:"month,omitempty"`
	Year  *string `json:"year,omitempty" url:"year,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BirthDate) UnmarshalJSON(data []byte) error {
	type unmarshaler BirthDate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BirthDate(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BirthDate) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type FullName struct {
	FirstName  string  `json:"firstName" url:"firstName"`
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	LastName   string  `json:"lastName" url:"lastName"`
	Suffix     *string `json:"suffix,omitempty" url:"suffix,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FullName) UnmarshalJSON(data []byte) error {
	type unmarshaler FullName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FullName(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FullName) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IndividualGovernmentID struct {
	// Full Social Security Number. Must be in the format 123-45-6789.
	Ssn string `json:"ssn" url:"ssn"`

	_rawJSON json.RawMessage
}

func (i *IndividualGovernmentID) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualGovernmentID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualGovernmentID(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualGovernmentID) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

func NewOrderDirectionFromString(s string) (OrderDirection, error) {
	switch s {
	case "ASC":
		return OrderDirectionAsc, nil
	case "DESC":
		return OrderDirectionDesc, nil
	}
	var t OrderDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderDirection) Ptr() *OrderDirection {
	return &o
}

type PhoneNumber struct {
	CountryCode string `json:"countryCode" url:"countryCode"`
	Number      string `json:"number" url:"number"`

	_rawJSON json.RawMessage
}

func (p *PhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneNumber(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumber) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type EmailLog struct {
	ID        EmailLogID `json:"id" url:"id"`
	Subject   string     `json:"subject" url:"subject"`
	From      string     `json:"from" url:"from"`
	To        string     `json:"to" url:"to"`
	HTMLBody  string     `json:"htmlBody" url:"htmlBody"`
	TextBody  string     `json:"textBody" url:"textBody"`
	CreatedAt time.Time  `json:"createdAt" url:"createdAt"`
	InvoiceID *InvoiceID `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailLog) UnmarshalJSON(data []byte) error {
	type embed EmailLog
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmailLog(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLog) MarshalJSON() ([]byte, error) {
	type embed EmailLog
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmailLog) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailLogID = string

type EmailLogResponse struct {
	// Total number of logs for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more logs available for the given filters.
	HasMore bool        `json:"hasMore" url:"hasMore"`
	Data    []*EmailLog `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailLogResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailLogResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailLogResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLogResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type AccountType string

const (
	AccountTypeBusiness   AccountType = "business"
	AccountTypeIndividual AccountType = "individual"
)

func NewAccountTypeFromString(s string) (AccountType, error) {
	switch s {
	case "business":
		return AccountTypeBusiness, nil
	case "individual":
		return AccountTypeIndividual, nil
	}
	var t AccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountType) Ptr() *AccountType {
	return &a
}

type AmountTrigger struct {
	Amount   float64      `json:"amount" url:"amount"`
	Currency CurrencyCode `json:"currency" url:"currency"`

	_rawJSON json.RawMessage
}

func (a *AmountTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler AmountTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AmountTrigger(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AmountTrigger) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyID = string

type ApprovalPolicyRequest struct {
	// List of triggers that will cause this policy to be evaluated. If no triggers are provided, the policy will be evaluated for all invoices.
	Trigger []*Trigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule    *Rule      `json:"rule,omitempty" url:"rule,omitempty"`
	// The policy ID of the previous approval policy in the chain of policies. Use 'root' if no upstreamPolicyId is intended to be set.
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`

	_rawJSON json.RawMessage
}

func (a *ApprovalPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyResponse struct {
	ID               ApprovalPolicyID `json:"id" url:"id"`
	Trigger          []*Trigger       `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule            `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`

	_rawJSON json.RawMessage
}

func (a *ApprovalPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyResponse(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyUpdateRequest struct {
	Trigger          []*Trigger        `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule             `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID *ApprovalPolicyID `json:"upstreamPolicyId,omitempty" url:"upstreamPolicyId,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApprovalPolicyUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyUpdateRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyUpdateRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApproverRule struct {
	NumApprovers   int             `json:"numApprovers" url:"numApprovers"`
	IdentifierList *IdentifierList `json:"identifierList,omitempty" url:"identifierList,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApproverRule) UnmarshalJSON(data []byte) error {
	type unmarshaler ApproverRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApproverRule(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApproverRule) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BusinessProfileRequest struct {
	// Email address for the business. Required for KYB.
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	// Phone number for the business. Required for KYB.
	Phone           *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs *string      `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	// Website URL for the business. Must be in the format http://www.example.com. Required for KYB if description is not provided.
	Website *string `json:"website,omitempty" url:"website,omitempty"`
	// Description of the business. Required for KYB if website is not provided.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Address for the business. Required for KYB.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// Tax ID for the business. Currently only EIN is supported. Required for KYB.
	TaxID *TaxID `json:"taxId,omitempty" url:"taxId,omitempty"`
	// Date of business formation
	FormationDate *time.Time `json:"formationDate,omitempty" url:"formationDate,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BusinessProfileRequest) UnmarshalJSON(data []byte) error {
	type embed BusinessProfileRequest
	var unmarshaler = struct {
		embed
		FormationDate *core.DateTime `json:"formationDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BusinessProfileRequest(unmarshaler.embed)
	b.FormationDate = unmarshaler.FormationDate.TimePtr()

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileRequest) MarshalJSON() ([]byte, error) {
	type embed BusinessProfileRequest
	var marshaler = struct {
		embed
		FormationDate *core.DateTime `json:"formationDate,omitempty"`
	}{
		embed:         embed(*b),
		FormationDate: core.NewOptionalDateTime(b.FormationDate),
	}
	return json.Marshal(marshaler)
}

func (b *BusinessProfileRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessProfileResponse struct {
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	Phone             *PhoneNumber  `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs   *string       `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	Website           *string       `json:"website,omitempty" url:"website,omitempty"`
	Description       *string       `json:"description,omitempty" url:"description,omitempty"`
	Address           *Address      `json:"address,omitempty" url:"address,omitempty"`
	// True if all representatives have been provided for this business.
	OwnersProvided *bool `json:"ownersProvided,omitempty" url:"ownersProvided,omitempty"`
	TaxIDProvided  bool  `json:"taxIDProvided" url:"taxIDProvided"`

	_rawJSON json.RawMessage
}

func (b *BusinessProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessProfileResponse(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessType string

const (
	BusinessTypeSoleProprietorship        BusinessType = "soleProprietorship"
	BusinessTypeUnincorporatedAssociation BusinessType = "unincorporatedAssociation"
	BusinessTypeTrust                     BusinessType = "trust"
	BusinessTypePublicCorporation         BusinessType = "publicCorporation"
	BusinessTypePrivateCorporation        BusinessType = "privateCorporation"
	BusinessTypeLlc                       BusinessType = "llc"
	BusinessTypePartnership               BusinessType = "partnership"
	BusinessTypeUnincorporatedNonProfit   BusinessType = "unincorporatedNonProfit"
	BusinessTypeIncorporatedNonProfit     BusinessType = "incorporatedNonProfit"
)

func NewBusinessTypeFromString(s string) (BusinessType, error) {
	switch s {
	case "soleProprietorship":
		return BusinessTypeSoleProprietorship, nil
	case "unincorporatedAssociation":
		return BusinessTypeUnincorporatedAssociation, nil
	case "trust":
		return BusinessTypeTrust, nil
	case "publicCorporation":
		return BusinessTypePublicCorporation, nil
	case "privateCorporation":
		return BusinessTypePrivateCorporation, nil
	case "llc":
		return BusinessTypeLlc, nil
	case "partnership":
		return BusinessTypePartnership, nil
	case "unincorporatedNonProfit":
		return BusinessTypeUnincorporatedNonProfit, nil
	case "incorporatedNonProfit":
		return BusinessTypeIncorporatedNonProfit, nil
	}
	var t BusinessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessType) Ptr() *BusinessType {
	return &b
}

type CounterpartyInvoiceMetricsResponse struct {
	TotalCount  int                                         `json:"totalCount" url:"totalCount"`
	TotalAmount float64                                     `json:"totalAmount" url:"totalAmount"`
	Statuses    []*CounterpartyInvoiceMetricsStatusResponse `json:"statuses,omitempty" url:"statuses,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CounterpartyInvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyInvoiceMetricsStatusResponse struct {
	Status      InvoiceStatus `json:"status" url:"status"`
	TotalCount  int           `json:"totalCount" url:"totalCount"`
	TotalAmount float64       `json:"totalAmount" url:"totalAmount"`

	_rawJSON json.RawMessage
}

func (c *CounterpartyInvoiceMetricsStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsStatusResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsStatusResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyNetworkType string

const (
	CounterpartyNetworkTypeEntity  CounterpartyNetworkType = "ENTITY"
	CounterpartyNetworkTypeNetwork CounterpartyNetworkType = "NETWORK"
)

func NewCounterpartyNetworkTypeFromString(s string) (CounterpartyNetworkType, error) {
	switch s {
	case "ENTITY":
		return CounterpartyNetworkTypeEntity, nil
	case "NETWORK":
		return CounterpartyNetworkTypeNetwork, nil
	}
	var t CounterpartyNetworkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CounterpartyNetworkType) Ptr() *CounterpartyNetworkType {
	return &c
}

type CounterpartyResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	Status      EntityStatus     `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee          bool                                `json:"isPayee" url:"isPayee"`
	CreatedAt        time.Time                           `json:"createdAt" url:"createdAt"`
	UpdatedAt        time.Time                           `json:"updatedAt" url:"updatedAt"`
	PaymentMethods   []*PaymentMethodResponse            `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	CounterpartyType []CounterpartyNetworkType           `json:"counterpartyType,omitempty" url:"counterpartyType,omitempty"`
	InvoiceMetrics   *CounterpartyInvoiceMetricsResponse `json:"invoiceMetrics,omitempty" url:"invoiceMetrics,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CounterpartyResponse) UnmarshalJSON(data []byte) error {
	type embed CounterpartyResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CounterpartyResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyResponse) MarshalJSON() ([]byte, error) {
	type embed CounterpartyResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CounterpartyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Ein struct {
	// Must be in the format XX-XXXXXXX.
	Number string `json:"number" url:"number"`

	_rawJSON json.RawMessage
}

func (e *Ein) UnmarshalJSON(data []byte) error {
	type unmarshaler Ein
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Ein(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Ein) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityAddPayeesRequest struct {
	// List of payee entity IDs to associate with the entity
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityAddPayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayeesRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayeesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityAddPayorsRequest struct {
	// List of payor entity IDs to associate with the entity
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityAddPayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayorsRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayorsRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayeesRequest struct {
	// List of payee entity IDs to hide
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityHidePayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayeesRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayeesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayorsRequest struct {
	// List of payor entity IDs to hide
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityHidePayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayorsRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayorsRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityID = string

type EntityMetadataResponse struct {
	Key   string   `json:"key" url:"key"`
	Value []string `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityMetadataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityMetadataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityMetadataResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityMetadataResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityOnboardingLinkType string

const (
	EntityOnboardingLinkTypePayee EntityOnboardingLinkType = "PAYEE"
	EntityOnboardingLinkTypePayor EntityOnboardingLinkType = "PAYOR"
)

func NewEntityOnboardingLinkTypeFromString(s string) (EntityOnboardingLinkType, error) {
	switch s {
	case "PAYEE":
		return EntityOnboardingLinkTypePayee, nil
	case "PAYOR":
		return EntityOnboardingLinkTypePayor, nil
	}
	var t EntityOnboardingLinkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityOnboardingLinkType) Ptr() *EntityOnboardingLinkType {
	return &e
}

type EntityRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  bool            `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType     `json:"accountType" url:"accountType"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// If this entity will be receiving payments, set this to true.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// Base64 encoded PNG image data for the entity logo.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	Status      EntityStatus     `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee   bool      `json:"isPayee" url:"isPayee"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (e *EntityResponse) UnmarshalJSON(data []byte) error {
	type embed EntityResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityResponse) MarshalJSON() ([]byte, error) {
	type embed EntityResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityStatus string

const (
	EntityStatusUnverified EntityStatus = "unverified"
	EntityStatusPending    EntityStatus = "pending"
	EntityStatusResubmit   EntityStatus = "resubmit"
	EntityStatusReview     EntityStatus = "review"
	EntityStatusVerified   EntityStatus = "verified"
	EntityStatusFailed     EntityStatus = "failed"
)

func NewEntityStatusFromString(s string) (EntityStatus, error) {
	switch s {
	case "unverified":
		return EntityStatusUnverified, nil
	case "pending":
		return EntityStatusPending, nil
	case "resubmit":
		return EntityStatusResubmit, nil
	case "review":
		return EntityStatusReview, nil
	case "verified":
		return EntityStatusVerified, nil
	case "failed":
		return EntityStatusFailed, nil
	}
	var t EntityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityStatus) Ptr() *EntityStatus {
	return &e
}

type EntityUpdateRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  *bool           `json:"isCustomer,omitempty" url:"isCustomer,omitempty"`
	AccountType *AccountType    `json:"accountType,omitempty" url:"accountType,omitempty"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor *bool `json:"isPayor,omitempty" url:"isPayor,omitempty"`
	// If this entity will be receiving payments, set this to true.
	IsPayee *bool `json:"isPayee,omitempty" url:"isPayee,omitempty"`
	// Base64 encoded PNG image data for the entity logo.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUpdateRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUpdateRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserID = string

type EntityUserRequest struct {
	// The ID used to identify this user in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string `json:"email,omitempty" url:"email,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	// List of roles. A role can be any string. For example: "payer", "approver", "viewer"
	Roles []string `json:"roles,omitempty" url:"roles,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUserRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserResponse struct {
	ID EntityUserID `json:"id" url:"id"`
	// The ID used to identify this user in your system.
	ForeignID *string   `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string   `json:"email,omitempty" url:"email,omitempty"`
	Name      *string   `json:"name,omitempty" url:"name,omitempty"`
	Roles     []string  `json:"roles,omitempty" url:"roles,omitempty"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (e *EntityUserResponse) UnmarshalJSON(data []byte) error {
	type embed EntityUserResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityUserResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserResponse) MarshalJSON() ([]byte, error) {
	type embed EntityUserResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityUserResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityWithPaymentMethodResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	Status      EntityStatus     `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee        bool                     `json:"isPayee" url:"isPayee"`
	CreatedAt      time.Time                `json:"createdAt" url:"createdAt"`
	UpdatedAt      time.Time                `json:"updatedAt" url:"updatedAt"`
	PaymentMethods []*PaymentMethodResponse `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EntityWithPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed EntityWithPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityWithPaymentMethodResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityWithPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed EntityWithPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityWithPaymentMethodResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FindCounterpartiesResponse struct {
	// Total number of counterparties for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more counterparties available for the given filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*CounterpartyResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FindCounterpartiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindCounterpartiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindCounterpartiesResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindCounterpartiesResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindEntityResponse struct {
	// Total number of entities for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more entities available for the given filters.
	HasMore bool                               `json:"hasMore" url:"hasMore"`
	Data    []*EntityWithPaymentMethodResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FindEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindNotificationResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*NotificationResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FindNotificationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindNotificationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindNotificationResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindNotificationResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IdentifierList struct {
	Type string
	// List of entity user roles that should be used to determine approvers
	RolesList []string
	// List of entity user IDs that should be used to determine approvers
	UserList []EntityUserID
}

func (i *IdentifierList) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "rolesList":
		var valueUnmarshaler struct {
			RolesList []string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.RolesList = valueUnmarshaler.RolesList
	case "userList":
		var valueUnmarshaler struct {
			UserList []EntityUserID `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.UserList = valueUnmarshaler.UserList
	}
	return nil
}

func (i IdentifierList) MarshalJSON() ([]byte, error) {
	if i.RolesList != nil {
		var marshaler = struct {
			Type      string   `json:"type"`
			RolesList []string `json:"value,omitempty"`
		}{
			Type:      "rolesList",
			RolesList: i.RolesList,
		}
		return json.Marshal(marshaler)
	}
	if i.UserList != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			UserList []EntityUserID `json:"value,omitempty"`
		}{
			Type:     "userList",
			UserList: i.UserList,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IdentifierListVisitor interface {
	VisitRolesList([]string) error
	VisitUserList([]EntityUserID) error
}

func (i *IdentifierList) Accept(visitor IdentifierListVisitor) error {
	if i.RolesList != nil {
		return visitor.VisitRolesList(i.RolesList)
	}
	if i.UserList != nil {
		return visitor.VisitUserList(i.UserList)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IndividualProfileRequest struct {
	Email        *string                 `json:"email,omitempty" url:"email,omitempty"`
	Name         *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone        *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Address      *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate    *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualProfileResponse struct {
	Email                *string      `json:"email,omitempty" url:"email,omitempty"`
	Name                 *FullName    `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	Address              *Address     `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool         `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool         `json:"governmentIDProvided" url:"governmentIDProvided"`

	_rawJSON json.RawMessage
}

func (i *IndividualProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileResponse(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LineItemAvailabilities string

const (
	LineItemAvailabilitiesDisabled LineItemAvailabilities = "DISABLED"
	LineItemAvailabilitiesOptional LineItemAvailabilities = "OPTIONAL"
	LineItemAvailabilitiesRequired LineItemAvailabilities = "REQUIRED"
)

func NewLineItemAvailabilitiesFromString(s string) (LineItemAvailabilities, error) {
	switch s {
	case "DISABLED":
		return LineItemAvailabilitiesDisabled, nil
	case "OPTIONAL":
		return LineItemAvailabilitiesOptional, nil
	case "REQUIRED":
		return LineItemAvailabilitiesRequired, nil
	}
	var t LineItemAvailabilities
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LineItemAvailabilities) Ptr() *LineItemAvailabilities {
	return &l
}

type MetadataTrigger struct {
	// The metadata key to match
	Key string `json:"key" url:"key"`
	// The metadata value the invoice must have to trigger this policy
	Value string `json:"value" url:"value"`

	_rawJSON json.RawMessage
}

func (m *MetadataTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataTrigger(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataTrigger) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NotificationID = string

type NotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this entity
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyRequest(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyRequest) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this entity
	Disabled bool `json:"disabled" url:"disabled"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string         `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`
	Type            NotificationType `json:"type" url:"type"`

	_rawJSON json.RawMessage
}

func (n *NotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyResponse(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationResponse struct {
	ID NotificationID `json:"id" url:"id"`
	// The invoice ID that this notification is related to. This field is only present for notifications related to invoices.
	InvoiceID *InvoiceID       `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`
	Type      NotificationType `json:"type" url:"type"`
	CreatedAt time.Time        `json:"createdAt" url:"createdAt"`

	_rawJSON json.RawMessage
}

func (n *NotificationResponse) UnmarshalJSON(data []byte) error {
	type embed NotificationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationResponse(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationResponse) MarshalJSON() ([]byte, error) {
	type embed NotificationResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*n),
		CreatedAt: core.NewDateTime(n.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationType string

const (
	NotificationTypeInvoiceApprovalNeeded NotificationType = "INVOICE_APPROVAL_NEEDED"
	NotificationTypeInvoiceApproved       NotificationType = "INVOICE_APPROVED"
	NotificationTypeInvoiceRejected       NotificationType = "INVOICE_REJECTED"
	NotificationTypeInvoiceScheduled      NotificationType = "INVOICE_SCHEDULED"
	NotificationTypeInvoicePending        NotificationType = "INVOICE_PENDING"
	NotificationTypeInvoicePaid           NotificationType = "INVOICE_PAID"
	NotificationTypeInvoiceCanceled       NotificationType = "INVOICE_CANCELED"
	NotificationTypeInvoiceCreated        NotificationType = "INVOICE_CREATED"
	NotificationTypeInvoiceEmailed        NotificationType = "INVOICE_EMAILED"
	NotificationTypeInvoiceFailed         NotificationType = "INVOICE_FAILED"
)

func NewNotificationTypeFromString(s string) (NotificationType, error) {
	switch s {
	case "INVOICE_APPROVAL_NEEDED":
		return NotificationTypeInvoiceApprovalNeeded, nil
	case "INVOICE_APPROVED":
		return NotificationTypeInvoiceApproved, nil
	case "INVOICE_REJECTED":
		return NotificationTypeInvoiceRejected, nil
	case "INVOICE_SCHEDULED":
		return NotificationTypeInvoiceScheduled, nil
	case "INVOICE_PENDING":
		return NotificationTypeInvoicePending, nil
	case "INVOICE_PAID":
		return NotificationTypeInvoicePaid, nil
	case "INVOICE_CANCELED":
		return NotificationTypeInvoiceCanceled, nil
	case "INVOICE_CREATED":
		return NotificationTypeInvoiceCreated, nil
	case "INVOICE_EMAILED":
		return NotificationTypeInvoiceEmailed, nil
	case "INVOICE_FAILED":
		return NotificationTypeInvoiceFailed, nil
	}
	var t NotificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationType) Ptr() *NotificationType {
	return &n
}

type ProfileRequest struct {
	// If this entity is a business, set this field
	Business *BusinessProfileRequest `json:"business,omitempty" url:"business,omitempty"`
	// If this entity is a individual, set this field
	Individual *IndividualProfileRequest `json:"individual,omitempty" url:"individual,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileResponse struct {
	// Will be set if the entity is a business
	Business *BusinessProfileResponse `json:"business,omitempty" url:"business,omitempty"`
	// Will be set if the entity is a individual
	Individual *IndividualProfileResponse `json:"individual,omitempty" url:"individual,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RepresentativeID = string

type RepresentativeRequest struct {
	Name             *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone            *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Email            string                  `json:"email" url:"email"`
	Address          *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate        *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID     *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`
	Responsibilities *Responsibilities       `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RepresentativeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RepresentativeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepresentativeRequest(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RepresentativeResponse struct {
	ID                   RepresentativeID  `json:"id" url:"id"`
	Name                 *FullName         `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber      `json:"phone,omitempty" url:"phone,omitempty"`
	Email                string            `json:"email" url:"email"`
	Address              *Address          `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool              `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool              `json:"governmentIDProvided" url:"governmentIDProvided"`
	Responsibilities     *Responsibilities `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`
	CreatedOn            time.Time         `json:"createdOn" url:"createdOn"`
	UpdatedOn            time.Time         `json:"updatedOn" url:"updatedOn"`
	DisabledOn           *time.Time        `json:"disabledOn,omitempty" url:"disabledOn,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RepresentativeResponse) UnmarshalJSON(data []byte) error {
	type embed RepresentativeResponse
	var unmarshaler = struct {
		embed
		CreatedOn  *core.DateTime `json:"createdOn"`
		UpdatedOn  *core.DateTime `json:"updatedOn"`
		DisabledOn *core.DateTime `json:"disabledOn,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RepresentativeResponse(unmarshaler.embed)
	r.CreatedOn = unmarshaler.CreatedOn.Time()
	r.UpdatedOn = unmarshaler.UpdatedOn.Time()
	r.DisabledOn = unmarshaler.DisabledOn.TimePtr()

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeResponse) MarshalJSON() ([]byte, error) {
	type embed RepresentativeResponse
	var marshaler = struct {
		embed
		CreatedOn  *core.DateTime `json:"createdOn"`
		UpdatedOn  *core.DateTime `json:"updatedOn"`
		DisabledOn *core.DateTime `json:"disabledOn,omitempty"`
	}{
		embed:      embed(*r),
		CreatedOn:  core.NewDateTime(r.CreatedOn),
		UpdatedOn:  core.NewDateTime(r.UpdatedOn),
		DisabledOn: core.NewOptionalDateTime(r.DisabledOn),
	}
	return json.Marshal(marshaler)
}

func (r *RepresentativeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Responsibilities struct {
	JobTitle *string `json:"jobTitle,omitempty" url:"jobTitle,omitempty"`
	// Indicates whether this individual has significant management responsibilities within the business
	IsController *bool `json:"isController,omitempty" url:"isController,omitempty"`
	// Indicates whether this individual has an ownership stake of at least 25% in the business
	IsOwner *bool `json:"isOwner,omitempty" url:"isOwner,omitempty"`
	// Percentage of ownership in the business. Must be between 0 and 100.
	OwnershipPercentage *int `json:"ownershipPercentage,omitempty" url:"ownershipPercentage,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Responsibilities) UnmarshalJSON(data []byte) error {
	type unmarshaler Responsibilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Responsibilities(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Responsibilities) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Rule struct {
	Type     string
	Approver *ApproverRule
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "approver":
		value := new(ApproverRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Approver = value
	}
	return nil
}

func (r Rule) MarshalJSON() ([]byte, error) {
	if r.Approver != nil {
		return core.MarshalJSONWithExtraProperty(r.Approver, "type", "approver")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RuleVisitor interface {
	VisitApprover(*ApproverRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	if r.Approver != nil {
		return visitor.VisitApprover(r.Approver)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

type TaxID struct {
	Ein *Ein `json:"ein,omitempty" url:"ein,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TaxID) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxID(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxID) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationEntityOptions struct {
	// If true, will require entity to undergo KYB to use Mercoa payment rails and will capture required KYB data in the portal.
	EnableMercoaPayments *bool `json:"enableMercoaPayments,omitempty" url:"enableMercoaPayments,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationEntityOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationEntityOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationEntityOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationEntityOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationInvoiceOptions struct {
	// Defaults to OPTIONAL. If set to REQUIRED, the user will be required to provide at least one line item when creating an invoice. If set to DISABLED, the user will not be able to provide line items when creating an invoice.
	LineItems *LineItemAvailabilities `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// DEPRECATED. Use lineItems instead.
	DisableLineItems *bool           `json:"disableLineItems,omitempty" url:"disableLineItems,omitempty"`
	Status           []InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationInvoiceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationInvoiceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationInvoiceOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationInvoiceOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationOptions struct {
	// Expressed in seconds or a string describing a time span. The default is 1h.
	ExpiresIn *string                        `json:"expiresIn,omitempty" url:"expiresIn,omitempty"`
	Invoice   *TokenGenerationInvoiceOptions `json:"invoice,omitempty" url:"invoice,omitempty"`
	Pages     *TokenGenerationPagesOptions   `json:"pages,omitempty" url:"pages,omitempty"`
	Style     *TokenGenerationStyleOptions   `json:"style,omitempty" url:"style,omitempty"`
	Vendors   *TokenGenerationVendorOptions  `json:"vendors,omitempty" url:"vendors,omitempty"`
	Entity    *TokenGenerationEntityOptions  `json:"entity,omitempty" url:"entity,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationPagesOptions struct {
	PaymentMethods  *bool `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	Representatives *bool `json:"representatives,omitempty" url:"representatives,omitempty"`
	Notifications   *bool `json:"notifications,omitempty" url:"notifications,omitempty"`
	Counterparties  *bool `json:"counterparties,omitempty" url:"counterparties,omitempty"`
	Approvals       *bool `json:"approvals,omitempty" url:"approvals,omitempty"`
	EmailLog        *bool `json:"emailLog,omitempty" url:"emailLog,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationPagesOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationPagesOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationPagesOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationPagesOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationStyleOptions struct {
	PrimaryColor string `json:"primaryColor" url:"primaryColor"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationStyleOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationStyleOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationStyleOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationStyleOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationVendorOptions struct {
	// If true, the user will not be able to create new vendors.
	DisableCreation *bool         `json:"disableCreation,omitempty" url:"disableCreation,omitempty"`
	Network         VendorNetwork `json:"network" url:"network"`

	_rawJSON json.RawMessage
}

func (t *TokenGenerationVendorOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationVendorOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationVendorOptions(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationVendorOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Trigger struct {
	Type     string
	Amount   *AmountTrigger
	Vendor   *VendorTrigger
	Metadata *MetadataTrigger
}

func (t *Trigger) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "amount":
		value := new(AmountTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Amount = value
	case "vendor":
		value := new(VendorTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Vendor = value
	case "metadata":
		value := new(MetadataTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Metadata = value
	}
	return nil
}

func (t Trigger) MarshalJSON() ([]byte, error) {
	if t.Amount != nil {
		return core.MarshalJSONWithExtraProperty(t.Amount, "type", "amount")
	}
	if t.Vendor != nil {
		return core.MarshalJSONWithExtraProperty(t.Vendor, "type", "vendor")
	}
	if t.Metadata != nil {
		return core.MarshalJSONWithExtraProperty(t.Metadata, "type", "metadata")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TriggerVisitor interface {
	VisitAmount(*AmountTrigger) error
	VisitVendor(*VendorTrigger) error
	VisitMetadata(*MetadataTrigger) error
}

func (t *Trigger) Accept(visitor TriggerVisitor) error {
	if t.Amount != nil {
		return visitor.VisitAmount(t.Amount)
	}
	if t.Vendor != nil {
		return visitor.VisitVendor(t.Vendor)
	}
	if t.Metadata != nil {
		return visitor.VisitMetadata(t.Metadata)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type UserNotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this user
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// Set to true if the selected notification type should be sent as a digest. Default is false.
	Digest *bool `json:"digest,omitempty" url:"digest,omitempty"`
	// Set to true if the selected notification type should be sent immediately. Default is true.
	Immediate *bool `json:"immediate,omitempty" url:"immediate,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UserNotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyRequest(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserNotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this user
	Disabled bool `json:"disabled" url:"disabled"`
	// True if the selected notification type is sent as a digest.
	Digest bool `json:"digest" url:"digest"`
	// True if the selected notification type is sent immediately.
	Immediate bool             `json:"immediate" url:"immediate"`
	Type      NotificationType `json:"type" url:"type"`

	_rawJSON json.RawMessage
}

func (u *UserNotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VendorTrigger struct {
	VendorIDs []EntityID `json:"vendorIds,omitempty" url:"vendorIds,omitempty"`

	_rawJSON json.RawMessage
}

func (v *VendorTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorTrigger(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorTrigger) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type AddApproverRequest struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID *ApprovalSlotID `json:"approvalSlotId,omitempty" url:"approvalSlotId,omitempty"`
	UserID         EntityUserID    `json:"userId" url:"userId"`

	_rawJSON json.RawMessage
}

func (a *AddApproverRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddApproverRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddApproverRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddApproverRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalRequest struct {
	// Comment associated with this approval action.
	Text   *string      `json:"text,omitempty" url:"text,omitempty"`
	UserID EntityUserID `json:"userId" url:"userId"`

	_rawJSON json.RawMessage
}

func (a *ApprovalRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalRequest(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlot struct {
	// The identifier for the approval policy this slot is associated with.
	ApprovalPolicyID ApprovalPolicyID `json:"approvalPolicyId" url:"approvalPolicyId"`
	// The identifier for this approval slot
	ApprovalSlotID  ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	AssignedUserID  *EntityUserID  `json:"assignedUserId,omitempty" url:"assignedUserId,omitempty"`
	Action          ApproverAction `json:"action" url:"action"`
	EligibleRoles   []string       `json:"eligibleRoles,omitempty" url:"eligibleRoles,omitempty"`
	EligibleUserIDs []EntityUserID `json:"eligibleUserIds,omitempty" url:"eligibleUserIds,omitempty"`
	// Either the date the invoice was created, date the approver was assigned, or date of last action by approver, whichever is latest.
	Date time.Time `json:"date" url:"date"`

	_rawJSON json.RawMessage
}

func (a *ApprovalSlot) UnmarshalJSON(data []byte) error {
	type embed ApprovalSlot
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalSlot(unmarshaler.embed)
	a.Date = unmarshaler.Date.Time()

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlot) MarshalJSON() ([]byte, error) {
	type embed ApprovalSlot
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*a),
		Date:  core.NewDateTime(a.Date),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalSlot) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotAssignment struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	AssignedUserID EntityUserID   `json:"assignedUserId" url:"assignedUserId"`

	_rawJSON json.RawMessage
}

func (a *ApprovalSlotAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalSlotAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalSlotAssignment(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlotAssignment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotID = string

type ApproverAction string

const (
	ApproverActionNone    ApproverAction = "NONE"
	ApproverActionApprove ApproverAction = "APPROVE"
	ApproverActionReject  ApproverAction = "REJECT"
)

func NewApproverActionFromString(s string) (ApproverAction, error) {
	switch s {
	case "NONE":
		return ApproverActionNone, nil
	case "APPROVE":
		return ApproverActionApprove, nil
	case "REJECT":
		return ApproverActionReject, nil
	}
	var t ApproverAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApproverAction) Ptr() *ApproverAction {
	return &a
}

type AssociatedApprovalAction struct {
	UserID EntityUserID   `json:"userId" url:"userId"`
	Action ApproverAction `json:"action" url:"action"`

	_rawJSON json.RawMessage
}

func (a *AssociatedApprovalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler AssociatedApprovalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssociatedApprovalAction(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssociatedApprovalAction) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BankAccountPaymentDestinationOptions struct {
	// Delivery method for ACH payments. Defaults to ACH_SAME_DAY.
	Delivery *BankDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankAccountPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDestinationOptions(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDestinationOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankDeliveryMethod string

const (
	BankDeliveryMethodAchStandard BankDeliveryMethod = "ACH_STANDARD"
	BankDeliveryMethodAchSameDay  BankDeliveryMethod = "ACH_SAME_DAY"
)

func NewBankDeliveryMethodFromString(s string) (BankDeliveryMethod, error) {
	switch s {
	case "ACH_STANDARD":
		return BankDeliveryMethodAchStandard, nil
	case "ACH_SAME_DAY":
		return BankDeliveryMethodAchSameDay, nil
	}
	var t BankDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankDeliveryMethod) Ptr() *BankDeliveryMethod {
	return &b
}

type CheckDeliveryMethod string

const (
	CheckDeliveryMethodPrint CheckDeliveryMethod = "PRINT"
	CheckDeliveryMethodMail  CheckDeliveryMethod = "MAIL"
)

func NewCheckDeliveryMethodFromString(s string) (CheckDeliveryMethod, error) {
	switch s {
	case "PRINT":
		return CheckDeliveryMethodPrint, nil
	case "MAIL":
		return CheckDeliveryMethodMail, nil
	}
	var t CheckDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckDeliveryMethod) Ptr() *CheckDeliveryMethod {
	return &c
}

type CheckPaymentDestinationOptions struct {
	// Delivery method for check disbursements. Defaults to MAIL.
	Delivery *CheckDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CheckPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckPaymentDestinationOptions(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckPaymentDestinationOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentID = string

type CommentRequest struct {
	Text   string        `json:"text" url:"text"`
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommentRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentResponse struct {
	ID   string              `json:"id" url:"id"`
	Text string              `json:"text" url:"text"`
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`
	// If an approval action has triggered the generation of this comment, returns the associated approval action and actor
	AssociatedApprovalAction *AssociatedApprovalAction `json:"associatedApprovalAction,omitempty" url:"associatedApprovalAction,omitempty"`
	CreatedAt                time.Time                 `json:"createdAt" url:"createdAt"`
	UpdatedAt                time.Time                 `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (c *CommentResponse) UnmarshalJSON(data []byte) error {
	type embed CommentResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CommentResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentResponse) MarshalJSON() ([]byte, error) {
	type embed CommentResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CommentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DocumentResponse struct {
	// ID of the document. If not provided, this is a dynamic document that is generated on the fly.
	ID       *string `json:"id,omitempty" url:"id,omitempty"`
	MimeType string  `json:"mimeType" url:"mimeType"`
	URI      string  `json:"uri" url:"uri"`

	_rawJSON json.RawMessage
}

func (d *DocumentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type FindInvoiceResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool               `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FindInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceResponse(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type InvoiceCreationRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Date when funds will be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID          *EntityID  `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID        *EntityID        `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	LineItems []*InvoiceLineItemRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Metadata associated with this invoice. You can specify up to 10 keys, with key names up to 40 characters long and values up to 200 characters long.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFailureType string

const (
	InvoiceFailureTypeSourcePaymentError      InvoiceFailureType = "SOURCE_PAYMENT_ERROR"
	InvoiceFailureTypeDestinationPaymentError InvoiceFailureType = "DESTINATION_PAYMENT_ERROR"
	InvoiceFailureTypeRejectedHighRisk        InvoiceFailureType = "REJECTED_HIGH_RISK"
	InvoiceFailureTypeInsufficientFunds       InvoiceFailureType = "INSUFFICIENT_FUNDS"
	InvoiceFailureTypeProcessingError         InvoiceFailureType = "PROCESSING_ERROR"
)

func NewInvoiceFailureTypeFromString(s string) (InvoiceFailureType, error) {
	switch s {
	case "SOURCE_PAYMENT_ERROR":
		return InvoiceFailureTypeSourcePaymentError, nil
	case "DESTINATION_PAYMENT_ERROR":
		return InvoiceFailureTypeDestinationPaymentError, nil
	case "REJECTED_HIGH_RISK":
		return InvoiceFailureTypeRejectedHighRisk, nil
	case "INSUFFICIENT_FUNDS":
		return InvoiceFailureTypeInsufficientFunds, nil
	case "PROCESSING_ERROR":
		return InvoiceFailureTypeProcessingError, nil
	}
	var t InvoiceFailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceFailureType) Ptr() *InvoiceFailureType {
	return &i
}

type InvoiceFeesResponse struct {
	// Fee charged to the platform (C1) for processing the source payment method. For example, credit card interchange and acquiring fees.
	SourcePaymentMethodFee float64 `json:"sourcePaymentMethodFee" url:"sourcePaymentMethodFee"`
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the platform (C1) for processing the destination payment method. For example, postage for a check payment.
	DestinationPaymentMethodFee float64 `json:"destinationPaymentMethodFee" url:"destinationPaymentMethodFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	_rawJSON json.RawMessage
}

func (i *InvoiceFeesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesResponse(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceID = string

type InvoiceLineItemRequest struct {
	// If provided, will overwrite line item on the invoice with this ID. If not provided, will create a new line item.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount float64 `json:"amount" url:"amount"`
	// Currency code for the amount. Defaults to USD.
	Currency    *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Description string        `json:"description" url:"description"`
	Name        *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity    *int          `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice        *float64          `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceLineItemRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemRequest
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemResponse struct {
	ID string `json:"id" url:"id"`
	// Total amount of line item in major units.
	Amount      *float64     `json:"amount,omitempty" url:"amount,omitempty"`
	Currency    CurrencyCode `json:"currency" url:"currency"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Name        *string      `json:"name,omitempty" url:"name,omitempty"`
	Quantity    *int         `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of line item in major units.
	UnitPrice        *float64          `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string   `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (i *InvoiceLineItemResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemResponse
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemResponse(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemResponse
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:        core.NewDateTime(i.CreatedAt),
		UpdatedAt:        core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetadataFilter struct {
	Key   string `json:"key" url:"key"`
	Value string `json:"value" url:"value"`

	_rawJSON json.RawMessage
}

func (i *InvoiceMetadataFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceMetadataFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceMetadataFilter(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetadataFilter) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsPerDateGroupBy string

const (
	InvoiceMetricsPerDateGroupByCreationDate  InvoiceMetricsPerDateGroupBy = "CREATION_DATE"
	InvoiceMetricsPerDateGroupByDueDate       InvoiceMetricsPerDateGroupBy = "DUE_DATE"
	InvoiceMetricsPerDateGroupByInvoiceDate   InvoiceMetricsPerDateGroupBy = "INVOICE_DATE"
	InvoiceMetricsPerDateGroupByDeductionDate InvoiceMetricsPerDateGroupBy = "DEDUCTION_DATE"
)

func NewInvoiceMetricsPerDateGroupByFromString(s string) (InvoiceMetricsPerDateGroupBy, error) {
	switch s {
	case "CREATION_DATE":
		return InvoiceMetricsPerDateGroupByCreationDate, nil
	case "DUE_DATE":
		return InvoiceMetricsPerDateGroupByDueDate, nil
	case "INVOICE_DATE":
		return InvoiceMetricsPerDateGroupByInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceMetricsPerDateGroupByDeductionDate, nil
	}
	var t InvoiceMetricsPerDateGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateGroupBy) Ptr() *InvoiceMetricsPerDateGroupBy {
	return &i
}

type InvoiceMetricsPerDateResponse struct {
	Date          time.Time    `json:"date" url:"date"`
	TotalAmount   float64      `json:"totalAmount" url:"totalAmount"`
	TotalCount    int          `json:"totalCount" url:"totalCount"`
	AverageAmount float64      `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode `json:"currency" url:"currency"`

	_rawJSON json.RawMessage
}

func (i *InvoiceMetricsPerDateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceMetricsPerDateResponse
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceMetricsPerDateResponse(unmarshaler.embed)
	i.Date = unmarshaler.Date.Time()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsPerDateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceMetricsPerDateResponse
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*i),
		Date:  core.NewDateTime(i.Date),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceMetricsPerDateResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsResponse struct {
	TotalAmount   float64                                   `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                                       `json:"totalCount" url:"totalCount"`
	AverageAmount float64                                   `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode                              `json:"currency" url:"currency"`
	Dates         map[string]*InvoiceMetricsPerDateResponse `json:"dates,omitempty" url:"dates,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceMetricsResponse(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceOrderByField string

const (
	InvoiceOrderByFieldAmount        InvoiceOrderByField = "AMOUNT"
	InvoiceOrderByFieldDueDate       InvoiceOrderByField = "DUE_DATE"
	InvoiceOrderByFieldCreatedAt     InvoiceOrderByField = "CREATED_AT"
	InvoiceOrderByFieldUpdatedAt     InvoiceOrderByField = "UPDATED_AT"
	InvoiceOrderByFieldInvoiceNumber InvoiceOrderByField = "INVOICE_NUMBER"
	InvoiceOrderByFieldVendorName    InvoiceOrderByField = "VENDOR_NAME"
	InvoiceOrderByFieldPayerName     InvoiceOrderByField = "PAYER_NAME"
)

func NewInvoiceOrderByFieldFromString(s string) (InvoiceOrderByField, error) {
	switch s {
	case "AMOUNT":
		return InvoiceOrderByFieldAmount, nil
	case "DUE_DATE":
		return InvoiceOrderByFieldDueDate, nil
	case "CREATED_AT":
		return InvoiceOrderByFieldCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceOrderByFieldUpdatedAt, nil
	case "INVOICE_NUMBER":
		return InvoiceOrderByFieldInvoiceNumber, nil
	case "VENDOR_NAME":
		return InvoiceOrderByFieldVendorName, nil
	case "PAYER_NAME":
		return InvoiceOrderByFieldPayerName, nil
	}
	var t InvoiceOrderByField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceOrderByField) Ptr() *InvoiceOrderByField {
	return &i
}

type InvoiceRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Date when funds will be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID          *EntityID  `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID        *EntityID        `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	LineItems []*InvoiceLineItemRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Metadata associated with this invoice. You can specify up to 10 keys, with key names up to 40 characters long and values up to 200 characters long.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponse struct {
	ID     InvoiceID     `json:"id" url:"id"`
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Date when funds will be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *EntityResponse            `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *EntityResponse            `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	Comments       []*CommentResponse         `json:"comments,omitempty" url:"comments,omitempty"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	Approvers      []*ApprovalSlot            `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse  `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	// If the invoice failed to be paid, this field will be populated with the type of failure.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	ProcessedAt *time.Time          `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`

	_rawJSON json.RawMessage
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponse
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		ProcessedAt      *core.DateTime `json:"processedAt,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponse
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		ProcessedAt      *core.DateTime `json:"processedAt,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
		ProcessedAt:      core.NewOptionalDateTime(i.ProcessedAt),
		CreatedAt:        core.NewDateTime(i.CreatedAt),
		UpdatedAt:        core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceStatus string

const (
	InvoiceStatusDraft     InvoiceStatus = "DRAFT"
	InvoiceStatusNew       InvoiceStatus = "NEW"
	InvoiceStatusApproved  InvoiceStatus = "APPROVED"
	InvoiceStatusScheduled InvoiceStatus = "SCHEDULED"
	InvoiceStatusPending   InvoiceStatus = "PENDING"
	InvoiceStatusPaid      InvoiceStatus = "PAID"
	InvoiceStatusArchived  InvoiceStatus = "ARCHIVED"
	InvoiceStatusRefused   InvoiceStatus = "REFUSED"
	InvoiceStatusCanceled  InvoiceStatus = "CANCELED"
	InvoiceStatusFailed    InvoiceStatus = "FAILED"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "NEW":
		return InvoiceStatusNew, nil
	case "APPROVED":
		return InvoiceStatusApproved, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PENDING":
		return InvoiceStatusPending, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "ARCHIVED":
		return InvoiceStatusArchived, nil
	case "REFUSED":
		return InvoiceStatusRefused, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

type PaymentDestinationOptions struct {
	Type        string
	Check       *CheckPaymentDestinationOptions
	BankAccount *BankAccountPaymentDestinationOptions
}

func (p *PaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "check":
		value := new(CheckPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "bankAccount":
		value := new(BankAccountPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	}
	return nil
}

func (p PaymentDestinationOptions) MarshalJSON() ([]byte, error) {
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentDestinationOptionsVisitor interface {
	VisitCheck(*CheckPaymentDestinationOptions) error
	VisitBankAccount(*BankAccountPaymentDestinationOptions) error
}

func (p *PaymentDestinationOptions) Accept(visitor PaymentDestinationOptionsVisitor) error {
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type OcrJobStatus string

const (
	OcrJobStatusPending OcrJobStatus = "pending"
	OcrJobStatusSuccess OcrJobStatus = "success"
	OcrJobStatusFailed  OcrJobStatus = "failed"
)

func NewOcrJobStatusFromString(s string) (OcrJobStatus, error) {
	switch s {
	case "pending":
		return OcrJobStatusPending, nil
	case "success":
		return OcrJobStatusSuccess, nil
	case "failed":
		return OcrJobStatusFailed, nil
	}
	var t OcrJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrJobStatus) Ptr() *OcrJobStatus {
	return &o
}

type BusinessOnboardingOptions struct {
	TermsOfService  *OnboardingOption `json:"termsOfService,omitempty" url:"termsOfService,omitempty"`
	Email           *OnboardingOption `json:"email,omitempty" url:"email,omitempty"`
	Name            *OnboardingOption `json:"name,omitempty" url:"name,omitempty"`
	Type            *OnboardingOption `json:"type,omitempty" url:"type,omitempty"`
	DoingBusinessAs *OnboardingOption `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	Ein             *OnboardingOption `json:"ein,omitempty" url:"ein,omitempty"`
	Address         *OnboardingOption `json:"address,omitempty" url:"address,omitempty"`
	Phone           *OnboardingOption `json:"phone,omitempty" url:"phone,omitempty"`
	FormationDate   *OnboardingOption `json:"formationDate,omitempty" url:"formationDate,omitempty"`
	Website         *OnboardingOption `json:"website,omitempty" url:"website,omitempty"`
	Description     *OnboardingOption `json:"description,omitempty" url:"description,omitempty"`
	Representatives *OnboardingOption `json:"representatives,omitempty" url:"representatives,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BusinessOnboardingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessOnboardingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessOnboardingOptions(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessOnboardingOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CodatProviderRequest struct {
	APIKey string `json:"apiKey" url:"apiKey"`

	_rawJSON json.RawMessage
}

func (c *CodatProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatProviderRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatProviderRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CodatProviderResponse struct {
	HasAPIKey bool `json:"hasApiKey" url:"hasApiKey"`

	_rawJSON json.RawMessage
}

func (c *CodatProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatProviderResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatProviderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ColorSchemeRequest struct {
	PrimaryColor        *string `json:"primaryColor,omitempty" url:"primaryColor,omitempty"`
	SecondaryColor      *string `json:"secondaryColor,omitempty" url:"secondaryColor,omitempty"`
	LogoBackgroundColor *string `json:"logoBackgroundColor,omitempty" url:"logoBackgroundColor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ColorSchemeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ColorSchemeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColorSchemeRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColorSchemeRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ColorSchemeResponse struct {
	PrimaryColor        *string `json:"primaryColor,omitempty" url:"primaryColor,omitempty"`
	SecondaryColor      *string `json:"secondaryColor,omitempty" url:"secondaryColor,omitempty"`
	LogoBackgroundColor *string `json:"logoBackgroundColor,omitempty" url:"logoBackgroundColor,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ColorSchemeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ColorSchemeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColorSchemeResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColorSchemeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EmailProviderRequest struct {
	Sender      *EmailSenderRequest `json:"sender,omitempty" url:"sender,omitempty"`
	InboxDomain string              `json:"inboxDomain" url:"inboxDomain"`

	_rawJSON json.RawMessage
}

func (e *EmailProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailProviderRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailProviderRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailProviderResponse struct {
	Sender      *EmailSenderResponse `json:"sender,omitempty" url:"sender,omitempty"`
	InboxDomain string               `json:"inboxDomain" url:"inboxDomain"`

	_rawJSON json.RawMessage
}

func (e *EmailProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailProviderResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailProviderResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailSenderProvider string

const (
	EmailSenderProviderNone     EmailSenderProvider = "none"
	EmailSenderProviderSendgrid EmailSenderProvider = "sendgrid"
	EmailSenderProviderSes      EmailSenderProvider = "ses"
	EmailSenderProviderResend   EmailSenderProvider = "resend"
)

func NewEmailSenderProviderFromString(s string) (EmailSenderProvider, error) {
	switch s {
	case "none":
		return EmailSenderProviderNone, nil
	case "sendgrid":
		return EmailSenderProviderSendgrid, nil
	case "ses":
		return EmailSenderProviderSes, nil
	case "resend":
		return EmailSenderProviderResend, nil
	}
	var t EmailSenderProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailSenderProvider) Ptr() *EmailSenderProvider {
	return &e
}

type EmailSenderRequest struct {
	Provider  EmailSenderProvider `json:"provider" url:"provider"`
	FromEmail string              `json:"fromEmail" url:"fromEmail"`
	FromName  string              `json:"fromName" url:"fromName"`
	APIKey    *string             `json:"apiKey,omitempty" url:"apiKey,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmailSenderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailSenderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailSenderRequest(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailSenderRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailSenderResponse struct {
	Provider  EmailSenderProvider `json:"provider" url:"provider"`
	FromEmail string              `json:"fromEmail" url:"fromEmail"`
	FromName  string              `json:"fromName" url:"fromName"`
	HasAPIKey bool                `json:"hasApiKey" url:"hasApiKey"`

	_rawJSON json.RawMessage
}

func (e *EmailSenderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailSenderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailSenderResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailSenderResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalAccountingSystemProviderRequest struct {
	Type   string
	None   *CodatProviderRequest
	Codat  *CodatProviderRequest
	Rutter *RutterProviderRequest
}

func (e *ExternalAccountingSystemProviderRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "none":
		value := new(CodatProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.None = value
	case "codat":
		value := new(CodatProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	}
	return nil
}

func (e ExternalAccountingSystemProviderRequest) MarshalJSON() ([]byte, error) {
	if e.None != nil {
		return core.MarshalJSONWithExtraProperty(e.None, "type", "none")
	}
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderRequestVisitor interface {
	VisitNone(*CodatProviderRequest) error
	VisitCodat(*CodatProviderRequest) error
	VisitRutter(*RutterProviderRequest) error
}

func (e *ExternalAccountingSystemProviderRequest) Accept(visitor ExternalAccountingSystemProviderRequestVisitor) error {
	if e.None != nil {
		return visitor.VisitNone(e.None)
	}
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderResponse struct {
	Type   string
	None   *CodatProviderResponse
	Codat  *CodatProviderResponse
	Rutter *RutterProviderResponse
}

func (e *ExternalAccountingSystemProviderResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "none":
		value := new(CodatProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.None = value
	case "codat":
		value := new(CodatProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	}
	return nil
}

func (e ExternalAccountingSystemProviderResponse) MarshalJSON() ([]byte, error) {
	if e.None != nil {
		return core.MarshalJSONWithExtraProperty(e.None, "type", "none")
	}
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderResponseVisitor interface {
	VisitNone(*CodatProviderResponse) error
	VisitCodat(*CodatProviderResponse) error
	VisitRutter(*RutterProviderResponse) error
}

func (e *ExternalAccountingSystemProviderResponse) Accept(visitor ExternalAccountingSystemProviderResponseVisitor) error {
	if e.None != nil {
		return visitor.VisitNone(e.None)
	}
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type IndividualOnboardingOptions struct {
	TermsOfService *OnboardingOption `json:"termsOfService,omitempty" url:"termsOfService,omitempty"`
	Email          *OnboardingOption `json:"email,omitempty" url:"email,omitempty"`
	Name           *OnboardingOption `json:"name,omitempty" url:"name,omitempty"`
	DateOfBirth    *OnboardingOption `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty"`
	Ssn            *OnboardingOption `json:"ssn,omitempty" url:"ssn,omitempty"`
	Address        *OnboardingOption `json:"address,omitempty" url:"address,omitempty"`
	Phone          *OnboardingOption `json:"phone,omitempty" url:"phone,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IndividualOnboardingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualOnboardingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualOnboardingOptions(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualOnboardingOptions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceNotificationConfigurationRequest struct {
	URL string `json:"url" url:"url"`

	_rawJSON json.RawMessage
}

func (i *InvoiceNotificationConfigurationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceNotificationConfigurationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceNotificationConfigurationRequest(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceNotificationConfigurationRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceNotificationConfigurationResponse struct {
	URL  string           `json:"url" url:"url"`
	Type NotificationType `json:"type" url:"type"`

	_rawJSON json.RawMessage
}

func (i *InvoiceNotificationConfigurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceNotificationConfigurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceNotificationConfigurationResponse(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceNotificationConfigurationResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MetadataSchema struct {
	Key         string  `json:"key" url:"key"`
	DisplayName string  `json:"displayName" url:"displayName"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether or not this field should be shown on line items. If true, this field will be shown on each line item. If false, the field will be shown on the invoice level. Defaults to false.
	LineItem *bool        `json:"lineItem,omitempty" url:"lineItem,omitempty"`
	Type     MetadataType `json:"type" url:"type"`
	// Whether or not multiple values are allowed for this field. Defaults to false. If true, the value will be a list of the specified type.
	AllowMultiple *bool `json:"allowMultiple,omitempty" url:"allowMultiple,omitempty"`
	// A list of conditional rules that determine whether or not this field should be shown. The field will only be shown if all of the conditions are met. If no conditions are specified, the field will always be shown.
	ShowConditions *MetadataShowConditions `json:"showConditions,omitempty" url:"showConditions,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MetadataSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataSchema(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataSchema) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataShowConditions struct {
	// Show this field only if the entity has values set for the metadata key.
	HasOptions *bool `json:"hasOptions,omitempty" url:"hasOptions,omitempty"`
	// Show this field only if a document has been attached.
	HasDocument *bool `json:"hasDocument,omitempty" url:"hasDocument,omitempty"`
	// Show this field only if the invoice has no line items. Useful for showing a field that applies to the entire invoice but overridden by line items if present.
	HasNoLineItems *bool `json:"hasNoLineItems,omitempty" url:"hasNoLineItems,omitempty"`
	// Show this field only if the payment source type is in this list.
	PaymentSourceTypes []PaymentMethodType `json:"paymentSourceTypes,omitempty" url:"paymentSourceTypes,omitempty"`
	// Show this field only if the payment source schema ID is in this list of payment source schema IDs. This is only applicable if paymentSourceTypes contains CUSTOM.
	PaymentSourceCustomSchemaIDs []string `json:"paymentSourceCustomSchemaIds,omitempty" url:"paymentSourceCustomSchemaIds,omitempty"`
	// Show this field only if the payment destination type is in this list.
	PaymentDestinationTypes []PaymentMethodType `json:"paymentDestinationTypes,omitempty" url:"paymentDestinationTypes,omitempty"`
	// Show this field only if the payment destination schema ID is in this list of payment destination schema IDs. This is only applicable if paymentDestinationTypes contains CUSTOM.
	PaymentDestinationCustomSchemaIDs []string `json:"paymentDestinationCustomSchemaIds,omitempty" url:"paymentDestinationCustomSchemaIds,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MetadataShowConditions) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataShowConditions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataShowConditions(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataShowConditions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataType string

const (
	MetadataTypeString   MetadataType = "STRING"
	MetadataTypeNumber   MetadataType = "NUMBER"
	MetadataTypeDate     MetadataType = "DATE"
	MetadataTypeBoolean  MetadataType = "BOOLEAN"
	MetadataTypeKeyValue MetadataType = "KEY_VALUE"
)

func NewMetadataTypeFromString(s string) (MetadataType, error) {
	switch s {
	case "STRING":
		return MetadataTypeString, nil
	case "NUMBER":
		return MetadataTypeNumber, nil
	case "DATE":
		return MetadataTypeDate, nil
	case "BOOLEAN":
		return MetadataTypeBoolean, nil
	case "KEY_VALUE":
		return MetadataTypeKeyValue, nil
	}
	var t MetadataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MetadataType) Ptr() *MetadataType {
	return &m
}

type NotificationConfigurationRequest struct {
	NotificationType string
	Invoice          *InvoiceNotificationConfigurationRequest
}

func (n *NotificationConfigurationRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		NotificationType string `json:"notificationType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.NotificationType = unmarshaler.NotificationType
	switch unmarshaler.NotificationType {
	case "invoice":
		value := new(InvoiceNotificationConfigurationRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Invoice = value
	}
	return nil
}

func (n NotificationConfigurationRequest) MarshalJSON() ([]byte, error) {
	if n.Invoice != nil {
		return core.MarshalJSONWithExtraProperty(n.Invoice, "notificationType", "invoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationRequestVisitor interface {
	VisitInvoice(*InvoiceNotificationConfigurationRequest) error
}

func (n *NotificationConfigurationRequest) Accept(visitor NotificationConfigurationRequestVisitor) error {
	if n.Invoice != nil {
		return visitor.VisitInvoice(n.Invoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationResponse struct {
	NotificationType string
	Invoice          *InvoiceNotificationConfigurationResponse
}

func (n *NotificationConfigurationResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		NotificationType string `json:"notificationType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.NotificationType = unmarshaler.NotificationType
	switch unmarshaler.NotificationType {
	case "invoice":
		value := new(InvoiceNotificationConfigurationResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Invoice = value
	}
	return nil
}

func (n NotificationConfigurationResponse) MarshalJSON() ([]byte, error) {
	if n.Invoice != nil {
		return core.MarshalJSONWithExtraProperty(n.Invoice, "notificationType", "invoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationResponseVisitor interface {
	VisitInvoice(*InvoiceNotificationConfigurationResponse) error
}

func (n *NotificationConfigurationResponse) Accept(visitor NotificationConfigurationResponseVisitor) error {
	if n.Invoice != nil {
		return visitor.VisitInvoice(n.Invoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type OnboardingOption struct {
	Show     bool `json:"show" url:"show"`
	Edit     bool `json:"edit" url:"edit"`
	Required bool `json:"required" url:"required"`

	_rawJSON json.RawMessage
}

func (o *OnboardingOption) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOption(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOption) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingOptionsRequest struct {
	EnableBusiness   *bool                        `json:"enableBusiness,omitempty" url:"enableBusiness,omitempty"`
	EnableIndividual *bool                        `json:"enableIndividual,omitempty" url:"enableIndividual,omitempty"`
	PaymentMethod    *bool                        `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	Business         *BusinessOnboardingOptions   `json:"business,omitempty" url:"business,omitempty"`
	Individual       *IndividualOnboardingOptions `json:"individual,omitempty" url:"individual,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OnboardingOptionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOptionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOptionsRequest(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOptionsRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingOptionsResponse struct {
	EnableBusiness   bool                         `json:"enableBusiness" url:"enableBusiness"`
	EnableIndividual bool                         `json:"enableIndividual" url:"enableIndividual"`
	PaymentMethod    bool                         `json:"paymentMethod" url:"paymentMethod"`
	Business         *BusinessOnboardingOptions   `json:"business,omitempty" url:"business,omitempty"`
	Individual       *IndividualOnboardingOptions `json:"individual,omitempty" url:"individual,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OnboardingOptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOptionsResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOptionsResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationID = string

type OrganizationRequest struct {
	Name                             *string                                  `json:"name,omitempty" url:"name,omitempty"`
	Logo                             *string                                  `json:"logo,omitempty" url:"logo,omitempty"`
	WebsiteURL                       *string                                  `json:"websiteUrl,omitempty" url:"websiteUrl,omitempty"`
	SupportEmail                     *string                                  `json:"supportEmail,omitempty" url:"supportEmail,omitempty"`
	PaymentMethods                   *PaymentMethodsRequest                   `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	EmailProvider                    *EmailProviderRequest                    `json:"emailProvider,omitempty" url:"emailProvider,omitempty"`
	ExternalAccountingSystemProvider *ExternalAccountingSystemProviderRequest `json:"externalAccountingSystemProvider,omitempty" url:"externalAccountingSystemProvider,omitempty"`
	ColorScheme                      *ColorSchemeRequest                      `json:"colorScheme,omitempty" url:"colorScheme,omitempty"`
	PayeeOnboardingOptions           *OnboardingOptionsRequest                `json:"payeeOnboardingOptions,omitempty" url:"payeeOnboardingOptions,omitempty"`
	PayorOnboardingOptions           *OnboardingOptionsRequest                `json:"payorOnboardingOptions,omitempty" url:"payorOnboardingOptions,omitempty"`
	MetadataSchema                   []*MetadataSchema                        `json:"metadataSchema,omitempty" url:"metadataSchema,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OrganizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationRequest(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationResponse struct {
	ID                               OrganizationID                            `json:"id" url:"id"`
	Sandbox                          bool                                      `json:"sandbox" url:"sandbox"`
	Name                             string                                    `json:"name" url:"name"`
	LogoURL                          *string                                   `json:"logoUrl,omitempty" url:"logoUrl,omitempty"`
	WebsiteURL                       *string                                   `json:"websiteUrl,omitempty" url:"websiteUrl,omitempty"`
	SupportEmail                     *string                                   `json:"supportEmail,omitempty" url:"supportEmail,omitempty"`
	PaymentMethods                   *PaymentMethodsResponse                   `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	EmailProvider                    *EmailProviderResponse                    `json:"emailProvider,omitempty" url:"emailProvider,omitempty"`
	ExternalAccountingSystemProvider *ExternalAccountingSystemProviderResponse `json:"externalAccountingSystemProvider,omitempty" url:"externalAccountingSystemProvider,omitempty"`
	ColorScheme                      *ColorSchemeResponse                      `json:"colorScheme,omitempty" url:"colorScheme,omitempty"`
	PayeeOnboardingOptions           *OnboardingOptionsResponse                `json:"payeeOnboardingOptions,omitempty" url:"payeeOnboardingOptions,omitempty"`
	PayorOnboardingOptions           *OnboardingOptionsResponse                `json:"payorOnboardingOptions,omitempty" url:"payorOnboardingOptions,omitempty"`
	MetadataSchema                   []*MetadataSchema                         `json:"metadataSchema,omitempty" url:"metadataSchema,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OrganizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaymentMethodsRequest struct {
	// List of payment methods that can be used to pay invoices.
	PayerPayments []*PaymentRailRequest `json:"payerPayments,omitempty" url:"payerPayments,omitempty"`
	// List of payment methods that can be created by a payor to send disbursements.
	BackupDisbursements []*PaymentRailRequest `json:"backupDisbursements,omitempty" url:"backupDisbursements,omitempty"`
	// List of payment methods that can be created by a payee to receive disbursements.
	VendorDisbursements []*PaymentRailRequest `json:"vendorDisbursements,omitempty" url:"vendorDisbursements,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentMethodsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodsRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodsRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodsResponse struct {
	// List of payment methods that can be used to pay invoices.
	PayerPayments []*PaymentRailResponse `json:"payerPayments,omitempty" url:"payerPayments,omitempty"`
	// List of payment methods that can be created by a payor to send disbursements.
	BackupDisbursements []*PaymentRailResponse `json:"backupDisbursements,omitempty" url:"backupDisbursements,omitempty"`
	// List of payment methods that can be created by a payee to receive disbursements.
	VendorDisbursements []*PaymentRailResponse `json:"vendorDisbursements,omitempty" url:"vendorDisbursements,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentMethodsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodsResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodsResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRailMarkup struct {
	Type   PaymentRailMarkupType `json:"type" url:"type"`
	Amount float64               `json:"amount" url:"amount"`

	_rawJSON json.RawMessage
}

func (p *PaymentRailMarkup) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRailMarkup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRailMarkup(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRailMarkup) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRailMarkupType string

const (
	PaymentRailMarkupTypeFlat    PaymentRailMarkupType = "flat"
	PaymentRailMarkupTypePercent PaymentRailMarkupType = "percent"
)

func NewPaymentRailMarkupTypeFromString(s string) (PaymentRailMarkupType, error) {
	switch s {
	case "flat":
		return PaymentRailMarkupTypeFlat, nil
	case "percent":
		return PaymentRailMarkupTypePercent, nil
	}
	var t PaymentRailMarkupType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentRailMarkupType) Ptr() *PaymentRailMarkupType {
	return &p
}

type PaymentRailRequest struct {
	Type PaymentMethodType `json:"type" url:"type"`
	// Name of the payment method. For custom payment methods, this is the ID of the schema.
	Name        string             `json:"name" url:"name"`
	Markup      *PaymentRailMarkup `json:"markup,omitempty" url:"markup,omitempty"`
	Description *string            `json:"description,omitempty" url:"description,omitempty"`
	Active      bool               `json:"active" url:"active"`

	_rawJSON json.RawMessage
}

func (p *PaymentRailRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRailRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRailRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRailRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRailResponse struct {
	Type PaymentMethodType `json:"type" url:"type"`
	// Name of the payment method. For custom payment methods, this is the ID of the schema.
	Name        string             `json:"name" url:"name"`
	Markup      *PaymentRailMarkup `json:"markup,omitempty" url:"markup,omitempty"`
	Description *string            `json:"description,omitempty" url:"description,omitempty"`
	Active      bool               `json:"active" url:"active"`
	Available   bool               `json:"available" url:"available"`

	_rawJSON json.RawMessage
}

func (p *PaymentRailResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRailResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRailResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRailResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RutterProviderRequest struct {
	ClientID     string `json:"clientId" url:"clientId"`
	ClientSecret string `json:"clientSecret" url:"clientSecret"`

	_rawJSON json.RawMessage
}

func (r *RutterProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterProviderRequest(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterProviderRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RutterProviderResponse struct {
	HasClientID     bool `json:"hasClientId" url:"hasClientId"`
	HasClientSecret bool `json:"hasClientSecret" url:"hasClientSecret"`

	_rawJSON json.RawMessage
}

func (r *RutterProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterProviderResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterProviderResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BankAccountCheckOptions struct {
	// If true, will allow the user to print checks from this bank account
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// If provided, will start the check number sequence at the provided number. If not provided, will start at 5000.
	InitialCheckNumber *int `json:"initialCheckNumber,omitempty" url:"initialCheckNumber,omitempty"`
	// If provided, will print a check with the provided routing number instead of the one from the bank account
	RoutingNumberOverride *string `json:"routingNumberOverride,omitempty" url:"routingNumberOverride,omitempty"`
	// If provided, will print a check with the provided account number instead of the one from the bank account
	AccountNumberOverride *string `json:"accountNumberOverride,omitempty" url:"accountNumberOverride,omitempty"`
	// Name of the person who's signature will be printed on the check.
	SignatoryName string `json:"signatoryName" url:"signatoryName"`
	// Base64 encoded image of the signature. If not provided, will use the signatoryName to generate a signature. Mercoa will automatically grayscale, resize, and convert the image to a PNG the image to fit on the check.
	SignatureImage *string `json:"signatureImage,omitempty" url:"signatureImage,omitempty"`
	// If true, will print checks with the provided signatureImage. If false, will print checks with a generated signature from the signatoryName. If this parameter is not set the default behavior is to use the signatureImage if provided.
	UseSignatureImage *bool `json:"useSignatureImage,omitempty" url:"useSignatureImage,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankAccountCheckOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCheckOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCheckOptions(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCheckOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// The name of the account. For example "My Checking Account" or "Property XYZ Checking"
	AccountName *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// The name of the bank. This is now automatically set when the bank account is linked.
	BankName      *string  `json:"bankName,omitempty" url:"bankName,omitempty"`
	RoutingNumber string   `json:"routingNumber" url:"routingNumber"`
	AccountNumber string   `json:"accountNumber" url:"accountNumber"`
	AccountType   BankType `json:"accountType" url:"accountType"`
	// If provided, will link a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountRequest(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	CreatedAt            time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt" url:"updatedAt"`
	AccountName          string         `json:"accountName" url:"accountName"`
	BankName             string         `json:"bankName" url:"bankName"`
	RoutingNumber        string         `json:"routingNumber" url:"routingNumber"`
	AccountNumber        string         `json:"accountNumber" url:"accountNumber"`
	AccountType          BankType       `json:"accountType" url:"accountType"`
	Status               BankStatus     `json:"status" url:"status"`
	// If check printing is enabled for the account, will return the check options for this bank account
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankAccountResponse) UnmarshalJSON(data []byte) error {
	type embed BankAccountResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankAccountResponse(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountResponse) MarshalJSON() ([]byte, error) {
	type embed BankAccountResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BankAccountResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool   `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	AccountName        *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// If provided, will update a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BankAccountUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountUpdateRequest(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountUpdateRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankStatus string

const (
	BankStatusNew                BankStatus = "NEW"
	BankStatusVerified           BankStatus = "VERIFIED"
	BankStatusVerificationFailed BankStatus = "VERIFICATION_FAILED"
	BankStatusPending            BankStatus = "PENDING"
	BankStatusErrored            BankStatus = "ERRORED"
)

func NewBankStatusFromString(s string) (BankStatus, error) {
	switch s {
	case "NEW":
		return BankStatusNew, nil
	case "VERIFIED":
		return BankStatusVerified, nil
	case "VERIFICATION_FAILED":
		return BankStatusVerificationFailed, nil
	case "PENDING":
		return BankStatusPending, nil
	case "ERRORED":
		return BankStatusErrored, nil
	}
	var t BankStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankStatus) Ptr() *BankStatus {
	return &b
}

type BankType string

const (
	BankTypeChecking BankType = "CHECKING"
	BankTypeSavings  BankType = "SAVINGS"
	BankTypeUnknown  BankType = "UNKNOWN"
)

func NewBankTypeFromString(s string) (BankType, error) {
	switch s {
	case "CHECKING":
		return BankTypeChecking, nil
	case "SAVINGS":
		return BankTypeSavings, nil
	case "UNKNOWN":
		return BankTypeUnknown, nil
	}
	var t BankType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankType) Ptr() *BankType {
	return &b
}

type CardBrand string

const (
	CardBrandAmericanExpress CardBrand = "AmericanExpress"
	CardBrandDiscover        CardBrand = "Discover"
	CardBrandMastercard      CardBrand = "Mastercard"
	CardBrandVisa            CardBrand = "Visa"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "AmericanExpress":
		return CardBrandAmericanExpress, nil
	case "Discover":
		return CardBrandDiscover, nil
	case "Mastercard":
		return CardBrandMastercard, nil
	case "Visa":
		return CardBrandVisa, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

type CardRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool     `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	CardType           CardType  `json:"cardType" url:"cardType"`
	CardBrand          CardBrand `json:"cardBrand" url:"cardBrand"`
	LastFour           string    `json:"lastFour" url:"lastFour"`
	ExpMonth           string    `json:"expMonth" url:"expMonth"`
	ExpYear            string    `json:"expYear" url:"expYear"`
	Token              string    `json:"token" url:"token"`

	_rawJSON json.RawMessage
}

func (c *CardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	CreatedAt            time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt" url:"updatedAt"`
	CardType             CardType       `json:"cardType" url:"cardType"`
	CardBrand            CardBrand      `json:"cardBrand" url:"cardBrand"`
	LastFour             string         `json:"lastFour" url:"lastFour"`
	ExpMonth             string         `json:"expMonth" url:"expMonth"`
	ExpYear              string         `json:"expYear" url:"expYear"`

	_rawJSON json.RawMessage
}

func (c *CardResponse) UnmarshalJSON(data []byte) error {
	type embed CardResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CardResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardResponse) MarshalJSON() ([]byte, error) {
	type embed CardResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardType string

const (
	CardTypeCredit  CardType = "credit"
	CardTypeDebit   CardType = "debit"
	CardTypePrepaid CardType = "prepaid"
	CardTypeUnknown CardType = "unknown"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "credit":
		return CardTypeCredit, nil
	case "debit":
		return CardTypeDebit, nil
	case "prepaid":
		return CardTypePrepaid, nil
	case "unknown":
		return CardTypeUnknown, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

type CheckRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool   `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	PayToTheOrderOf    string  `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1       string  `json:"addressLine1" url:"addressLine1"`
	AddressLine2       *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City               string  `json:"city" url:"city"`
	StateOrProvince    string  `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode         string  `json:"postalCode" url:"postalCode"`
	Country            string  `json:"country" url:"country"`

	_rawJSON json.RawMessage
}

func (c *CheckRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	CreatedAt            time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt" url:"updatedAt"`
	PayToTheOrderOf      string         `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1         string         `json:"addressLine1" url:"addressLine1"`
	AddressLine2         *string        `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City                 string         `json:"city" url:"city"`
	StateOrProvince      string         `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode           string         `json:"postalCode" url:"postalCode"`
	Country              string         `json:"country" url:"country"`

	_rawJSON json.RawMessage
}

func (c *CheckResponse) UnmarshalJSON(data []byte) error {
	type embed CheckResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CheckResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckResponse) MarshalJSON() ([]byte, error) {
	type embed CheckResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CheckResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CurrencyCode string

const (
	CurrencyCodeAed CurrencyCode = "AED"
	CurrencyCodeAfn CurrencyCode = "AFN"
	CurrencyCodeAll CurrencyCode = "ALL"
	CurrencyCodeAmd CurrencyCode = "AMD"
	CurrencyCodeAng CurrencyCode = "ANG"
	CurrencyCodeAoa CurrencyCode = "AOA"
	CurrencyCodeArs CurrencyCode = "ARS"
	CurrencyCodeAud CurrencyCode = "AUD"
	CurrencyCodeAwg CurrencyCode = "AWG"
	CurrencyCodeAzn CurrencyCode = "AZN"
	CurrencyCodeBam CurrencyCode = "BAM"
	CurrencyCodeBbd CurrencyCode = "BBD"
	CurrencyCodeBdt CurrencyCode = "BDT"
	CurrencyCodeBgn CurrencyCode = "BGN"
	CurrencyCodeBhd CurrencyCode = "BHD"
	CurrencyCodeBif CurrencyCode = "BIF"
	CurrencyCodeBmd CurrencyCode = "BMD"
	CurrencyCodeBnd CurrencyCode = "BND"
	CurrencyCodeBob CurrencyCode = "BOB"
	CurrencyCodeBov CurrencyCode = "BOV"
	CurrencyCodeBrl CurrencyCode = "BRL"
	CurrencyCodeBsd CurrencyCode = "BSD"
	CurrencyCodeBtn CurrencyCode = "BTN"
	CurrencyCodeBwp CurrencyCode = "BWP"
	CurrencyCodeByn CurrencyCode = "BYN"
	CurrencyCodeBzd CurrencyCode = "BZD"
	CurrencyCodeCad CurrencyCode = "CAD"
	CurrencyCodeCdf CurrencyCode = "CDF"
	CurrencyCodeChe CurrencyCode = "CHE"
	CurrencyCodeChf CurrencyCode = "CHF"
	CurrencyCodeChw CurrencyCode = "CHW"
	CurrencyCodeClf CurrencyCode = "CLF"
	CurrencyCodeClp CurrencyCode = "CLP"
	CurrencyCodeCop CurrencyCode = "COP"
	CurrencyCodeCou CurrencyCode = "COU"
	CurrencyCodeCrc CurrencyCode = "CRC"
	CurrencyCodeCuc CurrencyCode = "CUC"
	CurrencyCodeCup CurrencyCode = "CUP"
	CurrencyCodeCve CurrencyCode = "CVE"
	CurrencyCodeCzk CurrencyCode = "CZK"
	CurrencyCodeDjf CurrencyCode = "DJF"
	CurrencyCodeDkk CurrencyCode = "DKK"
	CurrencyCodeDop CurrencyCode = "DOP"
	CurrencyCodeDzd CurrencyCode = "DZD"
	CurrencyCodeEgp CurrencyCode = "EGP"
	CurrencyCodeErn CurrencyCode = "ERN"
	CurrencyCodeEtb CurrencyCode = "ETB"
	CurrencyCodeEur CurrencyCode = "EUR"
	CurrencyCodeFjd CurrencyCode = "FJD"
	CurrencyCodeFkp CurrencyCode = "FKP"
	CurrencyCodeGbp CurrencyCode = "GBP"
	CurrencyCodeGel CurrencyCode = "GEL"
	CurrencyCodeGhs CurrencyCode = "GHS"
	CurrencyCodeGip CurrencyCode = "GIP"
	CurrencyCodeGmd CurrencyCode = "GMD"
	CurrencyCodeGnf CurrencyCode = "GNF"
	CurrencyCodeGtq CurrencyCode = "GTQ"
	CurrencyCodeGyd CurrencyCode = "GYD"
	CurrencyCodeHkd CurrencyCode = "HKD"
	CurrencyCodeHnl CurrencyCode = "HNL"
	CurrencyCodeHtg CurrencyCode = "HTG"
	CurrencyCodeHuf CurrencyCode = "HUF"
	CurrencyCodeIdr CurrencyCode = "IDR"
	CurrencyCodeIls CurrencyCode = "ILS"
	CurrencyCodeInr CurrencyCode = "INR"
	CurrencyCodeIqd CurrencyCode = "IQD"
	CurrencyCodeIrr CurrencyCode = "IRR"
	CurrencyCodeIsk CurrencyCode = "ISK"
	CurrencyCodeJmd CurrencyCode = "JMD"
	CurrencyCodeJod CurrencyCode = "JOD"
	CurrencyCodeJpy CurrencyCode = "JPY"
	CurrencyCodeKes CurrencyCode = "KES"
	CurrencyCodeKgs CurrencyCode = "KGS"
	CurrencyCodeKhr CurrencyCode = "KHR"
	CurrencyCodeKmf CurrencyCode = "KMF"
	CurrencyCodeKpw CurrencyCode = "KPW"
	CurrencyCodeKrw CurrencyCode = "KRW"
	CurrencyCodeKwd CurrencyCode = "KWD"
	CurrencyCodeKyd CurrencyCode = "KYD"
	CurrencyCodeKzt CurrencyCode = "KZT"
	CurrencyCodeLak CurrencyCode = "LAK"
	CurrencyCodeLbp CurrencyCode = "LBP"
	CurrencyCodeLkr CurrencyCode = "LKR"
	CurrencyCodeLrd CurrencyCode = "LRD"
	CurrencyCodeLsl CurrencyCode = "LSL"
	CurrencyCodeLyd CurrencyCode = "LYD"
	CurrencyCodeMad CurrencyCode = "MAD"
	CurrencyCodeMdl CurrencyCode = "MDL"
	CurrencyCodeMga CurrencyCode = "MGA"
	CurrencyCodeMkd CurrencyCode = "MKD"
	CurrencyCodeMmk CurrencyCode = "MMK"
	CurrencyCodeMnt CurrencyCode = "MNT"
	CurrencyCodeMop CurrencyCode = "MOP"
	CurrencyCodeMru CurrencyCode = "MRU"
	CurrencyCodeMur CurrencyCode = "MUR"
	CurrencyCodeMvr CurrencyCode = "MVR"
	CurrencyCodeMwk CurrencyCode = "MWK"
	CurrencyCodeMxn CurrencyCode = "MXN"
	CurrencyCodeMxv CurrencyCode = "MXV"
	CurrencyCodeMyr CurrencyCode = "MYR"
	CurrencyCodeMzn CurrencyCode = "MZN"
	CurrencyCodeNad CurrencyCode = "NAD"
	CurrencyCodeNgn CurrencyCode = "NGN"
	CurrencyCodeNio CurrencyCode = "NIO"
	CurrencyCodeNok CurrencyCode = "NOK"
	CurrencyCodeNpr CurrencyCode = "NPR"
	CurrencyCodeNzd CurrencyCode = "NZD"
	CurrencyCodeOmr CurrencyCode = "OMR"
	CurrencyCodePab CurrencyCode = "PAB"
	CurrencyCodePen CurrencyCode = "PEN"
	CurrencyCodePgk CurrencyCode = "PGK"
	CurrencyCodePhp CurrencyCode = "PHP"
	CurrencyCodePkr CurrencyCode = "PKR"
	CurrencyCodePln CurrencyCode = "PLN"
	CurrencyCodePyg CurrencyCode = "PYG"
	CurrencyCodeQar CurrencyCode = "QAR"
	CurrencyCodeRon CurrencyCode = "RON"
	CurrencyCodeRsd CurrencyCode = "RSD"
	CurrencyCodeCny CurrencyCode = "CNY"
	CurrencyCodeRub CurrencyCode = "RUB"
	CurrencyCodeRwf CurrencyCode = "RWF"
	CurrencyCodeSar CurrencyCode = "SAR"
	CurrencyCodeSbd CurrencyCode = "SBD"
	CurrencyCodeScr CurrencyCode = "SCR"
	CurrencyCodeSdg CurrencyCode = "SDG"
	CurrencyCodeSek CurrencyCode = "SEK"
	CurrencyCodeSgd CurrencyCode = "SGD"
	CurrencyCodeShp CurrencyCode = "SHP"
	CurrencyCodeSle CurrencyCode = "SLE"
	CurrencyCodeSll CurrencyCode = "SLL"
	CurrencyCodeSos CurrencyCode = "SOS"
	CurrencyCodeSrd CurrencyCode = "SRD"
	CurrencyCodeSsp CurrencyCode = "SSP"
	CurrencyCodeStn CurrencyCode = "STN"
	CurrencyCodeSvc CurrencyCode = "SVC"
	CurrencyCodeSyp CurrencyCode = "SYP"
	CurrencyCodeSzl CurrencyCode = "SZL"
	CurrencyCodeThb CurrencyCode = "THB"
	CurrencyCodeTjs CurrencyCode = "TJS"
	CurrencyCodeTmt CurrencyCode = "TMT"
	CurrencyCodeTnd CurrencyCode = "TND"
	CurrencyCodeTop CurrencyCode = "TOP"
	CurrencyCodeTry CurrencyCode = "TRY"
	CurrencyCodeTtd CurrencyCode = "TTD"
	CurrencyCodeTwd CurrencyCode = "TWD"
	CurrencyCodeTzs CurrencyCode = "TZS"
	CurrencyCodeUah CurrencyCode = "UAH"
	CurrencyCodeUgx CurrencyCode = "UGX"
	CurrencyCodeUsd CurrencyCode = "USD"
	CurrencyCodeUsn CurrencyCode = "USN"
	CurrencyCodeUyi CurrencyCode = "UYI"
	CurrencyCodeUyu CurrencyCode = "UYU"
	CurrencyCodeUyw CurrencyCode = "UYW"
	CurrencyCodeUzs CurrencyCode = "UZS"
	CurrencyCodeVed CurrencyCode = "VED"
	CurrencyCodeVes CurrencyCode = "VES"
	CurrencyCodeVnd CurrencyCode = "VND"
	CurrencyCodeVuv CurrencyCode = "VUV"
	CurrencyCodeWst CurrencyCode = "WST"
	CurrencyCodeXaf CurrencyCode = "XAF"
	CurrencyCodeXag CurrencyCode = "XAG"
	CurrencyCodeXau CurrencyCode = "XAU"
	CurrencyCodeXba CurrencyCode = "XBA"
	CurrencyCodeXbb CurrencyCode = "XBB"
	CurrencyCodeXbc CurrencyCode = "XBC"
	CurrencyCodeXbd CurrencyCode = "XBD"
	CurrencyCodeXcd CurrencyCode = "XCD"
	CurrencyCodeXdr CurrencyCode = "XDR"
	CurrencyCodeXof CurrencyCode = "XOF"
	CurrencyCodeXpd CurrencyCode = "XPD"
	CurrencyCodeXpf CurrencyCode = "XPF"
	CurrencyCodeXpt CurrencyCode = "XPT"
	CurrencyCodeXsu CurrencyCode = "XSU"
	CurrencyCodeXts CurrencyCode = "XTS"
	CurrencyCodeXua CurrencyCode = "XUA"
	CurrencyCodeXxx CurrencyCode = "XXX"
	CurrencyCodeYer CurrencyCode = "YER"
	CurrencyCodeZar CurrencyCode = "ZAR"
	CurrencyCodeZmw CurrencyCode = "ZMW"
	CurrencyCodeZwl CurrencyCode = "ZWL"
)

func NewCurrencyCodeFromString(s string) (CurrencyCode, error) {
	switch s {
	case "AED":
		return CurrencyCodeAed, nil
	case "AFN":
		return CurrencyCodeAfn, nil
	case "ALL":
		return CurrencyCodeAll, nil
	case "AMD":
		return CurrencyCodeAmd, nil
	case "ANG":
		return CurrencyCodeAng, nil
	case "AOA":
		return CurrencyCodeAoa, nil
	case "ARS":
		return CurrencyCodeArs, nil
	case "AUD":
		return CurrencyCodeAud, nil
	case "AWG":
		return CurrencyCodeAwg, nil
	case "AZN":
		return CurrencyCodeAzn, nil
	case "BAM":
		return CurrencyCodeBam, nil
	case "BBD":
		return CurrencyCodeBbd, nil
	case "BDT":
		return CurrencyCodeBdt, nil
	case "BGN":
		return CurrencyCodeBgn, nil
	case "BHD":
		return CurrencyCodeBhd, nil
	case "BIF":
		return CurrencyCodeBif, nil
	case "BMD":
		return CurrencyCodeBmd, nil
	case "BND":
		return CurrencyCodeBnd, nil
	case "BOB":
		return CurrencyCodeBob, nil
	case "BOV":
		return CurrencyCodeBov, nil
	case "BRL":
		return CurrencyCodeBrl, nil
	case "BSD":
		return CurrencyCodeBsd, nil
	case "BTN":
		return CurrencyCodeBtn, nil
	case "BWP":
		return CurrencyCodeBwp, nil
	case "BYN":
		return CurrencyCodeByn, nil
	case "BZD":
		return CurrencyCodeBzd, nil
	case "CAD":
		return CurrencyCodeCad, nil
	case "CDF":
		return CurrencyCodeCdf, nil
	case "CHE":
		return CurrencyCodeChe, nil
	case "CHF":
		return CurrencyCodeChf, nil
	case "CHW":
		return CurrencyCodeChw, nil
	case "CLF":
		return CurrencyCodeClf, nil
	case "CLP":
		return CurrencyCodeClp, nil
	case "COP":
		return CurrencyCodeCop, nil
	case "COU":
		return CurrencyCodeCou, nil
	case "CRC":
		return CurrencyCodeCrc, nil
	case "CUC":
		return CurrencyCodeCuc, nil
	case "CUP":
		return CurrencyCodeCup, nil
	case "CVE":
		return CurrencyCodeCve, nil
	case "CZK":
		return CurrencyCodeCzk, nil
	case "DJF":
		return CurrencyCodeDjf, nil
	case "DKK":
		return CurrencyCodeDkk, nil
	case "DOP":
		return CurrencyCodeDop, nil
	case "DZD":
		return CurrencyCodeDzd, nil
	case "EGP":
		return CurrencyCodeEgp, nil
	case "ERN":
		return CurrencyCodeErn, nil
	case "ETB":
		return CurrencyCodeEtb, nil
	case "EUR":
		return CurrencyCodeEur, nil
	case "FJD":
		return CurrencyCodeFjd, nil
	case "FKP":
		return CurrencyCodeFkp, nil
	case "GBP":
		return CurrencyCodeGbp, nil
	case "GEL":
		return CurrencyCodeGel, nil
	case "GHS":
		return CurrencyCodeGhs, nil
	case "GIP":
		return CurrencyCodeGip, nil
	case "GMD":
		return CurrencyCodeGmd, nil
	case "GNF":
		return CurrencyCodeGnf, nil
	case "GTQ":
		return CurrencyCodeGtq, nil
	case "GYD":
		return CurrencyCodeGyd, nil
	case "HKD":
		return CurrencyCodeHkd, nil
	case "HNL":
		return CurrencyCodeHnl, nil
	case "HTG":
		return CurrencyCodeHtg, nil
	case "HUF":
		return CurrencyCodeHuf, nil
	case "IDR":
		return CurrencyCodeIdr, nil
	case "ILS":
		return CurrencyCodeIls, nil
	case "INR":
		return CurrencyCodeInr, nil
	case "IQD":
		return CurrencyCodeIqd, nil
	case "IRR":
		return CurrencyCodeIrr, nil
	case "ISK":
		return CurrencyCodeIsk, nil
	case "JMD":
		return CurrencyCodeJmd, nil
	case "JOD":
		return CurrencyCodeJod, nil
	case "JPY":
		return CurrencyCodeJpy, nil
	case "KES":
		return CurrencyCodeKes, nil
	case "KGS":
		return CurrencyCodeKgs, nil
	case "KHR":
		return CurrencyCodeKhr, nil
	case "KMF":
		return CurrencyCodeKmf, nil
	case "KPW":
		return CurrencyCodeKpw, nil
	case "KRW":
		return CurrencyCodeKrw, nil
	case "KWD":
		return CurrencyCodeKwd, nil
	case "KYD":
		return CurrencyCodeKyd, nil
	case "KZT":
		return CurrencyCodeKzt, nil
	case "LAK":
		return CurrencyCodeLak, nil
	case "LBP":
		return CurrencyCodeLbp, nil
	case "LKR":
		return CurrencyCodeLkr, nil
	case "LRD":
		return CurrencyCodeLrd, nil
	case "LSL":
		return CurrencyCodeLsl, nil
	case "LYD":
		return CurrencyCodeLyd, nil
	case "MAD":
		return CurrencyCodeMad, nil
	case "MDL":
		return CurrencyCodeMdl, nil
	case "MGA":
		return CurrencyCodeMga, nil
	case "MKD":
		return CurrencyCodeMkd, nil
	case "MMK":
		return CurrencyCodeMmk, nil
	case "MNT":
		return CurrencyCodeMnt, nil
	case "MOP":
		return CurrencyCodeMop, nil
	case "MRU":
		return CurrencyCodeMru, nil
	case "MUR":
		return CurrencyCodeMur, nil
	case "MVR":
		return CurrencyCodeMvr, nil
	case "MWK":
		return CurrencyCodeMwk, nil
	case "MXN":
		return CurrencyCodeMxn, nil
	case "MXV":
		return CurrencyCodeMxv, nil
	case "MYR":
		return CurrencyCodeMyr, nil
	case "MZN":
		return CurrencyCodeMzn, nil
	case "NAD":
		return CurrencyCodeNad, nil
	case "NGN":
		return CurrencyCodeNgn, nil
	case "NIO":
		return CurrencyCodeNio, nil
	case "NOK":
		return CurrencyCodeNok, nil
	case "NPR":
		return CurrencyCodeNpr, nil
	case "NZD":
		return CurrencyCodeNzd, nil
	case "OMR":
		return CurrencyCodeOmr, nil
	case "PAB":
		return CurrencyCodePab, nil
	case "PEN":
		return CurrencyCodePen, nil
	case "PGK":
		return CurrencyCodePgk, nil
	case "PHP":
		return CurrencyCodePhp, nil
	case "PKR":
		return CurrencyCodePkr, nil
	case "PLN":
		return CurrencyCodePln, nil
	case "PYG":
		return CurrencyCodePyg, nil
	case "QAR":
		return CurrencyCodeQar, nil
	case "RON":
		return CurrencyCodeRon, nil
	case "RSD":
		return CurrencyCodeRsd, nil
	case "CNY":
		return CurrencyCodeCny, nil
	case "RUB":
		return CurrencyCodeRub, nil
	case "RWF":
		return CurrencyCodeRwf, nil
	case "SAR":
		return CurrencyCodeSar, nil
	case "SBD":
		return CurrencyCodeSbd, nil
	case "SCR":
		return CurrencyCodeScr, nil
	case "SDG":
		return CurrencyCodeSdg, nil
	case "SEK":
		return CurrencyCodeSek, nil
	case "SGD":
		return CurrencyCodeSgd, nil
	case "SHP":
		return CurrencyCodeShp, nil
	case "SLE":
		return CurrencyCodeSle, nil
	case "SLL":
		return CurrencyCodeSll, nil
	case "SOS":
		return CurrencyCodeSos, nil
	case "SRD":
		return CurrencyCodeSrd, nil
	case "SSP":
		return CurrencyCodeSsp, nil
	case "STN":
		return CurrencyCodeStn, nil
	case "SVC":
		return CurrencyCodeSvc, nil
	case "SYP":
		return CurrencyCodeSyp, nil
	case "SZL":
		return CurrencyCodeSzl, nil
	case "THB":
		return CurrencyCodeThb, nil
	case "TJS":
		return CurrencyCodeTjs, nil
	case "TMT":
		return CurrencyCodeTmt, nil
	case "TND":
		return CurrencyCodeTnd, nil
	case "TOP":
		return CurrencyCodeTop, nil
	case "TRY":
		return CurrencyCodeTry, nil
	case "TTD":
		return CurrencyCodeTtd, nil
	case "TWD":
		return CurrencyCodeTwd, nil
	case "TZS":
		return CurrencyCodeTzs, nil
	case "UAH":
		return CurrencyCodeUah, nil
	case "UGX":
		return CurrencyCodeUgx, nil
	case "USD":
		return CurrencyCodeUsd, nil
	case "USN":
		return CurrencyCodeUsn, nil
	case "UYI":
		return CurrencyCodeUyi, nil
	case "UYU":
		return CurrencyCodeUyu, nil
	case "UYW":
		return CurrencyCodeUyw, nil
	case "UZS":
		return CurrencyCodeUzs, nil
	case "VED":
		return CurrencyCodeVed, nil
	case "VES":
		return CurrencyCodeVes, nil
	case "VND":
		return CurrencyCodeVnd, nil
	case "VUV":
		return CurrencyCodeVuv, nil
	case "WST":
		return CurrencyCodeWst, nil
	case "XAF":
		return CurrencyCodeXaf, nil
	case "XAG":
		return CurrencyCodeXag, nil
	case "XAU":
		return CurrencyCodeXau, nil
	case "XBA":
		return CurrencyCodeXba, nil
	case "XBB":
		return CurrencyCodeXbb, nil
	case "XBC":
		return CurrencyCodeXbc, nil
	case "XBD":
		return CurrencyCodeXbd, nil
	case "XCD":
		return CurrencyCodeXcd, nil
	case "XDR":
		return CurrencyCodeXdr, nil
	case "XOF":
		return CurrencyCodeXof, nil
	case "XPD":
		return CurrencyCodeXpd, nil
	case "XPF":
		return CurrencyCodeXpf, nil
	case "XPT":
		return CurrencyCodeXpt, nil
	case "XSU":
		return CurrencyCodeXsu, nil
	case "XTS":
		return CurrencyCodeXts, nil
	case "XUA":
		return CurrencyCodeXua, nil
	case "XXX":
		return CurrencyCodeXxx, nil
	case "YER":
		return CurrencyCodeYer, nil
	case "ZAR":
		return CurrencyCodeZar, nil
	case "ZMW":
		return CurrencyCodeZmw, nil
	case "ZWL":
		return CurrencyCodeZwl, nil
	}
	var t CurrencyCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CurrencyCode) Ptr() *CurrencyCode {
	return &c
}

type CustomPaymentMethodRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in your system
	ForeignID     string  `json:"foreignId" url:"foreignId"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID `json:"schemaId" url:"schemaId"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	CreatedAt            time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt" url:"updatedAt"`
	// ID for this payment method in your system
	ForeignID     string  `json:"foreignId" url:"foreignId"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID        `json:"schemaId" url:"schemaId"`
	Schema   *CustomPaymentMethodSchemaResponse `json:"schema,omitempty" url:"schema,omitempty"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID *CustomPaymentMethodSchemaID `json:"schemaId,omitempty" url:"schemaId,omitempty"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodUpdateRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodUpdateRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type PaymentMethodBalanceResponse struct {
	AvailableBalance float64      `json:"availableBalance" url:"availableBalance"`
	Currency         CurrencyCode `json:"currency" url:"currency"`
	// If the status is UNAVAILABLE, the account does not support this operation. If the status is ERROR, the account may need to be re-linked with Plaid.
	Status PaymentMethodBalanceStatus `json:"status" url:"status"`
	// The time the balance was last updated. Will be null if the balance has never been updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentMethodBalanceResponse) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodBalanceResponse
	var unmarshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodBalanceResponse(unmarshaler.embed)
	p.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBalanceResponse) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodBalanceResponse
	var marshaler = struct {
		embed
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*p),
		UpdatedAt: core.NewOptionalDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodBalanceResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodBalanceStatus string

const (
	PaymentMethodBalanceStatusAvailable   PaymentMethodBalanceStatus = "AVAILABLE"
	PaymentMethodBalanceStatusUnavailable PaymentMethodBalanceStatus = "UNAVAILABLE"
	PaymentMethodBalanceStatusError       PaymentMethodBalanceStatus = "ERROR"
)

func NewPaymentMethodBalanceStatusFromString(s string) (PaymentMethodBalanceStatus, error) {
	switch s {
	case "AVAILABLE":
		return PaymentMethodBalanceStatusAvailable, nil
	case "UNAVAILABLE":
		return PaymentMethodBalanceStatusUnavailable, nil
	case "ERROR":
		return PaymentMethodBalanceStatusError, nil
	}
	var t PaymentMethodBalanceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMethodBalanceStatus) Ptr() *PaymentMethodBalanceStatus {
	return &p
}

type PaymentMethodBaseRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaymentMethodBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodBaseRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodBaseResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	CreatedAt            time.Time      `json:"createdAt" url:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (p *PaymentMethodBaseResponse) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodBaseResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodBaseResponse(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseResponse) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodBaseResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodBaseResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodID = string

type PaymentMethodRequest struct {
	Type        string
	BankAccount *BankAccountRequest
	Card        *CardRequest
	Check       *CheckRequest
	Custom      *CustomPaymentMethodRequest
	OffPlatform *PaymentMethodBaseRequest
}

func (p *PaymentMethodRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	}
	return nil
}

func (p PaymentMethodRequest) MarshalJSON() ([]byte, error) {
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodRequestVisitor interface {
	VisitBankAccount(*BankAccountRequest) error
	VisitCard(*CardRequest) error
	VisitCheck(*CheckRequest) error
	VisitCustom(*CustomPaymentMethodRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
}

func (p *PaymentMethodRequest) Accept(visitor PaymentMethodRequestVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodResponse struct {
	Type        string
	BankAccount *BankAccountResponse
	Card        *CardResponse
	Check       *CheckResponse
	Custom      *CustomPaymentMethodResponse
	OffPlatform *PaymentMethodBaseResponse
}

func (p *PaymentMethodResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	}
	return nil
}

func (p PaymentMethodResponse) MarshalJSON() ([]byte, error) {
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodResponseVisitor interface {
	VisitBankAccount(*BankAccountResponse) error
	VisitCard(*CardResponse) error
	VisitCheck(*CheckResponse) error
	VisitCustom(*CustomPaymentMethodResponse) error
	VisitOffPlatform(*PaymentMethodBaseResponse) error
}

func (p *PaymentMethodResponse) Accept(visitor PaymentMethodResponseVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodType string

const (
	PaymentMethodTypeCustom      PaymentMethodType = "custom"
	PaymentMethodTypeCheck       PaymentMethodType = "check"
	PaymentMethodTypeBankAccount PaymentMethodType = "bankAccount"
	PaymentMethodTypeNa          PaymentMethodType = "na"
	PaymentMethodTypeCard        PaymentMethodType = "card"
	PaymentMethodTypeBnpl        PaymentMethodType = "bnpl"
	PaymentMethodTypeVirtualCard PaymentMethodType = "virtualCard"
	PaymentMethodTypeOffPlatform PaymentMethodType = "offPlatform"
)

func NewPaymentMethodTypeFromString(s string) (PaymentMethodType, error) {
	switch s {
	case "custom":
		return PaymentMethodTypeCustom, nil
	case "check":
		return PaymentMethodTypeCheck, nil
	case "bankAccount":
		return PaymentMethodTypeBankAccount, nil
	case "na":
		return PaymentMethodTypeNa, nil
	case "card":
		return PaymentMethodTypeCard, nil
	case "bnpl":
		return PaymentMethodTypeBnpl, nil
	case "virtualCard":
		return PaymentMethodTypeVirtualCard, nil
	case "offPlatform":
		return PaymentMethodTypeOffPlatform, nil
	}
	var t PaymentMethodType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMethodType) Ptr() *PaymentMethodType {
	return &p
}

// Update a payment method. for non custom payment methods.
type PaymentMethodUpdateRequest struct {
	Type   string
	Custom *CustomPaymentMethodUpdateRequest
	// Only defaultSource, defaultDestination, accountName, and checkOptions can be updated.
	BankAccount *BankAccountUpdateRequest
	// Only defaultSource and defaultDestination can be updated.
	Card *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Check *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	OffPlatform *PaymentMethodBaseRequest
}

func (p *PaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "custom":
		value := new(CustomPaymentMethodUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "bankAccount":
		value := new(BankAccountUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	}
	return nil
}

func (p PaymentMethodUpdateRequest) MarshalJSON() ([]byte, error) {
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodUpdateRequestVisitor interface {
	VisitCustom(*CustomPaymentMethodUpdateRequest) error
	VisitBankAccount(*BankAccountUpdateRequest) error
	VisitCard(*PaymentMethodBaseRequest) error
	VisitCheck(*PaymentMethodBaseRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
}

func (p *PaymentMethodUpdateRequest) Accept(visitor PaymentMethodUpdateRequestVisitor) error {
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PlaidLinkRequest struct {
	// Plaid account ID
	AccountID string `json:"accountId" url:"accountId"`
	// Public token received from Plaid Link. Use this if linking the account using the Plaid Link frontend component.
	PublicToken *string `json:"publicToken,omitempty" url:"publicToken,omitempty"`
	// Plaid access token for the account. If you already have an access token for the account (for example, you have linked the account to your app already), use this instead of publicToken.
	AccessToken *string `json:"accessToken,omitempty" url:"accessToken,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PlaidLinkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidLinkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidLinkRequest(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidLinkRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type CustomPaymentMethodSchemaField struct {
	Name        string                             `json:"name" url:"name"`
	DisplayName *string                            `json:"displayName,omitempty" url:"displayName,omitempty"`
	Type        CustomPaymentMethodSchemaFieldType `json:"type" url:"type"`
	// Indicates whether this field is optional
	Optional bool `json:"optional" url:"optional"`
	// Indicates whether this field should be used as the name of the payment method. Only one field can be used as the name. Will set the accountName field of the payment method to the value of this field.
	UseAsAccountName *bool `json:"useAsAccountName,omitempty" url:"useAsAccountName,omitempty"`
	// Indicates whether this field should be used as the account number of the payment method. Only one field can be used as the account number. Will set the accountNumber field of the payment method to the value of this field.
	UseAsAccountNumber *bool `json:"useAsAccountNumber,omitempty" url:"useAsAccountNumber,omitempty"`
	// When type is 'select', provide options that can be selected
	Options []string `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodSchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaField(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaField) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaFieldType string

const (
	CustomPaymentMethodSchemaFieldTypeText    CustomPaymentMethodSchemaFieldType = "text"
	CustomPaymentMethodSchemaFieldTypeNumber  CustomPaymentMethodSchemaFieldType = "number"
	CustomPaymentMethodSchemaFieldTypeSelect  CustomPaymentMethodSchemaFieldType = "select"
	CustomPaymentMethodSchemaFieldTypeDate    CustomPaymentMethodSchemaFieldType = "date"
	CustomPaymentMethodSchemaFieldTypePhone   CustomPaymentMethodSchemaFieldType = "phone"
	CustomPaymentMethodSchemaFieldTypeEmail   CustomPaymentMethodSchemaFieldType = "email"
	CustomPaymentMethodSchemaFieldTypeURL     CustomPaymentMethodSchemaFieldType = "url"
	CustomPaymentMethodSchemaFieldTypeAddress CustomPaymentMethodSchemaFieldType = "address"
)

func NewCustomPaymentMethodSchemaFieldTypeFromString(s string) (CustomPaymentMethodSchemaFieldType, error) {
	switch s {
	case "text":
		return CustomPaymentMethodSchemaFieldTypeText, nil
	case "number":
		return CustomPaymentMethodSchemaFieldTypeNumber, nil
	case "select":
		return CustomPaymentMethodSchemaFieldTypeSelect, nil
	case "date":
		return CustomPaymentMethodSchemaFieldTypeDate, nil
	case "phone":
		return CustomPaymentMethodSchemaFieldTypePhone, nil
	case "email":
		return CustomPaymentMethodSchemaFieldTypeEmail, nil
	case "url":
		return CustomPaymentMethodSchemaFieldTypeURL, nil
	case "address":
		return CustomPaymentMethodSchemaFieldTypeAddress, nil
	}
	var t CustomPaymentMethodSchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomPaymentMethodSchemaFieldType) Ptr() *CustomPaymentMethodSchemaFieldType {
	return &c
}

type CustomPaymentMethodSchemaID = string

type CustomPaymentMethodSchemaRequest struct {
	Name string `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports. If not provided, the payment method will support only USD.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields,omitempty" url:"fields,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodSchemaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaResponse struct {
	ID   CustomPaymentMethodSchemaID `json:"id" url:"id"`
	Name string                      `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields,omitempty" url:"fields,omitempty"`
	CreatedAt           time.Time                         `json:"createdAt" url:"createdAt"`
	UpdatedAt           time.Time                         `json:"updatedAt" url:"updatedAt"`

	_rawJSON json.RawMessage
}

func (c *CustomPaymentMethodSchemaResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodSchemaResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodSchemaResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodSchemaResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}
