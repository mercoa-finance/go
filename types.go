// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/mercoa-finance/go/core"
	time "time"
)

type BankAddress struct {
	Address             string `json:"address" url:"address"`
	City                string `json:"city" url:"city"`
	State               string `json:"state" url:"state"`
	PostalCode          string `json:"postalCode" url:"postalCode"`
	PostalCodeExtension string `json:"postalCodeExtension" url:"postalCodeExtension"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAddress) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAddress) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type EstimatedTiming struct {
	// Date the payment is scheduled to be deducted from the payer's account. Use this field if the payment has not yet been deducted.
	EstimatedDeductionDate *time.Time `json:"estimatedDeductionDate,omitempty" url:"estimatedDeductionDate,omitempty"`
	// Date the payment was processed. Use this field if the payment has already been deducted.
	ProcessedAt *time.Time `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	// ID of payment source.
	PaymentSourceID PaymentMethodID `json:"paymentSourceId" url:"paymentSourceId"`
	// ID of payment destination.
	PaymentDestinationID PaymentMethodID `json:"paymentDestinationId" url:"paymentDestinationId"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EstimatedTiming) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EstimatedTiming) UnmarshalJSON(data []byte) error {
	type embed EstimatedTiming
	var unmarshaler = struct {
		embed
		EstimatedDeductionDate *core.DateTime `json:"estimatedDeductionDate,omitempty"`
		ProcessedAt            *core.DateTime `json:"processedAt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EstimatedTiming(unmarshaler.embed)
	e.EstimatedDeductionDate = unmarshaler.EstimatedDeductionDate.TimePtr()
	e.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EstimatedTiming) MarshalJSON() ([]byte, error) {
	type embed EstimatedTiming
	var marshaler = struct {
		embed
		EstimatedDeductionDate *core.DateTime `json:"estimatedDeductionDate,omitempty"`
		ProcessedAt            *core.DateTime `json:"processedAt,omitempty"`
	}{
		embed:                  embed(*e),
		EstimatedDeductionDate: core.NewOptionalDateTime(e.EstimatedDeductionDate),
		ProcessedAt:            core.NewOptionalDateTime(e.ProcessedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EstimatedTiming) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InvoiceTiming struct {
	InvoiceID InvoiceID `json:"invoiceId" url:"invoiceId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceTiming) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTiming) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceTiming
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceTiming(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTiming) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type Address struct {
	AddressLine1 string  `json:"addressLine1" url:"addressLine1"`
	AddressLine2 *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City         string  `json:"city" url:"city"`
	// State or province code. Must be in the format XX.
	StateOrProvince string `json:"stateOrProvince" url:"stateOrProvince"`
	// Postal code. Must be in the format XXXXX or XXXXX-XXXX.
	PostalCode string  `json:"postalCode" url:"postalCode"`
	Country    *string `json:"country,omitempty" url:"country,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BirthDate struct {
	Day   *string `json:"day,omitempty" url:"day,omitempty"`
	Month *string `json:"month,omitempty" url:"month,omitempty"`
	Year  *string `json:"year,omitempty" url:"year,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BirthDate) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BirthDate) UnmarshalJSON(data []byte) error {
	type unmarshaler BirthDate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BirthDate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BirthDate) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type DocumentResponse struct {
	// ID of the document. If not provided, this is a dynamic document that is generated on the fly.
	ID       *string      `json:"id,omitempty" url:"id,omitempty"`
	MimeType string       `json:"mimeType" url:"mimeType"`
	Type     DocumentType `json:"type" url:"type"`
	URI      string       `json:"uri" url:"uri"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DocumentResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentType string

const (
	DocumentTypeInvoice       DocumentType = "INVOICE"
	DocumentTypeTenNinetyNine DocumentType = "TEN_NINETY_NINE"
	DocumentTypeW9            DocumentType = "W9"
	DocumentTypeCheck         DocumentType = "CHECK"
	DocumentTypeBankStatement DocumentType = "BANK_STATEMENT"
	DocumentTypeOther         DocumentType = "OTHER"
)

func NewDocumentTypeFromString(s string) (DocumentType, error) {
	switch s {
	case "INVOICE":
		return DocumentTypeInvoice, nil
	case "TEN_NINETY_NINE":
		return DocumentTypeTenNinetyNine, nil
	case "W9":
		return DocumentTypeW9, nil
	case "CHECK":
		return DocumentTypeCheck, nil
	case "BANK_STATEMENT":
		return DocumentTypeBankStatement, nil
	case "OTHER":
		return DocumentTypeOther, nil
	}
	var t DocumentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DocumentType) Ptr() *DocumentType {
	return &d
}

type FullName struct {
	FirstName  string  `json:"firstName" url:"firstName"`
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	LastName   string  `json:"lastName" url:"lastName"`
	Suffix     *string `json:"suffix,omitempty" url:"suffix,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FullName) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FullName) UnmarshalJSON(data []byte) error {
	type unmarshaler FullName
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FullName(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FullName) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IndividualGovernmentID struct {
	// Full Social Security Number. Must be in the format 123-45-6789.
	Ssn string `json:"ssn" url:"ssn"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndividualGovernmentID) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualGovernmentID) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualGovernmentID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualGovernmentID(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualGovernmentID) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

func NewOrderDirectionFromString(s string) (OrderDirection, error) {
	switch s {
	case "ASC":
		return OrderDirectionAsc, nil
	case "DESC":
		return OrderDirectionDesc, nil
	}
	var t OrderDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderDirection) Ptr() *OrderDirection {
	return &o
}

type PhoneNumber struct {
	CountryCode string `json:"countryCode" url:"countryCode"`
	Number      string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhoneNumber) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler PhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhoneNumber(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhoneNumber) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type StringOrStringArray struct {
	String     string
	StringList []string
}

func (s *StringOrStringArray) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s StringOrStringArray) MarshalJSON() ([]byte, error) {
	if s.String != "" {
		return json.Marshal(s.String)
	}
	if s.StringList != nil {
		return json.Marshal(s.StringList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type StringOrStringArrayVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *StringOrStringArray) Accept(visitor StringOrStringArrayVisitor) error {
	if s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.StringList != nil {
		return visitor.VisitStringList(s.StringList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

type EmailLog struct {
	ID        EmailLogID `json:"id" url:"id"`
	Subject   string     `json:"subject" url:"subject"`
	From      string     `json:"from" url:"from"`
	To        string     `json:"to" url:"to"`
	HTMLBody  string     `json:"htmlBody" url:"htmlBody"`
	TextBody  string     `json:"textBody" url:"textBody"`
	CreatedAt time.Time  `json:"createdAt" url:"createdAt"`
	InvoiceID *InvoiceID `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailLog) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailLog) UnmarshalJSON(data []byte) error {
	type embed EmailLog
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmailLog(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLog) MarshalJSON() ([]byte, error) {
	type embed EmailLog
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmailLog) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailLogID = string

type EmailLogResponse struct {
	// Total number of logs for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more logs available for the given filters.
	HasMore bool        `json:"hasMore" url:"hasMore"`
	Data    []*EmailLog `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailLogResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailLogResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailLogResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailLogResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLogResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupAddEntitiesRequest struct {
	// List of entity IDs or foreign IDs to add to the group
	EntityIDs []EntityID `json:"entityIds,omitempty" url:"entityIds,omitempty"`
	// Entity ID / foreign ID of an entity currently in the group to copy users and roles from OR a boolean defining if users should be copied to the new entities.
	//
	// If not provided or false, users and roles will not be copied.
	// If true, users and roles will be copied from the first entity the group.
	// If a valid ID is provided, users and roles will be copied from the corresponding provided entity in the group.
	//
	// Note: If users copied, any preexisting users will be left alone, and users with the same foreign ID will not be copied.
	CopyUsersFrom *EntityIDOrBoolean `json:"copyUsersFrom,omitempty" url:"copyUsersFrom,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupAddEntitiesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupAddEntitiesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupAddEntitiesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupAddEntitiesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupAddEntitiesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupCreateRequest struct {
	ForeignID   *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	EmailToName *string `json:"emailToName,omitempty" url:"emailToName,omitempty"`
	// Metadata key/value pairs to associate with this group. Will overwrite existing metadata.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// List of entity IDs or foreign IDs
	EntityIDs []EntityID `json:"entityIds,omitempty" url:"entityIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupCreateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupCreateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupCreateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupCreateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupCreateRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupFindResponse struct {
	Count   int                    `json:"count" url:"count"`
	HasMore bool                   `json:"hasMore" url:"hasMore"`
	Data    []*EntityGroupResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupFindResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupFindResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupFindResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupFindResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupFindResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupID = string

type EntityGroupRemoveEntitiesRequest struct {
	// List of entity IDs or foreign IDs to remove from the group
	EntityIDs []EntityID `json:"entityIds,omitempty" url:"entityIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupRemoveEntitiesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupRemoveEntitiesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupRemoveEntitiesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupRemoveEntitiesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupRemoveEntitiesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupResponse struct {
	ID          EntityGroupID     `json:"id" url:"id"`
	ForeignID   *string           `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Name        *string           `json:"name,omitempty" url:"name,omitempty"`
	EmailToName *string           `json:"emailToName,omitempty" url:"emailToName,omitempty"`
	Entities    []*EntityResponse `json:"entities,omitempty" url:"entities,omitempty"`
	Metadata    map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupUpdateRequest struct {
	ForeignID   *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	EmailToName *string `json:"emailToName,omitempty" url:"emailToName,omitempty"`
	// Metadata key/value pairs to associate with this group. Will overwrite existing metadata.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupUpdateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupUpdateRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupUserEntityRequest struct {
	// List of roles. A role can be any string. For example: "payer", "approver", "viewer"
	Roles []string `json:"roles,omitempty" url:"roles,omitempty"`
	// The IDs of the entities that these roles applies to.
	EntityID EntityID `json:"entityId" url:"entityId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupUserEntityRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupUserEntityRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupUserEntityRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupUserEntityRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupUserEntityRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupUserEntityResponse struct {
	// List of roles. A role can be any string. For example: "payer", "approver", "viewer"
	Roles []string `json:"roles,omitempty" url:"roles,omitempty"`
	// The IDs of the entities that these roles applies to.
	EntityID EntityID     `json:"entityId" url:"entityId"`
	ID       EntityUserID `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupUserEntityResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupUserEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupUserEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupUserEntityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupUserEntityResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupUserRequest struct {
	// The ID used to identify this user in your system. This is a required field and needs to be unique for all users in the group.
	ForeignID string  `json:"foreignId" url:"foreignId"`
	Email     *string `json:"email,omitempty" url:"email,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	// List of roles per entity. By default, the user will have no roles.
	Entities []*EntityGroupUserEntityRequest `json:"entities,omitempty" url:"entities,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupUserRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityGroupUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityGroupUserRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupUserRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityGroupUserResponse struct {
	// The ID used to identify this user in your system.
	ForeignID string  `json:"foreignId" url:"foreignId"`
	Email     *string `json:"email,omitempty" url:"email,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	// List of roles per entity.
	Entities  []*EntityGroupUserEntityResponse `json:"entities,omitempty" url:"entities,omitempty"`
	CreatedAt time.Time                        `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time                        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityGroupUserResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityGroupUserResponse) UnmarshalJSON(data []byte) error {
	type embed EntityGroupUserResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityGroupUserResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityGroupUserResponse) MarshalJSON() ([]byte, error) {
	type embed EntityGroupUserResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityGroupUserResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityIDOrBoolean struct {
	Boolean  bool
	EntityID EntityID
}

func (e *EntityIDOrBoolean) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		e.Boolean = valueBoolean
		return nil
	}
	var valueEntityID EntityID
	if err := json.Unmarshal(data, &valueEntityID); err == nil {
		e.EntityID = valueEntityID
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EntityIDOrBoolean) MarshalJSON() ([]byte, error) {
	if e.Boolean != false {
		return json.Marshal(e.Boolean)
	}
	if e.EntityID != "" {
		return json.Marshal(e.EntityID)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", e)
}

type EntityIDOrBooleanVisitor interface {
	VisitBoolean(bool) error
	VisitEntityID(EntityID) error
}

func (e *EntityIDOrBoolean) Accept(visitor EntityIDOrBooleanVisitor) error {
	if e.Boolean != false {
		return visitor.VisitBoolean(e.Boolean)
	}
	if e.EntityID != "" {
		return visitor.VisitEntityID(e.EntityID)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", e)
}

type FindEntityGroupUserResponse struct {
	// Total number of users for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more users available for the given filters.
	HasMore bool                       `json:"hasMore" url:"hasMore"`
	Data    []*EntityGroupUserResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindEntityGroupUserResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindEntityGroupUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityGroupUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityGroupUserResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityGroupUserResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type AccelerationFundsBalanceResponse struct {
	Amount   float64      `json:"amount" url:"amount"`
	Currency CurrencyCode `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccelerationFundsBalanceResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccelerationFundsBalanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccelerationFundsBalanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccelerationFundsBalanceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccelerationFundsBalanceResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccelerationFundsResponse struct {
	// The ID of the entity that these acceleration funds belong to.
	EntityID EntityID `json:"entityId" url:"entityId"`
	// The ID of the payment method that the acceleration funds were accessed through.
	PaymentMethodID  PaymentMethodID                   `json:"paymentMethodId" url:"paymentMethodId"`
	AvailableBalance *AccelerationFundsBalanceResponse `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	PendingBalance   *AccelerationFundsBalanceResponse `json:"pendingBalance,omitempty" url:"pendingBalance,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccelerationFundsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccelerationFundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccelerationFundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccelerationFundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccelerationFundsResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AccountType string

const (
	AccountTypeBusiness   AccountType = "business"
	AccountTypeIndividual AccountType = "individual"
)

func NewAccountTypeFromString(s string) (AccountType, error) {
	switch s {
	case "business":
		return AccountTypeBusiness, nil
	case "individual":
		return AccountTypeIndividual, nil
	}
	var t AccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountType) Ptr() *AccountType {
	return &a
}

type AmountTrigger struct {
	Amount   float64      `json:"amount" url:"amount"`
	Currency CurrencyCode `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AmountTrigger) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AmountTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler AmountTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AmountTrigger(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AmountTrigger) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyID = string

type ApprovalPolicyRequest struct {
	// List of triggers that will cause this policy to be evaluated. If no triggers are provided, the policy will be evaluated for all invoices.
	Trigger []*Trigger `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule    *Rule      `json:"rule,omitempty" url:"rule,omitempty"`
	// The policy ID of the previous approval policy in the chain of policies. Use 'root' if no upstreamPolicyId is intended to be set.
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalPolicyRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyResponse struct {
	ID               ApprovalPolicyID `json:"id" url:"id"`
	Trigger          []*Trigger       `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule            `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID ApprovalPolicyID `json:"upstreamPolicyId" url:"upstreamPolicyId"`
	CreatedAt        time.Time        `json:"createdAt" url:"createdAt"`
	UpdatedAt        time.Time        `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalPolicyResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyResponse) UnmarshalJSON(data []byte) error {
	type embed ApprovalPolicyResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalPolicyResponse(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyResponse) MarshalJSON() ([]byte, error) {
	type embed ApprovalPolicyResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalPolicyResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalPolicyUpdateRequest struct {
	Trigger          []*Trigger        `json:"trigger,omitempty" url:"trigger,omitempty"`
	Rule             *Rule             `json:"rule,omitempty" url:"rule,omitempty"`
	UpstreamPolicyID *ApprovalPolicyID `json:"upstreamPolicyId,omitempty" url:"upstreamPolicyId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalPolicyUpdateRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalPolicyUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalPolicyUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalPolicyUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalPolicyUpdateRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApproverRule struct {
	NumApprovers   int             `json:"numApprovers" url:"numApprovers"`
	IdentifierList *IdentifierList `json:"identifierList,omitempty" url:"identifierList,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApproverRule) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApproverRule) UnmarshalJSON(data []byte) error {
	type unmarshaler ApproverRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApproverRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApproverRule) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BusinessProfileRequest struct {
	// Email address for the business. Required for KYB.
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	// Phone number for the business. Required for KYB.
	Phone           *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs *string      `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	// Website URL for the business. Must be in the format http://www.example.com. Required for KYB if description is not provided.
	Website *string `json:"website,omitempty" url:"website,omitempty"`
	// Description of the business. Required for KYB if website is not provided.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Address for the business. Required for KYB.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// Tax ID for the business. Currently only EIN is supported. Required for KYB.
	TaxID *TaxID `json:"taxId,omitempty" url:"taxId,omitempty"`
	// Date of business formation
	FormationDate *time.Time `json:"formationDate,omitempty" url:"formationDate,omitempty"`
	// Industry code for the business. Required to collect funds.
	IndustryCodes *IndustryCodes `json:"industryCodes,omitempty" url:"industryCodes,omitempty"`
	// Average monthly transaction volume for the business. Required to collect funds.
	AverageMonthlyTransactionVolume *float64 `json:"averageMonthlyTransactionVolume,omitempty" url:"averageMonthlyTransactionVolume,omitempty"`
	// Average transaction size for the business. Required to collect funds.
	AverageTransactionSize *float64 `json:"averageTransactionSize,omitempty" url:"averageTransactionSize,omitempty"`
	// Maximum transaction size for the business. Required to collect funds.
	MaxTransactionSize *float64 `json:"maxTransactionSize,omitempty" url:"maxTransactionSize,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessProfileRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessProfileRequest) UnmarshalJSON(data []byte) error {
	type embed BusinessProfileRequest
	var unmarshaler = struct {
		embed
		FormationDate *core.DateTime `json:"formationDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BusinessProfileRequest(unmarshaler.embed)
	b.FormationDate = unmarshaler.FormationDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileRequest) MarshalJSON() ([]byte, error) {
	type embed BusinessProfileRequest
	var marshaler = struct {
		embed
		FormationDate *core.DateTime `json:"formationDate,omitempty"`
	}{
		embed:         embed(*b),
		FormationDate: core.NewOptionalDateTime(b.FormationDate),
	}
	return json.Marshal(marshaler)
}

func (b *BusinessProfileRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessProfileResponse struct {
	Email             *string       `json:"email,omitempty" url:"email,omitempty"`
	LegalBusinessName string        `json:"legalBusinessName" url:"legalBusinessName"`
	BusinessType      *BusinessType `json:"businessType,omitempty" url:"businessType,omitempty"`
	Phone             *PhoneNumber  `json:"phone,omitempty" url:"phone,omitempty"`
	DoingBusinessAs   *string       `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	Website           *string       `json:"website,omitempty" url:"website,omitempty"`
	Description       *string       `json:"description,omitempty" url:"description,omitempty"`
	Address           *Address      `json:"address,omitempty" url:"address,omitempty"`
	// True if all representatives have been provided for this business.
	OwnersProvided                  *bool          `json:"ownersProvided,omitempty" url:"ownersProvided,omitempty"`
	TaxIDProvided                   bool           `json:"taxIDProvided" url:"taxIDProvided"`
	TaxID                           *TaxID         `json:"taxId,omitempty" url:"taxId,omitempty"`
	IndustryCodes                   *IndustryCodes `json:"industryCodes,omitempty" url:"industryCodes,omitempty"`
	AverageMonthlyTransactionVolume *float64       `json:"averageMonthlyTransactionVolume,omitempty" url:"averageMonthlyTransactionVolume,omitempty"`
	AverageTransactionSize          *float64       `json:"averageTransactionSize,omitempty" url:"averageTransactionSize,omitempty"`
	MaxTransactionSize              *float64       `json:"maxTransactionSize,omitempty" url:"maxTransactionSize,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessProfileResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessProfileResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BusinessType string

const (
	BusinessTypeSoleProprietorship        BusinessType = "soleProprietorship"
	BusinessTypeUnincorporatedAssociation BusinessType = "unincorporatedAssociation"
	BusinessTypeTrust                     BusinessType = "trust"
	BusinessTypePublicCorporation         BusinessType = "publicCorporation"
	BusinessTypePrivateCorporation        BusinessType = "privateCorporation"
	BusinessTypeLlc                       BusinessType = "llc"
	BusinessTypePartnership               BusinessType = "partnership"
	BusinessTypeUnincorporatedNonProfit   BusinessType = "unincorporatedNonProfit"
	BusinessTypeIncorporatedNonProfit     BusinessType = "incorporatedNonProfit"
)

func NewBusinessTypeFromString(s string) (BusinessType, error) {
	switch s {
	case "soleProprietorship":
		return BusinessTypeSoleProprietorship, nil
	case "unincorporatedAssociation":
		return BusinessTypeUnincorporatedAssociation, nil
	case "trust":
		return BusinessTypeTrust, nil
	case "publicCorporation":
		return BusinessTypePublicCorporation, nil
	case "privateCorporation":
		return BusinessTypePrivateCorporation, nil
	case "llc":
		return BusinessTypeLlc, nil
	case "partnership":
		return BusinessTypePartnership, nil
	case "unincorporatedNonProfit":
		return BusinessTypeUnincorporatedNonProfit, nil
	case "incorporatedNonProfit":
		return BusinessTypeIncorporatedNonProfit, nil
	}
	var t BusinessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessType) Ptr() *BusinessType {
	return &b
}

type CounterpartyCustomizationAccount struct {
	// The ID the counterparty has assigned to this account.
	AccountID string `json:"accountId" url:"accountId"`
	// The postal code the counterparty has assigned to this account.
	PostalCode *string `json:"postalCode,omitempty" url:"postalCode,omitempty"`
	// The name on the account the counterparty has assigned to this account.
	NameOnAccount *string `json:"nameOnAccount,omitempty" url:"nameOnAccount,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyCustomizationAccount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyCustomizationAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyCustomizationAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyCustomizationAccount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyCustomizationAccount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyCustomizationRequest struct {
	CounterpartyID EntityID `json:"counterpartyId" url:"counterpartyId"`
	// The list of accounts the entity has with the counterparty.
	Accounts []*CounterpartyCustomizationAccount `json:"accounts,omitempty" url:"accounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyCustomizationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyCustomizationRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyInvoiceMetricsResponse struct {
	TotalCount  int                                         `json:"totalCount" url:"totalCount"`
	TotalAmount float64                                     `json:"totalAmount" url:"totalAmount"`
	Statuses    []*CounterpartyInvoiceMetricsStatusResponse `json:"statuses,omitempty" url:"statuses,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyInvoiceMetricsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyInvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyInvoiceMetricsStatusResponse struct {
	Status      InvoiceStatus `json:"status" url:"status"`
	TotalCount  int           `json:"totalCount" url:"totalCount"`
	TotalAmount float64       `json:"totalAmount" url:"totalAmount"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyInvoiceMetricsStatusResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyInvoiceMetricsStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyInvoiceMetricsStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyInvoiceMetricsStatusResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyInvoiceMetricsStatusResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyNetworkType string

const (
	CounterpartyNetworkTypeEntity  CounterpartyNetworkType = "ENTITY"
	CounterpartyNetworkTypeNetwork CounterpartyNetworkType = "NETWORK"
)

func NewCounterpartyNetworkTypeFromString(s string) (CounterpartyNetworkType, error) {
	switch s {
	case "ENTITY":
		return CounterpartyNetworkTypeEntity, nil
	case "NETWORK":
		return CounterpartyNetworkTypeNetwork, nil
	}
	var t CounterpartyNetworkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CounterpartyNetworkType) Ptr() *CounterpartyNetworkType {
	return &c
}

type CounterpartyResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`
	// If the entity searching for counterparties has any accounts configured in the Payee/Payor relationship, they will be returned
	Accounts         []*CounterpartyCustomizationAccount `json:"accounts,omitempty" url:"accounts,omitempty"`
	PaymentMethods   []*PaymentMethodResponse            `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	CounterpartyType []CounterpartyNetworkType           `json:"counterpartyType,omitempty" url:"counterpartyType,omitempty"`
	InvoiceMetrics   *CounterpartyInvoiceMetricsResponse `json:"invoiceMetrics,omitempty" url:"invoiceMetrics,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyResponse) UnmarshalJSON(data []byte) error {
	type embed CounterpartyResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CounterpartyResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyResponse) MarshalJSON() ([]byte, error) {
	type embed CounterpartyResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CounterpartyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Ein struct {
	// Must be in the format XX-XXXXXXX.
	Number string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Ein) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Ein) UnmarshalJSON(data []byte) error {
	type unmarshaler Ein
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Ein(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Ein) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateID = string

type EmailTemplateRequest struct {
	TemplateType EmailTemplateType `json:"templateType" url:"templateType"`
	// The name of the email template.
	Name string `json:"name" url:"name"`
	// The subject of the email template.
	Subject string `json:"subject" url:"subject"`
	// The HTML content of the email template.
	Content string `json:"content" url:"content"`
	// If true, this email template will be used as the default template for new invoices.
	IsDefault *bool `json:"isDefault,omitempty" url:"isDefault,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailTemplateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailTemplateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailTemplateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailTemplateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailTemplateRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateResponse struct {
	ID EmailTemplateID `json:"id" url:"id"`
	// The ID of the entity that this email template is associated with.
	EntityID     EntityID          `json:"entityId" url:"entityId"`
	TemplateType EmailTemplateType `json:"templateType" url:"templateType"`
	// The name of the email template.
	Name string `json:"name" url:"name"`
	// The subject of the email template.
	Subject string `json:"subject" url:"subject"`
	// The HTML content of the email template.
	Content string `json:"content" url:"content"`
	// True if this email template is the default template for new invoices.
	IsDefault bool `json:"isDefault" url:"isDefault"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailTemplateResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailTemplateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailTemplateResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailTemplateType string

const (
	EmailTemplateTypePayment      EmailTemplateType = "PAYMENT"
	EmailTemplateTypeDisbursement EmailTemplateType = "DISBURSEMENT"
)

func NewEmailTemplateTypeFromString(s string) (EmailTemplateType, error) {
	switch s {
	case "PAYMENT":
		return EmailTemplateTypePayment, nil
	case "DISBURSEMENT":
		return EmailTemplateTypeDisbursement, nil
	}
	var t EmailTemplateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailTemplateType) Ptr() *EmailTemplateType {
	return &e
}

type EntityAddPayeesRequest struct {
	// List of payee entity IDs or foreign IDs to associate with the entity
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`
	// List of customizations to apply to the payees. If the payee is not currently a counterparty of the entity, the counterparty will be created with the provided customizations.
	Customizations []*CounterpartyCustomizationRequest `json:"customizations,omitempty" url:"customizations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityAddPayeesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddPayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayeesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayeesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityAddPayorsRequest struct {
	// List of payor entity IDs or foreign IDs to associate with the entity
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`
	// List of customizations to apply to the payors. If the payor is not currently a counterparty of the entity, the counterparty will be created with the provided customizations.
	Customizations []*CounterpartyCustomizationRequest `json:"customizations,omitempty" url:"customizations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityAddPayorsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityAddPayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityAddPayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityAddPayorsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityAddPayorsRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCustomizationRequest struct {
	Metadata           []*MetadataCustomizationRequest      `json:"metadata,omitempty" url:"metadata,omitempty"`
	PaymentSource      []*PaymentMethodCustomizationRequest `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	BackupDisbursement []*PaymentMethodCustomizationRequest `json:"backupDisbursement,omitempty" url:"backupDisbursement,omitempty"`
	PaymentDestination []*PaymentMethodCustomizationRequest `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCustomizationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCustomizationRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityCustomizationResponse struct {
	Metadata           []*MetadataCustomizationRequest      `json:"metadata,omitempty" url:"metadata,omitempty"`
	PaymentSource      []*PaymentMethodCustomizationRequest `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	BackupDisbursement []*PaymentMethodCustomizationRequest `json:"backupDisbursement,omitempty" url:"backupDisbursement,omitempty"`
	PaymentDestination []*PaymentMethodCustomizationRequest `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityCustomizationResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityCustomizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityCustomizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityCustomizationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityCustomizationResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEvent struct {
	WebhookIDs []string        `json:"webhookIds,omitempty" url:"webhookIds,omitempty"`
	Data       *EntityResponse `json:"data,omitempty" url:"data,omitempty"`
	CreatedAt  time.Time       `json:"createdAt" url:"createdAt"`
	// The ID of the user who triggered this event
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityEvent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEvent) UnmarshalJSON(data []byte) error {
	type embed EntityEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityEvent(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEvent) MarshalJSON() ([]byte, error) {
	type embed EntityEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityEvent) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEventsResponse struct {
	Data  []*EntityEvent `json:"data,omitempty" url:"data,omitempty"`
	Count int            `json:"count" url:"count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityEventsResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEventsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayeesRequest struct {
	// List of payee entity IDs or foreign IDs to hide
	Payees []EntityID `json:"payees,omitempty" url:"payees,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityHidePayeesRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityHidePayeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayeesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayeesRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityHidePayorsRequest struct {
	// List of payor entity IDs or foreign IDs to hide
	Payors []EntityID `json:"payors,omitempty" url:"payors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityHidePayorsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityHidePayorsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityHidePayorsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityHidePayorsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityHidePayorsRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityID = string

type EntityMetadataResponse struct {
	Key   string   `json:"key" url:"key"`
	Value []string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityMetadataResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityMetadataResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityMetadataResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityMetadataResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityMetadataResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityOnboardingLinkType string

const (
	EntityOnboardingLinkTypePayee EntityOnboardingLinkType = "PAYEE"
	EntityOnboardingLinkTypePayor EntityOnboardingLinkType = "PAYOR"
)

func NewEntityOnboardingLinkTypeFromString(s string) (EntityOnboardingLinkType, error) {
	switch s {
	case "PAYEE":
		return EntityOnboardingLinkTypePayee, nil
	case "PAYOR":
		return EntityOnboardingLinkTypePayor, nil
	}
	var t EntityOnboardingLinkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityOnboardingLinkType) Ptr() *EntityOnboardingLinkType {
	return &e
}

type EntityRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  bool            `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType     `json:"accountType" url:"accountType"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// If this entity will be receiving payments, set this to true.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// Control if this entity should be available as a payor to any entity on your platform. If set to false, this entity will only be available as a payor to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayor *bool `json:"isNetworkPayor,omitempty" url:"isNetworkPayor,omitempty"`
	// Control if this entity should be available as a payee to any entity on your platform. If set to false, this entity will only be available as a payee to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayee *bool `json:"isNetworkPayee,omitempty" url:"isNetworkPayee,omitempty"`
	// Base64 encoded PNG image data for the entity logo. Max size 100KB.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityResponse) UnmarshalJSON(data []byte) error {
	type embed EntityResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityResponse) MarshalJSON() ([]byte, error) {
	type embed EntityResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityStatus string

const (
	EntityStatusUnverified EntityStatus = "unverified"
	EntityStatusPending    EntityStatus = "pending"
	EntityStatusResubmit   EntityStatus = "resubmit"
	EntityStatusReview     EntityStatus = "review"
	EntityStatusVerified   EntityStatus = "verified"
	EntityStatusFailed     EntityStatus = "failed"
)

func NewEntityStatusFromString(s string) (EntityStatus, error) {
	switch s {
	case "unverified":
		return EntityStatusUnverified, nil
	case "pending":
		return EntityStatusPending, nil
	case "resubmit":
		return EntityStatusResubmit, nil
	case "review":
		return EntityStatusReview, nil
	case "verified":
		return EntityStatusVerified, nil
	case "failed":
		return EntityStatusFailed, nil
	}
	var t EntityStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityStatus) Ptr() *EntityStatus {
	return &e
}

type EntityUpdateRequest struct {
	// The ID used to identify this entity in your system. This ID must be unique across all entities in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Sets the email address to which to send invoices to be added to the Invoice Inbox. Only provide the local-part/username of the email address, do not include the @domain.com
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias. Include the full email address.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// If this entity has a direct relationship with your organization (e.g your direct customer or client), set this to true. Otherwise, set to false (e.g your customer's vendors).
	IsCustomer  *bool           `json:"isCustomer,omitempty" url:"isCustomer,omitempty"`
	AccountType *AccountType    `json:"accountType,omitempty" url:"accountType,omitempty"`
	Profile     *ProfileRequest `json:"profile,omitempty" url:"profile,omitempty"`
	// If this entity will be paying invoices, set this to true.
	IsPayor *bool `json:"isPayor,omitempty" url:"isPayor,omitempty"`
	// If this entity will be receiving payments, set this to true.
	IsPayee *bool `json:"isPayee,omitempty" url:"isPayee,omitempty"`
	// Control if this entity should be available as a payor to any entity on your platform. If set to false, this entity will only be available as a payor to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayor *bool `json:"isNetworkPayor,omitempty" url:"isNetworkPayor,omitempty"`
	// Control if this entity should be available as a payee to any entity on your platform. If set to false, this entity will only be available as a payee to entities that have a direct relationship with this entity. Defaults to false.
	IsNetworkPayee *bool `json:"isNetworkPayee,omitempty" url:"isNetworkPayee,omitempty"`
	// Base64 encoded PNG image data for the entity logo. Max size 100KB.
	Logo *string `json:"logo,omitempty" url:"logo,omitempty"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity that this entity is connected to. This is used to trigger notifications to the connected entity when this entity is updated.
	ConnectedEntityID *EntityID `json:"connectedEntityId,omitempty" url:"connectedEntityId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityUpdateRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUpdateRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserID = string

type EntityUserRequest struct {
	// The ID used to identify this user in your system.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string `json:"email,omitempty" url:"email,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	// List of roles. A role can be any string. For example: "payer", "approver", "viewer"
	Roles []string `json:"roles,omitempty" url:"roles,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityUserRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityUserRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityUserResponse struct {
	ID EntityUserID `json:"id" url:"id"`
	// The ID used to identify this user in your system.
	ForeignID *string   `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	Email     *string   `json:"email,omitempty" url:"email,omitempty"`
	Name      *string   `json:"name,omitempty" url:"name,omitempty"`
	Roles     []string  `json:"roles,omitempty" url:"roles,omitempty"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityUserResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityUserResponse) UnmarshalJSON(data []byte) error {
	type embed EntityUserResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityUserResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityUserResponse) MarshalJSON() ([]byte, error) {
	type embed EntityUserResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityUserResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityWithPaymentMethodResponse struct {
	ID    EntityID `json:"id" url:"id"`
	Name  string   `json:"name" url:"name"`
	Email string   `json:"email" url:"email"`
	// The ID used to identify this entity in your system
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Local-part/username of the email address to which to send invoices to be added to the Invoice Inbox.
	EmailTo *string `json:"emailTo,omitempty" url:"emailTo,omitempty"`
	// Email inbox alias addresses. Used when forwarding emails to the emailTo address from an alias.
	EmailToAlias []string `json:"emailToAlias,omitempty" url:"emailToAlias,omitempty"`
	// True if this entity has a direct relationship with your organization.
	IsCustomer  bool             `json:"isCustomer" url:"isCustomer"`
	AccountType AccountType      `json:"accountType" url:"accountType"`
	Profile     *ProfileResponse `json:"profile,omitempty" url:"profile,omitempty"`
	// URL for the entity logo
	Logo   *string      `json:"logo,omitempty" url:"logo,omitempty"`
	Status EntityStatus `json:"status" url:"status"`
	// True if this entity has accepted the terms of service.
	AcceptedTos bool `json:"acceptedTos" url:"acceptedTos"`
	// True if this entity can pay invoices.
	IsPayor bool `json:"isPayor" url:"isPayor"`
	// True if this entity can receive payments.
	IsPayee bool `json:"isPayee" url:"isPayee"`
	// True if this entity is available as a payor to any entity on your platform. Otherwise this entity will only be available as a payor to entities that have a direct relationship with this entity.
	IsNetworkPayor bool `json:"isNetworkPayor" url:"isNetworkPayor"`
	// True if this entity is available as a payee to any entity on your platform. Otherwise this entity will only be available as a payee to entities that have a direct relationship with this entity.
	IsNetworkPayee bool `json:"isNetworkPayee" url:"isNetworkPayee"`
	// Simple key/value metadata associated with this entity. For more complex metadata, use the Metadata API.
	Metadata       map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt      time.Time                `json:"createdAt" url:"createdAt"`
	UpdatedAt      time.Time                `json:"updatedAt" url:"updatedAt"`
	PaymentMethods []*PaymentMethodResponse `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityWithPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityWithPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed EntityWithPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EntityWithPaymentMethodResponse(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	e.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityWithPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed EntityWithPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
		UpdatedAt: core.NewDateTime(e.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EntityWithPaymentMethodResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FindCounterpartiesResponse struct {
	// Total number of counterparties for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more counterparties available for the given filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*CounterpartyResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindCounterpartiesResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindCounterpartiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindCounterpartiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindCounterpartiesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindCounterpartiesResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindEntityResponse struct {
	// Total number of entities for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more entities available for the given filters.
	HasMore bool                               `json:"hasMore" url:"hasMore"`
	Data    []*EntityWithPaymentMethodResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindEntityResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindEntityUserResponse struct {
	// Total number of users for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more users available for the given filters.
	HasMore bool                  `json:"hasMore" url:"hasMore"`
	Data    []*EntityUserResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindEntityUserResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindEntityUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindEntityUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindEntityUserResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindEntityUserResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindNotificationResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*NotificationResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindNotificationResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindNotificationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindNotificationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindNotificationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindNotificationResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type IdentifierList struct {
	Type string
	// List of entity user roles that should be used to determine approvers
	RolesList []string
	// List of entity user IDs that should be used to determine approvers
	UserList []EntityUserID
}

func (i *IdentifierList) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "rolesList":
		var valueUnmarshaler struct {
			RolesList []string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.RolesList = valueUnmarshaler.RolesList
	case "userList":
		var valueUnmarshaler struct {
			UserList []EntityUserID `json:"value,omitempty"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.UserList = valueUnmarshaler.UserList
	}
	return nil
}

func (i IdentifierList) MarshalJSON() ([]byte, error) {
	if i.RolesList != nil {
		var marshaler = struct {
			Type      string   `json:"type"`
			RolesList []string `json:"value,omitempty"`
		}{
			Type:      "rolesList",
			RolesList: i.RolesList,
		}
		return json.Marshal(marshaler)
	}
	if i.UserList != nil {
		var marshaler = struct {
			Type     string         `json:"type"`
			UserList []EntityUserID `json:"value,omitempty"`
		}{
			Type:     "userList",
			UserList: i.UserList,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IdentifierListVisitor interface {
	VisitRolesList([]string) error
	VisitUserList([]EntityUserID) error
}

func (i *IdentifierList) Accept(visitor IdentifierListVisitor) error {
	if i.RolesList != nil {
		return visitor.VisitRolesList(i.RolesList)
	}
	if i.UserList != nil {
		return visitor.VisitUserList(i.UserList)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IndividualProfileRequest struct {
	Email        *string                 `json:"email,omitempty" url:"email,omitempty"`
	Name         *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone        *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Address      *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate    *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndividualProfileRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndividualProfileResponse struct {
	Email                *string      `json:"email,omitempty" url:"email,omitempty"`
	Name                 *FullName    `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	Address              *Address     `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool         `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool         `json:"governmentIDProvided" url:"governmentIDProvided"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndividualProfileResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualProfileResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IndustryCodes struct {
	Mcc *string `json:"mcc,omitempty" url:"mcc,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndustryCodes) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndustryCodes) UnmarshalJSON(data []byte) error {
	type unmarshaler IndustryCodes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndustryCodes(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndustryCodes) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LineItemAvailabilities string

const (
	LineItemAvailabilitiesDisabled LineItemAvailabilities = "DISABLED"
	LineItemAvailabilitiesOptional LineItemAvailabilities = "OPTIONAL"
	LineItemAvailabilitiesRequired LineItemAvailabilities = "REQUIRED"
)

func NewLineItemAvailabilitiesFromString(s string) (LineItemAvailabilities, error) {
	switch s {
	case "DISABLED":
		return LineItemAvailabilitiesDisabled, nil
	case "OPTIONAL":
		return LineItemAvailabilitiesOptional, nil
	case "REQUIRED":
		return LineItemAvailabilitiesRequired, nil
	}
	var t LineItemAvailabilities
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LineItemAvailabilities) Ptr() *LineItemAvailabilities {
	return &l
}

type MetadataCustomizationRequest struct {
	// The key of the metadata field. This must be defined at the organization level, otherwise an error will be returned.
	Key string `json:"key" url:"key"`
	// If true, this field will not be available to the entity.
	Disabled bool `json:"disabled" url:"disabled"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataCustomizationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataCustomizationRequest) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataTrigger struct {
	// The metadata key to match
	Key string `json:"key" url:"key"`
	// The metadata value the invoice must have to trigger this policy
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataTrigger) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataTrigger(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataTrigger) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NotificationID = string

type NotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this entity
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`
	// List of user IDs that should receive notifications in addition to the default users for this notification type
	AdditionalUsers []EntityUserID `json:"additionalUsers,omitempty" url:"additionalUsers,omitempty"`
	// Set to true if the selected notification type should be sent to the counterparty if this is a payable invoice.
	NotifyPayeeCounterparty *bool `json:"notifyPayeeCounterparty,omitempty" url:"notifyPayeeCounterparty,omitempty"`
	// Set to true if the selected notification type should be sent to the counterparty if this is a receivable invoice.
	NotifyPayorCounterparty *bool `json:"notifyPayorCounterparty,omitempty" url:"notifyPayorCounterparty,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationPolicyRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyRequest) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this entity
	Disabled bool `json:"disabled" url:"disabled"`
	// List of user roles that should receive notifications in addition to the default users for this notification type
	AdditionalRoles []string `json:"additionalRoles,omitempty" url:"additionalRoles,omitempty"`
	// List of user IDs that should receive notifications in addition to the default users for this notification type
	AdditionalUsers []EntityUserID `json:"additionalUsers,omitempty" url:"additionalUsers,omitempty"`
	// True if the selected notification type should be sent to the counterparty if this is a payable invoice.
	NotifyPayeeCounterparty bool `json:"notifyPayeeCounterparty" url:"notifyPayeeCounterparty"`
	// True if the selected notification type should be sent to the counterparty if this is a receivable invoice.
	NotifyPayorCounterparty bool             `json:"notifyPayorCounterparty" url:"notifyPayorCounterparty"`
	Type                    NotificationType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationPolicyResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationPolicyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationPolicyResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationResponse struct {
	ID NotificationID `json:"id" url:"id"`
	// The invoice ID that this notification is related to. This field is only present for notifications related to invoices.
	InvoiceID *InvoiceID         `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`
	Type      NotificationType   `json:"type" url:"type"`
	Status    NotificationStatus `json:"status" url:"status"`
	CreatedAt time.Time          `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationResponse) UnmarshalJSON(data []byte) error {
	type embed NotificationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NotificationResponse(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationResponse) MarshalJSON() ([]byte, error) {
	type embed NotificationResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*n),
		CreatedAt: core.NewDateTime(n.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *NotificationResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationStatus string

const (
	NotificationStatusPending NotificationStatus = "PENDING"
	NotificationStatusSent    NotificationStatus = "SENT"
	NotificationStatusRead    NotificationStatus = "READ"
	NotificationStatusFailed  NotificationStatus = "FAILED"
)

func NewNotificationStatusFromString(s string) (NotificationStatus, error) {
	switch s {
	case "PENDING":
		return NotificationStatusPending, nil
	case "SENT":
		return NotificationStatusSent, nil
	case "READ":
		return NotificationStatusRead, nil
	case "FAILED":
		return NotificationStatusFailed, nil
	}
	var t NotificationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationStatus) Ptr() *NotificationStatus {
	return &n
}

type NotificationType string

const (
	NotificationTypeInvoiceApprovalNeeded           NotificationType = "INVOICE_APPROVAL_NEEDED"
	NotificationTypeInvoiceApproved                 NotificationType = "INVOICE_APPROVED"
	NotificationTypeInvoiceRejected                 NotificationType = "INVOICE_REJECTED"
	NotificationTypeInvoiceScheduled                NotificationType = "INVOICE_SCHEDULED"
	NotificationTypeInvoicePending                  NotificationType = "INVOICE_PENDING"
	NotificationTypeInvoicePaid                     NotificationType = "INVOICE_PAID"
	NotificationTypeInvoiceCanceled                 NotificationType = "INVOICE_CANCELED"
	NotificationTypeInvoiceCreated                  NotificationType = "INVOICE_CREATED"
	NotificationTypeInvoiceEmailed                  NotificationType = "INVOICE_EMAILED"
	NotificationTypeInvoiceFailed                   NotificationType = "INVOICE_FAILED"
	NotificationTypeCounterpartyOnboardingCompleted NotificationType = "COUNTERPARTY_ONBOARDING_COMPLETED"
)

func NewNotificationTypeFromString(s string) (NotificationType, error) {
	switch s {
	case "INVOICE_APPROVAL_NEEDED":
		return NotificationTypeInvoiceApprovalNeeded, nil
	case "INVOICE_APPROVED":
		return NotificationTypeInvoiceApproved, nil
	case "INVOICE_REJECTED":
		return NotificationTypeInvoiceRejected, nil
	case "INVOICE_SCHEDULED":
		return NotificationTypeInvoiceScheduled, nil
	case "INVOICE_PENDING":
		return NotificationTypeInvoicePending, nil
	case "INVOICE_PAID":
		return NotificationTypeInvoicePaid, nil
	case "INVOICE_CANCELED":
		return NotificationTypeInvoiceCanceled, nil
	case "INVOICE_CREATED":
		return NotificationTypeInvoiceCreated, nil
	case "INVOICE_EMAILED":
		return NotificationTypeInvoiceEmailed, nil
	case "INVOICE_FAILED":
		return NotificationTypeInvoiceFailed, nil
	case "COUNTERPARTY_ONBOARDING_COMPLETED":
		return NotificationTypeCounterpartyOnboardingCompleted, nil
	}
	var t NotificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationType) Ptr() *NotificationType {
	return &n
}

type NotificationUpdateRequest struct {
	Status *NotificationStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationUpdateRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationUpdateRequest) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type PaymentMethodCustomizationRequest struct {
	Type PaymentMethodType `json:"type" url:"type"`
	// If type is custom, this is the ID of the schema to use for this payment method.
	SchemaID *string `json:"schemaId,omitempty" url:"schemaId,omitempty"`
	// If true, this method will will not be available to the entity.
	Disabled bool `json:"disabled" url:"disabled"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodCustomizationRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodCustomizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodCustomizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodCustomizationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodCustomizationRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileRequest struct {
	// If this entity is a business, set this field
	Business *BusinessProfileRequest `json:"business,omitempty" url:"business,omitempty"`
	// If this entity is a individual, set this field
	Individual *IndividualProfileRequest `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProfileRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProfileResponse struct {
	// Will be set if the entity is a business
	Business *BusinessProfileResponse `json:"business,omitempty" url:"business,omitempty"`
	// Will be set if the entity is a individual
	Individual *IndividualProfileResponse `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProfileResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProfileResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RepresentativeID = string

type RepresentativeRequest struct {
	Name *FullName `json:"name,omitempty" url:"name,omitempty"`
	// Either phone or email is required.
	Phone *PhoneNumber `json:"phone,omitempty" url:"phone,omitempty"`
	// Either phone or email is required.
	Email            *string                 `json:"email,omitempty" url:"email,omitempty"`
	Address          *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate        *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID     *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`
	Responsibilities *Responsibilities       `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RepresentativeRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RepresentativeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepresentativeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RepresentativeResponse struct {
	ID                   RepresentativeID  `json:"id" url:"id"`
	Name                 *FullName         `json:"name,omitempty" url:"name,omitempty"`
	Phone                *PhoneNumber      `json:"phone,omitempty" url:"phone,omitempty"`
	Email                *string           `json:"email,omitempty" url:"email,omitempty"`
	Address              *Address          `json:"address,omitempty" url:"address,omitempty"`
	BirthDateProvided    bool              `json:"birthDateProvided" url:"birthDateProvided"`
	GovernmentIDProvided bool              `json:"governmentIDProvided" url:"governmentIDProvided"`
	Responsibilities     *Responsibilities `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`
	CreatedOn            time.Time         `json:"createdOn" url:"createdOn"`
	UpdatedOn            time.Time         `json:"updatedOn" url:"updatedOn"`
	DisabledOn           *time.Time        `json:"disabledOn,omitempty" url:"disabledOn,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RepresentativeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeResponse) UnmarshalJSON(data []byte) error {
	type embed RepresentativeResponse
	var unmarshaler = struct {
		embed
		CreatedOn  *core.DateTime `json:"createdOn"`
		UpdatedOn  *core.DateTime `json:"updatedOn"`
		DisabledOn *core.DateTime `json:"disabledOn,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RepresentativeResponse(unmarshaler.embed)
	r.CreatedOn = unmarshaler.CreatedOn.Time()
	r.UpdatedOn = unmarshaler.UpdatedOn.Time()
	r.DisabledOn = unmarshaler.DisabledOn.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeResponse) MarshalJSON() ([]byte, error) {
	type embed RepresentativeResponse
	var marshaler = struct {
		embed
		CreatedOn  *core.DateTime `json:"createdOn"`
		UpdatedOn  *core.DateTime `json:"updatedOn"`
		DisabledOn *core.DateTime `json:"disabledOn,omitempty"`
	}{
		embed:      embed(*r),
		CreatedOn:  core.NewDateTime(r.CreatedOn),
		UpdatedOn:  core.NewDateTime(r.UpdatedOn),
		DisabledOn: core.NewOptionalDateTime(r.DisabledOn),
	}
	return json.Marshal(marshaler)
}

func (r *RepresentativeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RepresentativeUpdateRequest struct {
	Name             *FullName               `json:"name,omitempty" url:"name,omitempty"`
	Phone            *PhoneNumber            `json:"phone,omitempty" url:"phone,omitempty"`
	Email            *string                 `json:"email,omitempty" url:"email,omitempty"`
	Address          *Address                `json:"address,omitempty" url:"address,omitempty"`
	BirthDate        *BirthDate              `json:"birthDate,omitempty" url:"birthDate,omitempty"`
	GovernmentID     *IndividualGovernmentID `json:"governmentID,omitempty" url:"governmentID,omitempty"`
	Responsibilities *Responsibilities       `json:"responsibilities,omitempty" url:"responsibilities,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RepresentativeUpdateRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RepresentativeUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RepresentativeUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RepresentativeUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RepresentativeUpdateRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Responsibilities struct {
	JobTitle *string `json:"jobTitle,omitempty" url:"jobTitle,omitempty"`
	// Indicates whether this individual has significant management responsibilities within the business
	IsController *bool `json:"isController,omitempty" url:"isController,omitempty"`
	// Indicates whether this individual has an ownership stake of at least 25% in the business
	IsOwner *bool `json:"isOwner,omitempty" url:"isOwner,omitempty"`
	// Percentage of ownership in the business. Must be between 0 and 100.
	OwnershipPercentage *int `json:"ownershipPercentage,omitempty" url:"ownershipPercentage,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Responsibilities) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Responsibilities) UnmarshalJSON(data []byte) error {
	type unmarshaler Responsibilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Responsibilities(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Responsibilities) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Rule struct {
	Type     string
	Approver *ApproverRule
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "approver":
		value := new(ApproverRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Approver = value
	}
	return nil
}

func (r Rule) MarshalJSON() ([]byte, error) {
	if r.Approver != nil {
		return core.MarshalJSONWithExtraProperty(r.Approver, "type", "approver")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RuleVisitor interface {
	VisitApprover(*ApproverRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	if r.Approver != nil {
		return visitor.VisitApprover(r.Approver)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

type TaxID struct {
	Ein *Ein `json:"ein,omitempty" url:"ein,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TaxID) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxID) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxID(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxID) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationEntityOptions struct {
	// If true, will require entity to undergo KYB to use Mercoa payment rails and will capture required KYB data in the portal.
	EnableMercoaPayments *bool `json:"enableMercoaPayments,omitempty" url:"enableMercoaPayments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationEntityOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationEntityOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationEntityOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationEntityOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationEntityOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationInvoiceOptions struct {
	// Defaults to OPTIONAL. If set to REQUIRED, the user will be required to provide at least one line item when creating an invoice. If set to DISABLED, the user will not be able to provide line items when creating an invoice.
	LineItems *LineItemAvailabilities `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// DEPRECATED. Use lineItems instead.
	DisableLineItems *bool           `json:"disableLineItems,omitempty" url:"disableLineItems,omitempty"`
	Status           []InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationInvoiceOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationInvoiceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationInvoiceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationInvoiceOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationInvoiceOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationOptions struct {
	// Expressed in seconds or a string describing a time span. The default is 1h.
	ExpiresIn *string                        `json:"expiresIn,omitempty" url:"expiresIn,omitempty"`
	Invoice   *TokenGenerationInvoiceOptions `json:"invoice,omitempty" url:"invoice,omitempty"`
	Pages     *TokenGenerationPagesOptions   `json:"pages,omitempty" url:"pages,omitempty"`
	Style     *TokenGenerationStyleOptions   `json:"style,omitempty" url:"style,omitempty"`
	Vendors   *TokenGenerationVendorOptions  `json:"vendors,omitempty" url:"vendors,omitempty"`
	Entity    *TokenGenerationEntityOptions  `json:"entity,omitempty" url:"entity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationPagesOptions struct {
	PaymentMethods  *bool `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	Representatives *bool `json:"representatives,omitempty" url:"representatives,omitempty"`
	Notifications   *bool `json:"notifications,omitempty" url:"notifications,omitempty"`
	Counterparties  *bool `json:"counterparties,omitempty" url:"counterparties,omitempty"`
	Approvals       *bool `json:"approvals,omitempty" url:"approvals,omitempty"`
	EmailLog        *bool `json:"emailLog,omitempty" url:"emailLog,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationPagesOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationPagesOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationPagesOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationPagesOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationPagesOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationStyleOptions struct {
	PrimaryColor string `json:"primaryColor" url:"primaryColor"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationStyleOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationStyleOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationStyleOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationStyleOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationStyleOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenGenerationVendorOptions struct {
	// If true, the user will not be able to create new vendors.
	DisableCreation *bool         `json:"disableCreation,omitempty" url:"disableCreation,omitempty"`
	Network         VendorNetwork `json:"network" url:"network"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenGenerationVendorOptions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenGenerationVendorOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenGenerationVendorOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenGenerationVendorOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenGenerationVendorOptions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Trigger struct {
	Type     string
	Amount   *AmountTrigger
	Vendor   *VendorTrigger
	Metadata *MetadataTrigger
}

func (t *Trigger) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "amount":
		value := new(AmountTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Amount = value
	case "vendor":
		value := new(VendorTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Vendor = value
	case "metadata":
		value := new(MetadataTrigger)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Metadata = value
	}
	return nil
}

func (t Trigger) MarshalJSON() ([]byte, error) {
	if t.Amount != nil {
		return core.MarshalJSONWithExtraProperty(t.Amount, "type", "amount")
	}
	if t.Vendor != nil {
		return core.MarshalJSONWithExtraProperty(t.Vendor, "type", "vendor")
	}
	if t.Metadata != nil {
		return core.MarshalJSONWithExtraProperty(t.Metadata, "type", "metadata")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TriggerVisitor interface {
	VisitAmount(*AmountTrigger) error
	VisitVendor(*VendorTrigger) error
	VisitMetadata(*MetadataTrigger) error
}

func (t *Trigger) Accept(visitor TriggerVisitor) error {
	if t.Amount != nil {
		return visitor.VisitAmount(t.Amount)
	}
	if t.Vendor != nil {
		return visitor.VisitVendor(t.Vendor)
	}
	if t.Metadata != nil {
		return visitor.VisitMetadata(t.Metadata)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type UserNotificationPolicyRequest struct {
	// Set to true if the selected notification type should be disabled for this user
	Disabled *bool `json:"disabled,omitempty" url:"disabled,omitempty"`
	// Set to true if the selected notification type should be sent as a digest. Default is false.
	Digest *bool `json:"digest,omitempty" url:"digest,omitempty"`
	// Set to true if the selected notification type should be sent immediately. Default is true.
	Immediate *bool `json:"immediate,omitempty" url:"immediate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserNotificationPolicyRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserNotificationPolicyRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserNotificationPolicyResponse struct {
	// True if the selected notification type is disabled for this user
	Disabled bool `json:"disabled" url:"disabled"`
	// True if the selected notification type is sent as a digest.
	Digest bool `json:"digest" url:"digest"`
	// True if the selected notification type is sent immediately.
	Immediate bool             `json:"immediate" url:"immediate"`
	Type      NotificationType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UserNotificationPolicyResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserNotificationPolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UserNotificationPolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserNotificationPolicyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserNotificationPolicyResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type VendorNetwork string

const (
	VendorNetworkAll      VendorNetwork = "all"
	VendorNetworkPlatform VendorNetwork = "platform"
	VendorNetworkEntity   VendorNetwork = "entity"
)

func NewVendorNetworkFromString(s string) (VendorNetwork, error) {
	switch s {
	case "all":
		return VendorNetworkAll, nil
	case "platform":
		return VendorNetworkPlatform, nil
	case "entity":
		return VendorNetworkEntity, nil
	}
	var t VendorNetwork
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VendorNetwork) Ptr() *VendorNetwork {
	return &v
}

type VendorTrigger struct {
	VendorIDs []EntityID `json:"vendorIds,omitempty" url:"vendorIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorTrigger) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorTrigger) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorTrigger
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorTrigger(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorTrigger) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type AddApproverRequest struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID *ApprovalSlotID `json:"approvalSlotId,omitempty" url:"approvalSlotId,omitempty"`
	// The ID or the Foreign ID of the user to add to the approval slot.
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddApproverRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddApproverRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddApproverRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddApproverRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddApproverRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalRequest struct {
	// Comment associated with this approval action.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID or the Foreign ID of the user
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlot struct {
	// The identifier for the approval policy this slot is associated with.
	ApprovalPolicyID ApprovalPolicyID `json:"approvalPolicyId" url:"approvalPolicyId"`
	// The identifier for this approval slot
	ApprovalSlotID  ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	AssignedUserID  *EntityUserID  `json:"assignedUserId,omitempty" url:"assignedUserId,omitempty"`
	Action          ApproverAction `json:"action" url:"action"`
	EligibleRoles   []string       `json:"eligibleRoles,omitempty" url:"eligibleRoles,omitempty"`
	EligibleUserIDs []EntityUserID `json:"eligibleUserIds,omitempty" url:"eligibleUserIds,omitempty"`
	// Either the date the invoice was created, date the approver was assigned, or date of last action by approver, whichever is latest.
	Date time.Time `json:"date" url:"date"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalSlot) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlot) UnmarshalJSON(data []byte) error {
	type embed ApprovalSlot
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalSlot(unmarshaler.embed)
	a.Date = unmarshaler.Date.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlot) MarshalJSON() ([]byte, error) {
	type embed ApprovalSlot
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*a),
		Date:  core.NewDateTime(a.Date),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalSlot) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotAssignment struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	AssignedUserID EntityUserID   `json:"assignedUserId" url:"assignedUserId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApprovalSlotAssignment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlotAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalSlotAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalSlotAssignment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlotAssignment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotID = string

type ApproverAction string

const (
	ApproverActionNone    ApproverAction = "NONE"
	ApproverActionApprove ApproverAction = "APPROVE"
	ApproverActionReject  ApproverAction = "REJECT"
)

func NewApproverActionFromString(s string) (ApproverAction, error) {
	switch s {
	case "NONE":
		return ApproverActionNone, nil
	case "APPROVE":
		return ApproverActionApprove, nil
	case "REJECT":
		return ApproverActionReject, nil
	}
	var t ApproverAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApproverAction) Ptr() *ApproverAction {
	return &a
}

type AssociatedApprovalAction struct {
	UserID EntityUserID   `json:"userId" url:"userId"`
	Action ApproverAction `json:"action" url:"action"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssociatedApprovalAction) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssociatedApprovalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler AssociatedApprovalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssociatedApprovalAction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssociatedApprovalAction) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BankAccountPaymentDestinationOptions struct {
	// Delivery method for ACH payments. Defaults to ACH_SAME_DAY.
	Delivery *BankDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`
	// ACH Statement Description. By default, this will be 'AP' followed by the first 8 characters of the invoice ID. Must be at least 4 characters and no more than 10 characters, and follow this regex pattern ^[a-zA-Z0-9\-#.$&* ]{4,10}$
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDestinationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDestinationOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankDeliveryMethod string

const (
	BankDeliveryMethodAchStandard    BankDeliveryMethod = "ACH_STANDARD"
	BankDeliveryMethodAchSameDay     BankDeliveryMethod = "ACH_SAME_DAY"
	BankDeliveryMethodAchAccelerated BankDeliveryMethod = "ACH_ACCELERATED"
)

func NewBankDeliveryMethodFromString(s string) (BankDeliveryMethod, error) {
	switch s {
	case "ACH_STANDARD":
		return BankDeliveryMethodAchStandard, nil
	case "ACH_SAME_DAY":
		return BankDeliveryMethodAchSameDay, nil
	case "ACH_ACCELERATED":
		return BankDeliveryMethodAchAccelerated, nil
	}
	var t BankDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankDeliveryMethod) Ptr() *BankDeliveryMethod {
	return &b
}

type CheckDeliveryMethod string

const (
	CheckDeliveryMethodPrint CheckDeliveryMethod = "PRINT"
	CheckDeliveryMethodMail  CheckDeliveryMethod = "MAIL"
)

func NewCheckDeliveryMethodFromString(s string) (CheckDeliveryMethod, error) {
	switch s {
	case "PRINT":
		return CheckDeliveryMethodPrint, nil
	case "MAIL":
		return CheckDeliveryMethodMail, nil
	}
	var t CheckDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckDeliveryMethod) Ptr() *CheckDeliveryMethod {
	return &c
}

type CheckPaymentDestinationOptions struct {
	// Delivery method for check disbursements. Defaults to MAIL.
	Delivery *CheckDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckPaymentDestinationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckPaymentDestinationOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentID = string

type CommentRequest struct {
	Text string `json:"text" url:"text"`
	// The ID or the Foreign ID of the user who created the comment.
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CommentRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentResponse struct {
	ID   string              `json:"id" url:"id"`
	Text string              `json:"text" url:"text"`
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`
	// If an approval action has triggered the generation of this comment, returns the associated approval action and actor
	AssociatedApprovalAction *AssociatedApprovalAction `json:"associatedApprovalAction,omitempty" url:"associatedApprovalAction,omitempty"`
	CreatedAt                time.Time                 `json:"createdAt" url:"createdAt"`
	UpdatedAt                time.Time                 `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CommentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentResponse) UnmarshalJSON(data []byte) error {
	type embed CommentResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CommentResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentResponse) MarshalJSON() ([]byte, error) {
	type embed CommentResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CommentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DayOfWeek string

const (
	DayOfWeekSunday    DayOfWeek = "0"
	DayOfWeekMonday    DayOfWeek = "1"
	DayOfWeekTuesday   DayOfWeek = "2"
	DayOfWeekWednesday DayOfWeek = "3"
	DayOfWeekThursday  DayOfWeek = "4"
	DayOfWeekFriday    DayOfWeek = "5"
	DayOfWeekSaturday  DayOfWeek = "6"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "0":
		return DayOfWeekSunday, nil
	case "1":
		return DayOfWeekMonday, nil
	case "2":
		return DayOfWeekTuesday, nil
	case "3":
		return DayOfWeekWednesday, nil
	case "4":
		return DayOfWeekThursday, nil
	case "5":
		return DayOfWeekFriday, nil
	case "6":
		return DayOfWeekSaturday, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

type FindInvoiceResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool               `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindInvoiceTemplateResponse struct {
	// Total number of invoice templates for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more invoice templates available for the given filters.
	HasMore bool                       `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceTemplateResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindInvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceTemplateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceTemplateResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type InvoiceCreationRequest struct {
	InvoiceCreationWithEntityRequest      *InvoiceCreationWithEntityRequest
	InvoiceCreationWithEntityGroupRequest *InvoiceCreationWithEntityGroupRequest
}

func (i *InvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	valueInvoiceCreationWithEntityRequest := new(InvoiceCreationWithEntityRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityRequest); err == nil {
		i.InvoiceCreationWithEntityRequest = valueInvoiceCreationWithEntityRequest
		return nil
	}
	valueInvoiceCreationWithEntityGroupRequest := new(InvoiceCreationWithEntityGroupRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityGroupRequest); err == nil {
		i.InvoiceCreationWithEntityGroupRequest = valueInvoiceCreationWithEntityGroupRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCreationRequest) MarshalJSON() ([]byte, error) {
	if i.InvoiceCreationWithEntityRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityRequest)
	}
	if i.InvoiceCreationWithEntityGroupRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityGroupRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationRequestVisitor interface {
	VisitInvoiceCreationWithEntityRequest(*InvoiceCreationWithEntityRequest) error
	VisitInvoiceCreationWithEntityGroupRequest(*InvoiceCreationWithEntityGroupRequest) error
}

func (i *InvoiceCreationRequest) Accept(visitor InvoiceCreationRequestVisitor) error {
	if i.InvoiceCreationWithEntityRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityRequest(i.InvoiceCreationWithEntityRequest)
	}
	if i.InvoiceCreationWithEntityGroupRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityGroupRequest(i.InvoiceCreationWithEntityGroupRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationWithEntityGroupRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule                  `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	LineItems       []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity group who created this invoice.
	CreatorEntityGroupID EntityGroupID `json:"creatorEntityGroupId" url:"creatorEntityGroupId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCreationWithEntityGroupRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityGroupRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityGroupRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityGroupRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityGroupRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityGroupRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityGroupRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreationWithEntityRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule                  `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	LineItems       []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice.
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCreationWithEntityRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceDateFilter string

const (
	InvoiceDateFilterInvoiceDate     InvoiceDateFilter = "INVOICE_DATE"
	InvoiceDateFilterDeductionDate   InvoiceDateFilter = "DEDUCTION_DATE"
	InvoiceDateFilterNextPaymentDate InvoiceDateFilter = "NEXT_PAYMENT_DATE"
	InvoiceDateFilterDueDate         InvoiceDateFilter = "DUE_DATE"
	InvoiceDateFilterSettlementDate  InvoiceDateFilter = "SETTLEMENT_DATE"
	InvoiceDateFilterCreatedAt       InvoiceDateFilter = "CREATED_AT"
	InvoiceDateFilterUpdatedAt       InvoiceDateFilter = "UPDATED_AT"
)

func NewInvoiceDateFilterFromString(s string) (InvoiceDateFilter, error) {
	switch s {
	case "INVOICE_DATE":
		return InvoiceDateFilterInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceDateFilterDeductionDate, nil
	case "NEXT_PAYMENT_DATE":
		return InvoiceDateFilterNextPaymentDate, nil
	case "DUE_DATE":
		return InvoiceDateFilterDueDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceDateFilterSettlementDate, nil
	case "CREATED_AT":
		return InvoiceDateFilterCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceDateFilterUpdatedAt, nil
	}
	var t InvoiceDateFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceDateFilter) Ptr() *InvoiceDateFilter {
	return &i
}

type InvoiceEvent struct {
	WebhookIDs []string         `json:"webhookIds,omitempty" url:"webhookIds,omitempty"`
	Data       *InvoiceResponse `json:"data,omitempty" url:"data,omitempty"`
	// The ID of the user who triggered this event
	UserID    *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`
	CreatedAt time.Time     `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEvent) UnmarshalJSON(data []byte) error {
	type embed InvoiceEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceEvent(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEvent) MarshalJSON() ([]byte, error) {
	type embed InvoiceEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceEvent) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceEventsResponse struct {
	Data  []*InvoiceEvent `json:"data,omitempty" url:"data,omitempty"`
	Count int             `json:"count" url:"count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceEventsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEventsResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFailureReason struct {
	// The failure reason code.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The failure reason description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceFailureReason) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFailureReason) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFailureReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFailureReason(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFailureReason) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFailureType string

const (
	InvoiceFailureTypeSourcePaymentError      InvoiceFailureType = "SOURCE_PAYMENT_ERROR"
	InvoiceFailureTypeDestinationPaymentError InvoiceFailureType = "DESTINATION_PAYMENT_ERROR"
	InvoiceFailureTypeRejectedHighRisk        InvoiceFailureType = "REJECTED_HIGH_RISK"
	InvoiceFailureTypeInsufficientFunds       InvoiceFailureType = "INSUFFICIENT_FUNDS"
	InvoiceFailureTypeProcessingError         InvoiceFailureType = "PROCESSING_ERROR"
)

func NewInvoiceFailureTypeFromString(s string) (InvoiceFailureType, error) {
	switch s {
	case "SOURCE_PAYMENT_ERROR":
		return InvoiceFailureTypeSourcePaymentError, nil
	case "DESTINATION_PAYMENT_ERROR":
		return InvoiceFailureTypeDestinationPaymentError, nil
	case "REJECTED_HIGH_RISK":
		return InvoiceFailureTypeRejectedHighRisk, nil
	case "INSUFFICIENT_FUNDS":
		return InvoiceFailureTypeInsufficientFunds, nil
	case "PROCESSING_ERROR":
		return InvoiceFailureTypeProcessingError, nil
	}
	var t InvoiceFailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceFailureType) Ptr() *InvoiceFailureType {
	return &i
}

type InvoiceFeesRequest struct {
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceFeesRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFeesResponse struct {
	// Fee charged to the platform (C1) for processing the source payment method. For example, credit card interchange and acquiring fees.
	SourcePaymentMethodFee float64 `json:"sourcePaymentMethodFee" url:"sourcePaymentMethodFee"`
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the platform (C1) for processing the destination payment method. For example, postage for a check payment.
	DestinationPaymentMethodFee float64 `json:"destinationPaymentMethodFee" url:"destinationPaymentMethodFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceFeesResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceID = string

type InvoiceLineItemCategory string

const (
	InvoiceLineItemCategoryExpense  InvoiceLineItemCategory = "EXPENSE"
	InvoiceLineItemCategoryRevenue  InvoiceLineItemCategory = "REVENUE"
	InvoiceLineItemCategoryTax      InvoiceLineItemCategory = "TAX"
	InvoiceLineItemCategoryShipping InvoiceLineItemCategory = "SHIPPING"
	InvoiceLineItemCategoryDiscount InvoiceLineItemCategory = "DISCOUNT"
	InvoiceLineItemCategoryOther    InvoiceLineItemCategory = "OTHER"
)

func NewInvoiceLineItemCategoryFromString(s string) (InvoiceLineItemCategory, error) {
	switch s {
	case "EXPENSE":
		return InvoiceLineItemCategoryExpense, nil
	case "REVENUE":
		return InvoiceLineItemCategoryRevenue, nil
	case "TAX":
		return InvoiceLineItemCategoryTax, nil
	case "SHIPPING":
		return InvoiceLineItemCategoryShipping, nil
	case "DISCOUNT":
		return InvoiceLineItemCategoryDiscount, nil
	case "OTHER":
		return InvoiceLineItemCategoryOther, nil
	}
	var t InvoiceLineItemCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceLineItemCategory) Ptr() *InvoiceLineItemCategory {
	return &i
}

type InvoiceLineItemCreationRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item. Defaults to EXPENSE.
	Category         *InvoiceLineItemCategory `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time               `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time               `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      float64 `json:"amount" url:"amount"`
	Description string  `json:"description" url:"description"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceLineItemCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemCreationRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemCreationRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemCreationRequest
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemCreationRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemID = string

type InvoiceLineItemIndividualUpdateRequest struct {
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Category of the line item. Defaults to EXPENSE.
	Category         *InvoiceLineItemCategory `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time               `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time               `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemIndividualUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemIndividualUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemIndividualUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemIndividualUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemIndividualUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemIndividualUpdateRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemRequestBase struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item. Defaults to EXPENSE.
	Category         *InvoiceLineItemCategory `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time               `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time               `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceLineItemRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemRequestBase
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemRequestBase(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemRequestBase
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemRequestBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemResponse struct {
	ID InvoiceLineItemID `json:"id" url:"id"`
	// Total amount of line item in major units.
	Amount      *float64     `json:"amount,omitempty" url:"amount,omitempty"`
	Currency    CurrencyCode `json:"currency" url:"currency"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Name        *string      `json:"name,omitempty" url:"name,omitempty"`
	Quantity    *float64     `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of line item in major units.
	UnitPrice        *float64                `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	Category         InvoiceLineItemCategory `json:"category" url:"category"`
	ServiceStartDate *time.Time              `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time              `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string       `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string   `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceLineItemResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemResponse
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemResponse(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemResponse
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *core.DateTime `json:"createdAt"`
		UpdatedAt        *core.DateTime `json:"updatedAt"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:        core.NewDateTime(i.CreatedAt),
		UpdatedAt:        core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemUpdateRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item. Defaults to EXPENSE.
	Category         *InvoiceLineItemCategory `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time               `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time               `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string        `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// If provided, will overwrite line item on the invoice with this ID. If not provided, will create a new line item.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	Description *string  `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceLineItemUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemUpdateRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsGroupBy string

const (
	InvoiceMetricsGroupByStatus InvoiceMetricsGroupBy = "STATUS"
)

func NewInvoiceMetricsGroupByFromString(s string) (InvoiceMetricsGroupBy, error) {
	switch s {
	case "STATUS":
		return InvoiceMetricsGroupByStatus, nil
	}
	var t InvoiceMetricsGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsGroupBy) Ptr() *InvoiceMetricsGroupBy {
	return &i
}

type InvoiceMetricsPerDateFrequency string

const (
	InvoiceMetricsPerDateFrequencyDaily   InvoiceMetricsPerDateFrequency = "DAILY"
	InvoiceMetricsPerDateFrequencyWeekly  InvoiceMetricsPerDateFrequency = "WEEKLY"
	InvoiceMetricsPerDateFrequencyMonthly InvoiceMetricsPerDateFrequency = "MONTHLY"
	InvoiceMetricsPerDateFrequencyYearly  InvoiceMetricsPerDateFrequency = "YEARLY"
)

func NewInvoiceMetricsPerDateFrequencyFromString(s string) (InvoiceMetricsPerDateFrequency, error) {
	switch s {
	case "DAILY":
		return InvoiceMetricsPerDateFrequencyDaily, nil
	case "WEEKLY":
		return InvoiceMetricsPerDateFrequencyWeekly, nil
	case "MONTHLY":
		return InvoiceMetricsPerDateFrequencyMonthly, nil
	case "YEARLY":
		return InvoiceMetricsPerDateFrequencyYearly, nil
	}
	var t InvoiceMetricsPerDateFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateFrequency) Ptr() *InvoiceMetricsPerDateFrequency {
	return &i
}

type InvoiceMetricsPerDateGroupBy string

const (
	InvoiceMetricsPerDateGroupByCreationDate    InvoiceMetricsPerDateGroupBy = "CREATION_DATE"
	InvoiceMetricsPerDateGroupByDueDate         InvoiceMetricsPerDateGroupBy = "DUE_DATE"
	InvoiceMetricsPerDateGroupByInvoiceDate     InvoiceMetricsPerDateGroupBy = "INVOICE_DATE"
	InvoiceMetricsPerDateGroupByDeductionDate   InvoiceMetricsPerDateGroupBy = "DEDUCTION_DATE"
	InvoiceMetricsPerDateGroupByNextPaymentDate InvoiceMetricsPerDateGroupBy = "NEXT_PAYMENT_DATE"
)

func NewInvoiceMetricsPerDateGroupByFromString(s string) (InvoiceMetricsPerDateGroupBy, error) {
	switch s {
	case "CREATION_DATE":
		return InvoiceMetricsPerDateGroupByCreationDate, nil
	case "DUE_DATE":
		return InvoiceMetricsPerDateGroupByDueDate, nil
	case "INVOICE_DATE":
		return InvoiceMetricsPerDateGroupByInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceMetricsPerDateGroupByDeductionDate, nil
	case "NEXT_PAYMENT_DATE":
		return InvoiceMetricsPerDateGroupByNextPaymentDate, nil
	}
	var t InvoiceMetricsPerDateGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateGroupBy) Ptr() *InvoiceMetricsPerDateGroupBy {
	return &i
}

type InvoiceMetricsPerDateResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string `json:"group,omitempty" url:"group,omitempty"`
	Date          time.Time           `json:"date" url:"date"`
	TotalAmount   float64             `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                 `json:"totalCount" url:"totalCount"`
	AverageAmount float64             `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode        `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceMetricsPerDateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsPerDateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceMetricsPerDateResponse
	var unmarshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceMetricsPerDateResponse(unmarshaler.embed)
	i.Date = unmarshaler.Date.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsPerDateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceMetricsPerDateResponse
	var marshaler = struct {
		embed
		Date *core.DateTime `json:"date"`
	}{
		embed: embed(*i),
		Date:  core.NewDateTime(i.Date),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceMetricsPerDateResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string                       `json:"group,omitempty" url:"group,omitempty"`
	TotalAmount   float64                                   `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                                       `json:"totalCount" url:"totalCount"`
	AverageAmount float64                                   `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode                              `json:"currency" url:"currency"`
	Dates         map[string]*InvoiceMetricsPerDateResponse `json:"dates,omitempty" url:"dates,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceMetricsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceMetricsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceOrderByField string

const (
	InvoiceOrderByFieldAmount          InvoiceOrderByField = "AMOUNT"
	InvoiceOrderByFieldDueDate         InvoiceOrderByField = "DUE_DATE"
	InvoiceOrderByFieldCreatedAt       InvoiceOrderByField = "CREATED_AT"
	InvoiceOrderByFieldUpdatedAt       InvoiceOrderByField = "UPDATED_AT"
	InvoiceOrderByFieldDeductionDate   InvoiceOrderByField = "DEDUCTION_DATE"
	InvoiceOrderByFieldInvoiceDate     InvoiceOrderByField = "INVOICE_DATE"
	InvoiceOrderByFieldSettlementDate  InvoiceOrderByField = "SETTLEMENT_DATE"
	InvoiceOrderByFieldInvoiceNumber   InvoiceOrderByField = "INVOICE_NUMBER"
	InvoiceOrderByFieldVendorName      InvoiceOrderByField = "VENDOR_NAME"
	InvoiceOrderByFieldPayerName       InvoiceOrderByField = "PAYER_NAME"
	InvoiceOrderByFieldNextPaymentDate InvoiceOrderByField = "NEXT_PAYMENT_DATE"
)

func NewInvoiceOrderByFieldFromString(s string) (InvoiceOrderByField, error) {
	switch s {
	case "AMOUNT":
		return InvoiceOrderByFieldAmount, nil
	case "DUE_DATE":
		return InvoiceOrderByFieldDueDate, nil
	case "CREATED_AT":
		return InvoiceOrderByFieldCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceOrderByFieldUpdatedAt, nil
	case "DEDUCTION_DATE":
		return InvoiceOrderByFieldDeductionDate, nil
	case "INVOICE_DATE":
		return InvoiceOrderByFieldInvoiceDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceOrderByFieldSettlementDate, nil
	case "INVOICE_NUMBER":
		return InvoiceOrderByFieldInvoiceNumber, nil
	case "VENDOR_NAME":
		return InvoiceOrderByFieldVendorName, nil
	case "PAYER_NAME":
		return InvoiceOrderByFieldPayerName, nil
	case "NEXT_PAYMENT_DATE":
		return InvoiceOrderByFieldNextPaymentDate, nil
	}
	var t InvoiceOrderByField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceOrderByField) Ptr() *InvoiceOrderByField {
	return &i
}

type InvoiceRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceRequestBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// If this is a recurring invoice, this will be the next date when funds are scheduled to be deducted from payer's account.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	Approvers      []*ApprovalSlot            `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse  `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	ID              InvoiceID        `json:"id" url:"id"`
	// Date when the invoice payment was processed.
	ProcessedAt *time.Time `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// If the invoice failed to be paid, this field will be populated with the type of failure.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *InvoiceFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
		ProcessedAt       *core.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *core.DateTime `json:"settlementDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	i.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponse
	var marshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
		ProcessedAt       *core.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *core.DateTime `json:"settlementDate,omitempty"`
	}{
		embed:             embed(*i),
		InvoiceDate:       core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     core.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: core.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    core.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         core.NewDateTime(i.CreatedAt),
		UpdatedAt:         core.NewDateTime(i.UpdatedAt),
		ProcessedAt:       core.NewOptionalDateTime(i.ProcessedAt),
		SettlementDate:    core.NewOptionalDateTime(i.SettlementDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponseBase struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// If this is a recurring invoice, this will be the next date when funds are scheduled to be deducted from payer's account.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	Approvers      []*ApprovalSlot            `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse  `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceResponseBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponseBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponseBase
	var unmarshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponseBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponseBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponseBase
	var marshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     core.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: core.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    core.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         core.NewDateTime(i.CreatedAt),
		UpdatedAt:         core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponseBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceStatus string

const (
	InvoiceStatusUnassigned InvoiceStatus = "UNASSIGNED"
	InvoiceStatusDraft      InvoiceStatus = "DRAFT"
	InvoiceStatusNew        InvoiceStatus = "NEW"
	InvoiceStatusApproved   InvoiceStatus = "APPROVED"
	InvoiceStatusScheduled  InvoiceStatus = "SCHEDULED"
	InvoiceStatusPending    InvoiceStatus = "PENDING"
	InvoiceStatusPaid       InvoiceStatus = "PAID"
	InvoiceStatusArchived   InvoiceStatus = "ARCHIVED"
	InvoiceStatusRefused    InvoiceStatus = "REFUSED"
	InvoiceStatusCanceled   InvoiceStatus = "CANCELED"
	InvoiceStatusFailed     InvoiceStatus = "FAILED"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "UNASSIGNED":
		return InvoiceStatusUnassigned, nil
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "NEW":
		return InvoiceStatusNew, nil
	case "APPROVED":
		return InvoiceStatusApproved, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PENDING":
		return InvoiceStatusPending, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "ARCHIVED":
		return InvoiceStatusArchived, nil
	case "REFUSED":
		return InvoiceStatusRefused, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

type InvoiceTemplateCreationRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule                  `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	LineItems       []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice template.
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceTemplateCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateCreationRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateCreationRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateCreationRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateCreationRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateID = string

type InvoiceTemplateRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceTemplateRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateRequestBase) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// If this is a recurring invoice, this will be the next date when funds are scheduled to be deducted from payer's account.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	Approvers      []*ApprovalSlot            `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse  `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule  `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	ID              InvoiceTemplateID `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateResponse
	var marshaler = struct {
		embed
		InvoiceDate       *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *core.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *core.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *core.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *core.DateTime `json:"createdAt"`
		UpdatedAt         *core.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     core.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: core.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    core.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         core.NewDateTime(i.CreatedAt),
		UpdatedAt:         core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule                `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	LineItems       []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceTemplateUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateUpdateRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64 encoded image or PDF of invoice document. PNG, JPG, WEBP, and PDF are supported. 10MB max. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule                `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	LineItems       []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *core.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *core.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *core.DateTime `json:"settlementDate,omitempty"`
		DueDate          *core.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *core.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *core.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      core.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    core.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   core.NewOptionalDateTime(i.SettlementDate),
		DueDate:          core.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: core.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   core.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceUpdateRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MetadataFilter struct {
	Key string `json:"key" url:"key"`
	// If multiple values are provided, the filter will match if any of the values match (OR filter)
	Value *StringOrStringArray `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataFilter) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataFilter) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaymentDestinationOptions struct {
	Type        string
	Check       *CheckPaymentDestinationOptions
	BankAccount *BankAccountPaymentDestinationOptions
	Utility     *UtilityPaymentDestinationOptions
}

func (p *PaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "check":
		value := new(CheckPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "bankAccount":
		value := new(BankAccountPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "utility":
		value := new(UtilityPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	}
	return nil
}

func (p PaymentDestinationOptions) MarshalJSON() ([]byte, error) {
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Utility != nil {
		return core.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentDestinationOptionsVisitor interface {
	VisitCheck(*CheckPaymentDestinationOptions) error
	VisitBankAccount(*BankAccountPaymentDestinationOptions) error
	VisitUtility(*UtilityPaymentDestinationOptions) error
}

func (p *PaymentDestinationOptions) Accept(visitor PaymentDestinationOptionsVisitor) error {
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMonthRepeatType string

const (
	PaymentMonthRepeatTypeStart PaymentMonthRepeatType = "start"
	PaymentMonthRepeatTypeEnd   PaymentMonthRepeatType = "end"
)

func NewPaymentMonthRepeatTypeFromString(s string) (PaymentMonthRepeatType, error) {
	switch s {
	case "start":
		return PaymentMonthRepeatTypeStart, nil
	case "end":
		return PaymentMonthRepeatTypeEnd, nil
	}
	var t PaymentMonthRepeatType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMonthRepeatType) Ptr() *PaymentMonthRepeatType {
	return &p
}

type PaymentMonthSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// Offset from the start or end of the month to repeat on (0-30). Defaults to 0.
	DayOffset int `json:"dayOffset" url:"dayOffset"`
	// Type of offset. If start, will offset from the start of the month (so 10 with an offset of start will be on the 10th of the month). If end, will offset from the end of the month (so 10 with an offset of end will be the 20th).
	OffsetType *PaymentMonthRepeatType `json:"offsetType,omitempty" url:"offsetType,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMonthSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMonthSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMonthSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMonthSchedule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMonthSchedule) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentSchedule struct {
	Type    string
	OneTime *PaymentScheduleBase
	Daily   *PaymentScheduleBase
	Weekly  *PaymentWeekSchedule
	Monthly *PaymentMonthSchedule
	Yearly  *PaymentYearSchedule
}

func (p *PaymentSchedule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "oneTime":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OneTime = value
	case "daily":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Daily = value
	case "weekly":
		value := new(PaymentWeekSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Weekly = value
	case "monthly":
		value := new(PaymentMonthSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Monthly = value
	case "yearly":
		value := new(PaymentYearSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Yearly = value
	}
	return nil
}

func (p PaymentSchedule) MarshalJSON() ([]byte, error) {
	if p.OneTime != nil {
		return core.MarshalJSONWithExtraProperty(p.OneTime, "type", "oneTime")
	}
	if p.Daily != nil {
		return core.MarshalJSONWithExtraProperty(p.Daily, "type", "daily")
	}
	if p.Weekly != nil {
		return core.MarshalJSONWithExtraProperty(p.Weekly, "type", "weekly")
	}
	if p.Monthly != nil {
		return core.MarshalJSONWithExtraProperty(p.Monthly, "type", "monthly")
	}
	if p.Yearly != nil {
		return core.MarshalJSONWithExtraProperty(p.Yearly, "type", "yearly")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentScheduleVisitor interface {
	VisitOneTime(*PaymentScheduleBase) error
	VisitDaily(*PaymentScheduleBase) error
	VisitWeekly(*PaymentWeekSchedule) error
	VisitMonthly(*PaymentMonthSchedule) error
	VisitYearly(*PaymentYearSchedule) error
}

func (p *PaymentSchedule) Accept(visitor PaymentScheduleVisitor) error {
	if p.OneTime != nil {
		return visitor.VisitOneTime(p.OneTime)
	}
	if p.Daily != nil {
		return visitor.VisitDaily(p.Daily)
	}
	if p.Weekly != nil {
		return visitor.VisitWeekly(p.Weekly)
	}
	if p.Monthly != nil {
		return visitor.VisitMonthly(p.Monthly)
	}
	if p.Yearly != nil {
		return visitor.VisitYearly(p.Yearly)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentScheduleBase struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentScheduleBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentScheduleBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentScheduleBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentScheduleBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentScheduleBase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentScheduleEndCondition struct {
	Integer  int
	DateTime time.Time
}

func (p *PaymentScheduleEndCondition) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		p.Integer = valueInteger
		return nil
	}
	var valueDateTime *core.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		p.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentScheduleEndCondition) MarshalJSON() ([]byte, error) {
	if p.Integer != 0 {
		return json.Marshal(p.Integer)
	}
	if !p.DateTime.IsZero() {
		return json.Marshal(core.NewDateTime(p.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentScheduleEndConditionVisitor interface {
	VisitInteger(int) error
	VisitDateTime(time.Time) error
}

func (p *PaymentScheduleEndCondition) Accept(visitor PaymentScheduleEndConditionVisitor) error {
	if p.Integer != 0 {
		return visitor.VisitInteger(p.Integer)
	}
	if !p.DateTime.IsZero() {
		return visitor.VisitDateTime(p.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentType string

const (
	PaymentTypeOneTime   PaymentType = "oneTime"
	PaymentTypeRecurring PaymentType = "recurring"
)

func NewPaymentTypeFromString(s string) (PaymentType, error) {
	switch s {
	case "oneTime":
		return PaymentTypeOneTime, nil
	case "recurring":
		return PaymentTypeRecurring, nil
	}
	var t PaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentType) Ptr() *PaymentType {
	return &p
}

type PaymentWeekSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends     *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	RepeatOn []DayOfWeek                  `json:"repeatOn,omitempty" url:"repeatOn,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentWeekSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentWeekSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentWeekSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentWeekSchedule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentWeekSchedule) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentYearSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// Day of the month to repeat on (1-31).
	RepeatOnDay int `json:"repeatOnDay" url:"repeatOnDay"`
	// Month to repeat on (1-12).
	RepeatOnMonth int `json:"repeatOnMonth" url:"repeatOnMonth"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentYearSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentYearSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentYearSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentYearSchedule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentYearSchedule) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UtilityPaymentDestinationOptions struct {
	// The ID for the utility account to pay with. Links to accounts listed on payor/payee relationship.
	AccountID string `json:"accountId" url:"accountId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UtilityPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilityPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilityPaymentDestinationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentDestinationOptions) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type OcrJobStatus string

const (
	OcrJobStatusPending OcrJobStatus = "pending"
	OcrJobStatusSuccess OcrJobStatus = "success"
	OcrJobStatusFailed  OcrJobStatus = "failed"
)

func NewOcrJobStatusFromString(s string) (OcrJobStatus, error) {
	switch s {
	case "pending":
		return OcrJobStatusPending, nil
	case "success":
		return OcrJobStatusSuccess, nil
	case "failed":
		return OcrJobStatusFailed, nil
	}
	var t OcrJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrJobStatus) Ptr() *OcrJobStatus {
	return &o
}

type BusinessOnboardingOptions struct {
	TermsOfService                  *OnboardingOption `json:"termsOfService,omitempty" url:"termsOfService,omitempty"`
	Email                           *OnboardingOption `json:"email,omitempty" url:"email,omitempty"`
	Name                            *OnboardingOption `json:"name,omitempty" url:"name,omitempty"`
	Address                         *OnboardingOption `json:"address,omitempty" url:"address,omitempty"`
	Phone                           *OnboardingOption `json:"phone,omitempty" url:"phone,omitempty"`
	TenNinetyNine                   *OnboardingOption `json:"tenNinetyNine,omitempty" url:"tenNinetyNine,omitempty"`
	W9                              *OnboardingOption `json:"w9,omitempty" url:"w9,omitempty"`
	BankStatement                   *OnboardingOption `json:"bankStatement,omitempty" url:"bankStatement,omitempty"`
	Type                            *OnboardingOption `json:"type,omitempty" url:"type,omitempty"`
	DoingBusinessAs                 *OnboardingOption `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	Ein                             *OnboardingOption `json:"ein,omitempty" url:"ein,omitempty"`
	Mcc                             *OnboardingOption `json:"mcc,omitempty" url:"mcc,omitempty"`
	FormationDate                   *OnboardingOption `json:"formationDate,omitempty" url:"formationDate,omitempty"`
	Website                         *OnboardingOption `json:"website,omitempty" url:"website,omitempty"`
	Description                     *OnboardingOption `json:"description,omitempty" url:"description,omitempty"`
	Representatives                 *OnboardingOption `json:"representatives,omitempty" url:"representatives,omitempty"`
	Logo                            *OnboardingOption `json:"logo,omitempty" url:"logo,omitempty"`
	AverageTransactionSize          *OnboardingOption `json:"averageTransactionSize,omitempty" url:"averageTransactionSize,omitempty"`
	AverageMonthlyTransactionVolume *OnboardingOption `json:"averageMonthlyTransactionVolume,omitempty" url:"averageMonthlyTransactionVolume,omitempty"`
	MaxTransactionSize              *OnboardingOption `json:"maxTransactionSize,omitempty" url:"maxTransactionSize,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessOnboardingOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessOnboardingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessOnboardingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessOnboardingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessOnboardingOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CodatProviderRequest struct {
	APIKey string `json:"apiKey" url:"apiKey"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CodatProviderRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodatProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatProviderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatProviderRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CodatProviderResponse struct {
	HasAPIKey bool `json:"hasApiKey" url:"hasApiKey"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CodatProviderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodatProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CodatProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodatProviderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodatProviderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ColorSchemeRequest struct {
	PrimaryColor        *string `json:"primaryColor,omitempty" url:"primaryColor,omitempty"`
	SecondaryColor      *string `json:"secondaryColor,omitempty" url:"secondaryColor,omitempty"`
	LogoBackgroundColor *string `json:"logoBackgroundColor,omitempty" url:"logoBackgroundColor,omitempty"`
	RoundedCorners      *int    `json:"roundedCorners,omitempty" url:"roundedCorners,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ColorSchemeRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ColorSchemeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ColorSchemeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColorSchemeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColorSchemeRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ColorSchemeResponse struct {
	PrimaryColor        *string `json:"primaryColor,omitempty" url:"primaryColor,omitempty"`
	SecondaryColor      *string `json:"secondaryColor,omitempty" url:"secondaryColor,omitempty"`
	LogoBackgroundColor *string `json:"logoBackgroundColor,omitempty" url:"logoBackgroundColor,omitempty"`
	RoundedCorners      *int    `json:"roundedCorners,omitempty" url:"roundedCorners,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ColorSchemeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ColorSchemeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ColorSchemeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColorSchemeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColorSchemeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommonOnboardingOptions struct {
	TermsOfService *OnboardingOption `json:"termsOfService,omitempty" url:"termsOfService,omitempty"`
	Email          *OnboardingOption `json:"email,omitempty" url:"email,omitempty"`
	Name           *OnboardingOption `json:"name,omitempty" url:"name,omitempty"`
	Address        *OnboardingOption `json:"address,omitempty" url:"address,omitempty"`
	Phone          *OnboardingOption `json:"phone,omitempty" url:"phone,omitempty"`
	TenNinetyNine  *OnboardingOption `json:"tenNinetyNine,omitempty" url:"tenNinetyNine,omitempty"`
	W9             *OnboardingOption `json:"w9,omitempty" url:"w9,omitempty"`
	BankStatement  *OnboardingOption `json:"bankStatement,omitempty" url:"bankStatement,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CommonOnboardingOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommonOnboardingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonOnboardingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonOnboardingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonOnboardingOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EmailProviderRequest struct {
	Sender                  *EmailSenderRequest `json:"sender,omitempty" url:"sender,omitempty"`
	InboxDomain             string              `json:"inboxDomain" url:"inboxDomain"`
	AlternativeInboxDomains []string            `json:"alternativeInboxDomains,omitempty" url:"alternativeInboxDomains,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailProviderRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailProviderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailProviderRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailProviderResponse struct {
	Sender                  *EmailSenderResponse `json:"sender,omitempty" url:"sender,omitempty"`
	InboxDomain             string               `json:"inboxDomain" url:"inboxDomain"`
	AlternativeInboxDomains []string             `json:"alternativeInboxDomains,omitempty" url:"alternativeInboxDomains,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailProviderResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailProviderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailProviderResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailSenderProvider string

const (
	EmailSenderProviderNone     EmailSenderProvider = "none"
	EmailSenderProviderSendgrid EmailSenderProvider = "sendgrid"
	EmailSenderProviderSes      EmailSenderProvider = "ses"
	EmailSenderProviderResend   EmailSenderProvider = "resend"
)

func NewEmailSenderProviderFromString(s string) (EmailSenderProvider, error) {
	switch s {
	case "none":
		return EmailSenderProviderNone, nil
	case "sendgrid":
		return EmailSenderProviderSendgrid, nil
	case "ses":
		return EmailSenderProviderSes, nil
	case "resend":
		return EmailSenderProviderResend, nil
	}
	var t EmailSenderProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmailSenderProvider) Ptr() *EmailSenderProvider {
	return &e
}

type EmailSenderRequest struct {
	Provider  EmailSenderProvider `json:"provider" url:"provider"`
	FromEmail string              `json:"fromEmail" url:"fromEmail"`
	FromName  string              `json:"fromName" url:"fromName"`
	APIKey    *string             `json:"apiKey,omitempty" url:"apiKey,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailSenderRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailSenderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailSenderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailSenderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailSenderRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailSenderResponse struct {
	Provider  EmailSenderProvider `json:"provider" url:"provider"`
	FromEmail string              `json:"fromEmail" url:"fromEmail"`
	FromName  string              `json:"fromName" url:"fromName"`
	HasAPIKey bool                `json:"hasApiKey" url:"hasApiKey"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailSenderResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailSenderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailSenderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailSenderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailSenderResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalAccountingSystemProviderRequest struct {
	Type   string
	None   *CodatProviderRequest
	Codat  *CodatProviderRequest
	Rutter *RutterProviderRequest
}

func (e *ExternalAccountingSystemProviderRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "none":
		value := new(CodatProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.None = value
	case "codat":
		value := new(CodatProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterProviderRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	}
	return nil
}

func (e ExternalAccountingSystemProviderRequest) MarshalJSON() ([]byte, error) {
	if e.None != nil {
		return core.MarshalJSONWithExtraProperty(e.None, "type", "none")
	}
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderRequestVisitor interface {
	VisitNone(*CodatProviderRequest) error
	VisitCodat(*CodatProviderRequest) error
	VisitRutter(*RutterProviderRequest) error
}

func (e *ExternalAccountingSystemProviderRequest) Accept(visitor ExternalAccountingSystemProviderRequestVisitor) error {
	if e.None != nil {
		return visitor.VisitNone(e.None)
	}
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderResponse struct {
	Type   string
	None   *CodatProviderResponse
	Codat  *CodatProviderResponse
	Rutter *RutterProviderResponse
}

func (e *ExternalAccountingSystemProviderResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "none":
		value := new(CodatProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.None = value
	case "codat":
		value := new(CodatProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Codat = value
	case "rutter":
		value := new(RutterProviderResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Rutter = value
	}
	return nil
}

func (e ExternalAccountingSystemProviderResponse) MarshalJSON() ([]byte, error) {
	if e.None != nil {
		return core.MarshalJSONWithExtraProperty(e.None, "type", "none")
	}
	if e.Codat != nil {
		return core.MarshalJSONWithExtraProperty(e.Codat, "type", "codat")
	}
	if e.Rutter != nil {
		return core.MarshalJSONWithExtraProperty(e.Rutter, "type", "rutter")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExternalAccountingSystemProviderResponseVisitor interface {
	VisitNone(*CodatProviderResponse) error
	VisitCodat(*CodatProviderResponse) error
	VisitRutter(*RutterProviderResponse) error
}

func (e *ExternalAccountingSystemProviderResponse) Accept(visitor ExternalAccountingSystemProviderResponseVisitor) error {
	if e.None != nil {
		return visitor.VisitNone(e.None)
	}
	if e.Codat != nil {
		return visitor.VisitCodat(e.Codat)
	}
	if e.Rutter != nil {
		return visitor.VisitRutter(e.Rutter)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type IndividualOnboardingOptions struct {
	TermsOfService *OnboardingOption `json:"termsOfService,omitempty" url:"termsOfService,omitempty"`
	Email          *OnboardingOption `json:"email,omitempty" url:"email,omitempty"`
	Name           *OnboardingOption `json:"name,omitempty" url:"name,omitempty"`
	Address        *OnboardingOption `json:"address,omitempty" url:"address,omitempty"`
	Phone          *OnboardingOption `json:"phone,omitempty" url:"phone,omitempty"`
	TenNinetyNine  *OnboardingOption `json:"tenNinetyNine,omitempty" url:"tenNinetyNine,omitempty"`
	W9             *OnboardingOption `json:"w9,omitempty" url:"w9,omitempty"`
	BankStatement  *OnboardingOption `json:"bankStatement,omitempty" url:"bankStatement,omitempty"`
	DateOfBirth    *OnboardingOption `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty"`
	Ssn            *OnboardingOption `json:"ssn,omitempty" url:"ssn,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IndividualOnboardingOptions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IndividualOnboardingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler IndividualOnboardingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IndividualOnboardingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IndividualOnboardingOptions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceNotificationConfigurationRequest struct {
	URL string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceNotificationConfigurationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceNotificationConfigurationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceNotificationConfigurationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceNotificationConfigurationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceNotificationConfigurationRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceNotificationConfigurationResponse struct {
	URL  string           `json:"url" url:"url"`
	Type NotificationType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceNotificationConfigurationResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceNotificationConfigurationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceNotificationConfigurationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceNotificationConfigurationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceNotificationConfigurationResponse) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MetadataRegexValidationRule struct {
	// A regular expression that the value must match.
	Regex string `json:"regex" url:"regex"`
	// The error message to display if the value does not match the regular expression.
	ErrorMessage string `json:"errorMessage" url:"errorMessage"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataRegexValidationRule) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataRegexValidationRule) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataRegexValidationRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataRegexValidationRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataRegexValidationRule) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataSchema struct {
	Key         string  `json:"key" url:"key"`
	DisplayName string  `json:"displayName" url:"displayName"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Whether or not this field should be shown on line items. If true, this field will be shown on each line item. If false, the field will be shown on the invoice level. Defaults to false.
	LineItem *bool        `json:"lineItem,omitempty" url:"lineItem,omitempty"`
	Type     MetadataType `json:"type" url:"type"`
	// Whether or not multiple values are allowed for this field. Defaults to false. If true, the value will be a list of the specified type.
	AllowMultiple *bool `json:"allowMultiple,omitempty" url:"allowMultiple,omitempty"`
	// Validation rules are currently only supported for STRING types.
	ValidationRules *MetadataValidationRule `json:"validationRules,omitempty" url:"validationRules,omitempty"`
	// A list of conditional rules that determine whether or not this field should be shown. The field will only be shown if all of the conditions are met. If no conditions are specified, the field will always be shown.
	ShowConditions *MetadataShowConditions `json:"showConditions,omitempty" url:"showConditions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataSchema) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataSchema) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataShowConditions struct {
	// Show this field only if the entity has values set for the metadata key.
	HasOptions *bool `json:"hasOptions,omitempty" url:"hasOptions,omitempty"`
	// Show this field only if a document has been attached.
	HasDocument *bool `json:"hasDocument,omitempty" url:"hasDocument,omitempty"`
	// Show this field only if the invoice has no line items. Useful for showing a field that applies to the entire invoice but overridden by line items if present.
	HasNoLineItems *bool `json:"hasNoLineItems,omitempty" url:"hasNoLineItems,omitempty"`
	// Show this field only if the payment source type is in this list.
	PaymentSourceTypes []PaymentMethodType `json:"paymentSourceTypes,omitempty" url:"paymentSourceTypes,omitempty"`
	// Show this field only if the payment source schema ID is in this list of payment source schema IDs. This is only applicable if paymentSourceTypes contains CUSTOM.
	PaymentSourceCustomSchemaIDs []string `json:"paymentSourceCustomSchemaIds,omitempty" url:"paymentSourceCustomSchemaIds,omitempty"`
	// Show this field only if the payment destination type is in this list.
	PaymentDestinationTypes []PaymentMethodType `json:"paymentDestinationTypes,omitempty" url:"paymentDestinationTypes,omitempty"`
	// Show this field only if the payment destination schema ID is in this list of payment destination schema IDs. This is only applicable if paymentDestinationTypes contains CUSTOM.
	PaymentDestinationCustomSchemaIDs []string `json:"paymentDestinationCustomSchemaIds,omitempty" url:"paymentDestinationCustomSchemaIds,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataShowConditions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataShowConditions) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataShowConditions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataShowConditions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataShowConditions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataType string

const (
	MetadataTypeString   MetadataType = "STRING"
	MetadataTypeNumber   MetadataType = "NUMBER"
	MetadataTypeDate     MetadataType = "DATE"
	MetadataTypeBoolean  MetadataType = "BOOLEAN"
	MetadataTypeKeyValue MetadataType = "KEY_VALUE"
)

func NewMetadataTypeFromString(s string) (MetadataType, error) {
	switch s {
	case "STRING":
		return MetadataTypeString, nil
	case "NUMBER":
		return MetadataTypeNumber, nil
	case "DATE":
		return MetadataTypeDate, nil
	case "BOOLEAN":
		return MetadataTypeBoolean, nil
	case "KEY_VALUE":
		return MetadataTypeKeyValue, nil
	}
	var t MetadataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MetadataType) Ptr() *MetadataType {
	return &m
}

type MetadataValidationRule struct {
	Type  string
	Regex *MetadataRegexValidationRule
}

func (m *MetadataValidationRule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	m.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "regex":
		value := new(MetadataRegexValidationRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.Regex = value
	}
	return nil
}

func (m MetadataValidationRule) MarshalJSON() ([]byte, error) {
	if m.Regex != nil {
		return core.MarshalJSONWithExtraProperty(m.Regex, "type", "regex")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", m)
}

type MetadataValidationRuleVisitor interface {
	VisitRegex(*MetadataRegexValidationRule) error
}

func (m *MetadataValidationRule) Accept(visitor MetadataValidationRuleVisitor) error {
	if m.Regex != nil {
		return visitor.VisitRegex(m.Regex)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", m)
}

type NotificationConfigurationRequest struct {
	NotificationType string
	Invoice          *InvoiceNotificationConfigurationRequest
}

func (n *NotificationConfigurationRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		NotificationType string `json:"notificationType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.NotificationType = unmarshaler.NotificationType
	switch unmarshaler.NotificationType {
	case "invoice":
		value := new(InvoiceNotificationConfigurationRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Invoice = value
	}
	return nil
}

func (n NotificationConfigurationRequest) MarshalJSON() ([]byte, error) {
	if n.Invoice != nil {
		return core.MarshalJSONWithExtraProperty(n.Invoice, "notificationType", "invoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationRequestVisitor interface {
	VisitInvoice(*InvoiceNotificationConfigurationRequest) error
}

func (n *NotificationConfigurationRequest) Accept(visitor NotificationConfigurationRequestVisitor) error {
	if n.Invoice != nil {
		return visitor.VisitInvoice(n.Invoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationResponse struct {
	NotificationType string
	Invoice          *InvoiceNotificationConfigurationResponse
}

func (n *NotificationConfigurationResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		NotificationType string `json:"notificationType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.NotificationType = unmarshaler.NotificationType
	switch unmarshaler.NotificationType {
	case "invoice":
		value := new(InvoiceNotificationConfigurationResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Invoice = value
	}
	return nil
}

func (n NotificationConfigurationResponse) MarshalJSON() ([]byte, error) {
	if n.Invoice != nil {
		return core.MarshalJSONWithExtraProperty(n.Invoice, "notificationType", "invoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationConfigurationResponseVisitor interface {
	VisitInvoice(*InvoiceNotificationConfigurationResponse) error
}

func (n *NotificationConfigurationResponse) Accept(visitor NotificationConfigurationResponseVisitor) error {
	if n.Invoice != nil {
		return visitor.VisitInvoice(n.Invoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationEmailTemplateRequest struct {
	BackgroundStyle *string `json:"backgroundStyle,omitempty" url:"backgroundStyle,omitempty"`
	Header          *string `json:"header,omitempty" url:"header,omitempty"`
	Body            *string `json:"body,omitempty" url:"body,omitempty"`
	Signature       *string `json:"signature,omitempty" url:"signature,omitempty"`
	Footer          *string `json:"footer,omitempty" url:"footer,omitempty"`
	Button          *string `json:"button,omitempty" url:"button,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationEmailTemplateRequest) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationEmailTemplateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationEmailTemplateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationEmailTemplateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationEmailTemplateRequest) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationEmailTemplateResponse struct {
	BackgroundStyle *string `json:"backgroundStyle,omitempty" url:"backgroundStyle,omitempty"`
	Header          *string `json:"header,omitempty" url:"header,omitempty"`
	Body            *string `json:"body,omitempty" url:"body,omitempty"`
	Signature       *string `json:"signature,omitempty" url:"signature,omitempty"`
	Footer          *string `json:"footer,omitempty" url:"footer,omitempty"`
	Button          *string `json:"button,omitempty" url:"button,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationEmailTemplateResponse) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationEmailTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationEmailTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationEmailTemplateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationEmailTemplateResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OnboardingOption struct {
	Show     bool `json:"show" url:"show"`
	Edit     bool `json:"edit" url:"edit"`
	Required bool `json:"required" url:"required"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OnboardingOption) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingOption) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOption) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingOptionsRequest struct {
	EnableBusiness   *bool                        `json:"enableBusiness,omitempty" url:"enableBusiness,omitempty"`
	EnableIndividual *bool                        `json:"enableIndividual,omitempty" url:"enableIndividual,omitempty"`
	PaymentMethod    *bool                        `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	Business         *BusinessOnboardingOptions   `json:"business,omitempty" url:"business,omitempty"`
	Individual       *IndividualOnboardingOptions `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OnboardingOptionsRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingOptionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOptionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOptionsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOptionsRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OnboardingOptionsResponse struct {
	EnableBusiness   bool                         `json:"enableBusiness" url:"enableBusiness"`
	EnableIndividual bool                         `json:"enableIndividual" url:"enableIndividual"`
	PaymentMethod    bool                         `json:"paymentMethod" url:"paymentMethod"`
	Business         *BusinessOnboardingOptions   `json:"business,omitempty" url:"business,omitempty"`
	Individual       *IndividualOnboardingOptions `json:"individual,omitempty" url:"individual,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OnboardingOptionsResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OnboardingOptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OnboardingOptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OnboardingOptionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OnboardingOptionsResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationID = string

type OrganizationRequest struct {
	Name                             *string                                  `json:"name,omitempty" url:"name,omitempty"`
	Logo                             *string                                  `json:"logo,omitempty" url:"logo,omitempty"`
	WebsiteURL                       *string                                  `json:"websiteUrl,omitempty" url:"websiteUrl,omitempty"`
	SupportEmail                     *string                                  `json:"supportEmail,omitempty" url:"supportEmail,omitempty"`
	PaymentMethods                   *PaymentMethodsRequest                   `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	EmailProvider                    *EmailProviderRequest                    `json:"emailProvider,omitempty" url:"emailProvider,omitempty"`
	ExternalAccountingSystemProvider *ExternalAccountingSystemProviderRequest `json:"externalAccountingSystemProvider,omitempty" url:"externalAccountingSystemProvider,omitempty"`
	ColorScheme                      *ColorSchemeRequest                      `json:"colorScheme,omitempty" url:"colorScheme,omitempty"`
	PayeeOnboardingOptions           *OnboardingOptionsRequest                `json:"payeeOnboardingOptions,omitempty" url:"payeeOnboardingOptions,omitempty"`
	PayorOnboardingOptions           *OnboardingOptionsRequest                `json:"payorOnboardingOptions,omitempty" url:"payorOnboardingOptions,omitempty"`
	MetadataSchema                   []*MetadataSchema                        `json:"metadataSchema,omitempty" url:"metadataSchema,omitempty"`
	NotificationEmailTemplate        *NotificationEmailTemplateRequest        `json:"notificationEmailTemplate,omitempty" url:"notificationEmailTemplate,omitempty"`
	CustomDomains                    []string                                 `json:"customDomains,omitempty" url:"customDomains,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationResponse struct {
	ID                               OrganizationID                            `json:"id" url:"id"`
	Sandbox                          bool                                      `json:"sandbox" url:"sandbox"`
	Name                             string                                    `json:"name" url:"name"`
	LogoURL                          *string                                   `json:"logoUrl,omitempty" url:"logoUrl,omitempty"`
	WebsiteURL                       *string                                   `json:"websiteUrl,omitempty" url:"websiteUrl,omitempty"`
	SupportEmail                     *string                                   `json:"supportEmail,omitempty" url:"supportEmail,omitempty"`
	PaymentMethods                   *PaymentMethodsResponse                   `json:"paymentMethods,omitempty" url:"paymentMethods,omitempty"`
	EmailProvider                    *EmailProviderResponse                    `json:"emailProvider,omitempty" url:"emailProvider,omitempty"`
	ExternalAccountingSystemProvider *ExternalAccountingSystemProviderResponse `json:"externalAccountingSystemProvider,omitempty" url:"externalAccountingSystemProvider,omitempty"`
	ColorScheme                      *ColorSchemeResponse                      `json:"colorScheme,omitempty" url:"colorScheme,omitempty"`
	PayeeOnboardingOptions           *OnboardingOptionsResponse                `json:"payeeOnboardingOptions,omitempty" url:"payeeOnboardingOptions,omitempty"`
	PayorOnboardingOptions           *OnboardingOptionsResponse                `json:"payorOnboardingOptions,omitempty" url:"payorOnboardingOptions,omitempty"`
	MetadataSchema                   []*MetadataSchema                         `json:"metadataSchema,omitempty" url:"metadataSchema,omitempty"`
	NotificationEmailTemplate        *NotificationEmailTemplateResponse        `json:"notificationEmailTemplate,omitempty" url:"notificationEmailTemplate,omitempty"`
	CustomDomains                    []string                                  `json:"customDomains,omitempty" url:"customDomains,omitempty"`
	OrganizationEntityID             *EntityID                                 `json:"organizationEntityId,omitempty" url:"organizationEntityId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaymentMethodsRequest struct {
	// List of payment methods that can be used to pay invoices.
	PayerPayments []*PaymentRailRequest `json:"payerPayments,omitempty" url:"payerPayments,omitempty"`
	// List of payment methods that can be created by a payor to send disbursements.
	BackupDisbursements []*PaymentRailRequest `json:"backupDisbursements,omitempty" url:"backupDisbursements,omitempty"`
	// List of payment methods that can be created by a payee to receive disbursements.
	VendorDisbursements []*PaymentRailRequest `json:"vendorDisbursements,omitempty" url:"vendorDisbursements,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodsRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodsRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodsResponse struct {
	// List of payment methods that can be used to pay invoices.
	PayerPayments []*PaymentRailResponse `json:"payerPayments,omitempty" url:"payerPayments,omitempty"`
	// List of payment methods that can be created by a payor to send disbursements.
	BackupDisbursements []*PaymentRailResponse `json:"backupDisbursements,omitempty" url:"backupDisbursements,omitempty"`
	// List of payment methods that can be created by a payee to receive disbursements.
	VendorDisbursements []*PaymentRailResponse `json:"vendorDisbursements,omitempty" url:"vendorDisbursements,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodsResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodsResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRailRequest struct {
	Type PaymentMethodType `json:"type" url:"type"`
	// For custom payment methods, this is the ID of the schema.
	Name   *string `json:"name,omitempty" url:"name,omitempty"`
	Active bool    `json:"active" url:"active"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRailRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRailRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRailRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRailRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRailRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentRailResponse struct {
	Type PaymentMethodType `json:"type" url:"type"`
	// For custom payment methods, this is the ID of the schema.
	Name   string `json:"name" url:"name"`
	Active bool   `json:"active" url:"active"`
	// unused
	Available *bool `json:"available,omitempty" url:"available,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRailResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRailResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRailResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRailResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRailResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RutterProviderRequest struct {
	ClientID     string `json:"clientId" url:"clientId"`
	ClientSecret string `json:"clientSecret" url:"clientSecret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RutterProviderRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RutterProviderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterProviderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterProviderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterProviderRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RutterProviderResponse struct {
	HasClientID     bool `json:"hasClientId" url:"hasClientId"`
	HasClientSecret bool `json:"hasClientSecret" url:"hasClientSecret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RutterProviderResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RutterProviderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RutterProviderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RutterProviderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RutterProviderResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BankAccountCheckOptions struct {
	// If true, will allow the user to print checks from this bank account
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// If provided, will start the check number sequence at the provided number. If not provided, will start at 5000.
	InitialCheckNumber *int `json:"initialCheckNumber,omitempty" url:"initialCheckNumber,omitempty"`
	// If provided, will print a check with the provided routing number instead of the one from the bank account
	RoutingNumberOverride *string `json:"routingNumberOverride,omitempty" url:"routingNumberOverride,omitempty"`
	// If provided, will print a check with the provided account number instead of the one from the bank account
	AccountNumberOverride *string `json:"accountNumberOverride,omitempty" url:"accountNumberOverride,omitempty"`
	// Name of the person who's signature will be printed on the check.
	SignatoryName string `json:"signatoryName" url:"signatoryName"`
	// Base64 encoded image of the signature. If not provided, will use the signatoryName to generate a signature. Mercoa will automatically grayscale, resize, and convert the image to a PNG the image to fit on the check.
	SignatureImage *string `json:"signatureImage,omitempty" url:"signatureImage,omitempty"`
	// If true, will print checks with the provided signatureImage. If false, will print checks with a generated signature from the signatoryName. If this parameter is not set the default behavior is to use the signatureImage if provided.
	UseSignatureImage *bool `json:"useSignatureImage,omitempty" url:"useSignatureImage,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountCheckOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCheckOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCheckOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCheckOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCheckOptions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The name of the account. For example "My Checking Account" or "Property XYZ Checking"
	AccountName *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// The name of the bank. This is now automatically set when the bank account is linked.
	BankName      *string  `json:"bankName,omitempty" url:"bankName,omitempty"`
	RoutingNumber string   `json:"routingNumber" url:"routingNumber"`
	AccountNumber string   `json:"accountNumber" url:"accountNumber"`
	AccountType   BankType `json:"accountType" url:"accountType"`
	// If provided, will link a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata      map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt     time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time         `json:"updatedAt" url:"updatedAt"`
	AccountName   string            `json:"accountName" url:"accountName"`
	BankName      string            `json:"bankName" url:"bankName"`
	RoutingNumber string            `json:"routingNumber" url:"routingNumber"`
	AccountNumber string            `json:"accountNumber" url:"accountNumber"`
	AccountType   BankType          `json:"accountType" url:"accountType"`
	Status        BankStatus        `json:"status" url:"status"`
	// If check printing is enabled for the account, will return the check options for this bank account
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountResponse) UnmarshalJSON(data []byte) error {
	type embed BankAccountResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankAccountResponse(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountResponse) MarshalJSON() ([]byte, error) {
	type embed BankAccountResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BankAccountResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata    map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	AccountName *string           `json:"accountName,omitempty" url:"accountName,omitempty"`
	// If provided, will update a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountUpdateRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountUpdateRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankStatus string

const (
	BankStatusNew                BankStatus = "NEW"
	BankStatusVerified           BankStatus = "VERIFIED"
	BankStatusVerificationFailed BankStatus = "VERIFICATION_FAILED"
	BankStatusPending            BankStatus = "PENDING"
	BankStatusErrored            BankStatus = "ERRORED"
)

func NewBankStatusFromString(s string) (BankStatus, error) {
	switch s {
	case "NEW":
		return BankStatusNew, nil
	case "VERIFIED":
		return BankStatusVerified, nil
	case "VERIFICATION_FAILED":
		return BankStatusVerificationFailed, nil
	case "PENDING":
		return BankStatusPending, nil
	case "ERRORED":
		return BankStatusErrored, nil
	}
	var t BankStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankStatus) Ptr() *BankStatus {
	return &b
}

type BankType string

const (
	BankTypeChecking BankType = "CHECKING"
	BankTypeSavings  BankType = "SAVINGS"
	BankTypeUnknown  BankType = "UNKNOWN"
)

func NewBankTypeFromString(s string) (BankType, error) {
	switch s {
	case "CHECKING":
		return BankTypeChecking, nil
	case "SAVINGS":
		return BankTypeSavings, nil
	case "UNKNOWN":
		return BankTypeUnknown, nil
	}
	var t BankType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankType) Ptr() *BankType {
	return &b
}

type CardBrand string

const (
	CardBrandAmericanExpress CardBrand = "AmericanExpress"
	CardBrandDiscover        CardBrand = "Discover"
	CardBrandMastercard      CardBrand = "Mastercard"
	CardBrandVisa            CardBrand = "Visa"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "AmericanExpress":
		return CardBrandAmericanExpress, nil
	case "Discover":
		return CardBrandDiscover, nil
	case "Mastercard":
		return CardBrandMastercard, nil
	case "Visa":
		return CardBrandVisa, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

type CardRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CardType  CardType          `json:"cardType" url:"cardType"`
	CardBrand CardBrand         `json:"cardBrand" url:"cardBrand"`
	LastFour  string            `json:"lastFour" url:"lastFour"`
	ExpMonth  string            `json:"expMonth" url:"expMonth"`
	ExpYear   string            `json:"expYear" url:"expYear"`
	Token     string            `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`
	CardType  CardType          `json:"cardType" url:"cardType"`
	CardBrand CardBrand         `json:"cardBrand" url:"cardBrand"`
	LastFour  string            `json:"lastFour" url:"lastFour"`
	ExpMonth  string            `json:"expMonth" url:"expMonth"`
	ExpYear   string            `json:"expYear" url:"expYear"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardResponse) UnmarshalJSON(data []byte) error {
	type embed CardResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CardResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardResponse) MarshalJSON() ([]byte, error) {
	type embed CardResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardType string

const (
	CardTypeCredit  CardType = "credit"
	CardTypeDebit   CardType = "debit"
	CardTypePrepaid CardType = "prepaid"
	CardTypeUnknown CardType = "unknown"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "credit":
		return CardTypeCredit, nil
	case "debit":
		return CardTypeDebit, nil
	case "prepaid":
		return CardTypePrepaid, nil
	case "unknown":
		return CardTypeUnknown, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

type CheckRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata        map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	PayToTheOrderOf string            `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1    string            `json:"addressLine1" url:"addressLine1"`
	AddressLine2    *string           `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City            string            `json:"city" url:"city"`
	StateOrProvince string            `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode      string            `json:"postalCode" url:"postalCode"`
	Country         string            `json:"country" url:"country"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata        map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt       time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt       time.Time         `json:"updatedAt" url:"updatedAt"`
	PayToTheOrderOf string            `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1    string            `json:"addressLine1" url:"addressLine1"`
	AddressLine2    *string           `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City            string            `json:"city" url:"city"`
	StateOrProvince string            `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode      string            `json:"postalCode" url:"postalCode"`
	Country         string            `json:"country" url:"country"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckResponse) UnmarshalJSON(data []byte) error {
	type embed CheckResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CheckResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckResponse) MarshalJSON() ([]byte, error) {
	type embed CheckResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CheckResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CurrencyCode string

const (
	CurrencyCodeAed CurrencyCode = "AED"
	CurrencyCodeAfn CurrencyCode = "AFN"
	CurrencyCodeAll CurrencyCode = "ALL"
	CurrencyCodeAmd CurrencyCode = "AMD"
	CurrencyCodeAng CurrencyCode = "ANG"
	CurrencyCodeAoa CurrencyCode = "AOA"
	CurrencyCodeArs CurrencyCode = "ARS"
	CurrencyCodeAud CurrencyCode = "AUD"
	CurrencyCodeAwg CurrencyCode = "AWG"
	CurrencyCodeAzn CurrencyCode = "AZN"
	CurrencyCodeBam CurrencyCode = "BAM"
	CurrencyCodeBbd CurrencyCode = "BBD"
	CurrencyCodeBdt CurrencyCode = "BDT"
	CurrencyCodeBgn CurrencyCode = "BGN"
	CurrencyCodeBhd CurrencyCode = "BHD"
	CurrencyCodeBif CurrencyCode = "BIF"
	CurrencyCodeBmd CurrencyCode = "BMD"
	CurrencyCodeBnd CurrencyCode = "BND"
	CurrencyCodeBob CurrencyCode = "BOB"
	CurrencyCodeBov CurrencyCode = "BOV"
	CurrencyCodeBrl CurrencyCode = "BRL"
	CurrencyCodeBsd CurrencyCode = "BSD"
	CurrencyCodeBtn CurrencyCode = "BTN"
	CurrencyCodeBwp CurrencyCode = "BWP"
	CurrencyCodeByn CurrencyCode = "BYN"
	CurrencyCodeBzd CurrencyCode = "BZD"
	CurrencyCodeCad CurrencyCode = "CAD"
	CurrencyCodeCdf CurrencyCode = "CDF"
	CurrencyCodeChe CurrencyCode = "CHE"
	CurrencyCodeChf CurrencyCode = "CHF"
	CurrencyCodeChw CurrencyCode = "CHW"
	CurrencyCodeClf CurrencyCode = "CLF"
	CurrencyCodeClp CurrencyCode = "CLP"
	CurrencyCodeCop CurrencyCode = "COP"
	CurrencyCodeCou CurrencyCode = "COU"
	CurrencyCodeCrc CurrencyCode = "CRC"
	CurrencyCodeCuc CurrencyCode = "CUC"
	CurrencyCodeCup CurrencyCode = "CUP"
	CurrencyCodeCve CurrencyCode = "CVE"
	CurrencyCodeCzk CurrencyCode = "CZK"
	CurrencyCodeDjf CurrencyCode = "DJF"
	CurrencyCodeDkk CurrencyCode = "DKK"
	CurrencyCodeDop CurrencyCode = "DOP"
	CurrencyCodeDzd CurrencyCode = "DZD"
	CurrencyCodeEgp CurrencyCode = "EGP"
	CurrencyCodeErn CurrencyCode = "ERN"
	CurrencyCodeEtb CurrencyCode = "ETB"
	CurrencyCodeEur CurrencyCode = "EUR"
	CurrencyCodeFjd CurrencyCode = "FJD"
	CurrencyCodeFkp CurrencyCode = "FKP"
	CurrencyCodeGbp CurrencyCode = "GBP"
	CurrencyCodeGel CurrencyCode = "GEL"
	CurrencyCodeGhs CurrencyCode = "GHS"
	CurrencyCodeGip CurrencyCode = "GIP"
	CurrencyCodeGmd CurrencyCode = "GMD"
	CurrencyCodeGnf CurrencyCode = "GNF"
	CurrencyCodeGtq CurrencyCode = "GTQ"
	CurrencyCodeGyd CurrencyCode = "GYD"
	CurrencyCodeHkd CurrencyCode = "HKD"
	CurrencyCodeHnl CurrencyCode = "HNL"
	CurrencyCodeHtg CurrencyCode = "HTG"
	CurrencyCodeHuf CurrencyCode = "HUF"
	CurrencyCodeIdr CurrencyCode = "IDR"
	CurrencyCodeIls CurrencyCode = "ILS"
	CurrencyCodeInr CurrencyCode = "INR"
	CurrencyCodeIqd CurrencyCode = "IQD"
	CurrencyCodeIrr CurrencyCode = "IRR"
	CurrencyCodeIsk CurrencyCode = "ISK"
	CurrencyCodeJmd CurrencyCode = "JMD"
	CurrencyCodeJod CurrencyCode = "JOD"
	CurrencyCodeJpy CurrencyCode = "JPY"
	CurrencyCodeKes CurrencyCode = "KES"
	CurrencyCodeKgs CurrencyCode = "KGS"
	CurrencyCodeKhr CurrencyCode = "KHR"
	CurrencyCodeKmf CurrencyCode = "KMF"
	CurrencyCodeKpw CurrencyCode = "KPW"
	CurrencyCodeKrw CurrencyCode = "KRW"
	CurrencyCodeKwd CurrencyCode = "KWD"
	CurrencyCodeKyd CurrencyCode = "KYD"
	CurrencyCodeKzt CurrencyCode = "KZT"
	CurrencyCodeLak CurrencyCode = "LAK"
	CurrencyCodeLbp CurrencyCode = "LBP"
	CurrencyCodeLkr CurrencyCode = "LKR"
	CurrencyCodeLrd CurrencyCode = "LRD"
	CurrencyCodeLsl CurrencyCode = "LSL"
	CurrencyCodeLyd CurrencyCode = "LYD"
	CurrencyCodeMad CurrencyCode = "MAD"
	CurrencyCodeMdl CurrencyCode = "MDL"
	CurrencyCodeMga CurrencyCode = "MGA"
	CurrencyCodeMkd CurrencyCode = "MKD"
	CurrencyCodeMmk CurrencyCode = "MMK"
	CurrencyCodeMnt CurrencyCode = "MNT"
	CurrencyCodeMop CurrencyCode = "MOP"
	CurrencyCodeMru CurrencyCode = "MRU"
	CurrencyCodeMur CurrencyCode = "MUR"
	CurrencyCodeMvr CurrencyCode = "MVR"
	CurrencyCodeMwk CurrencyCode = "MWK"
	CurrencyCodeMxn CurrencyCode = "MXN"
	CurrencyCodeMxv CurrencyCode = "MXV"
	CurrencyCodeMyr CurrencyCode = "MYR"
	CurrencyCodeMzn CurrencyCode = "MZN"
	CurrencyCodeNad CurrencyCode = "NAD"
	CurrencyCodeNgn CurrencyCode = "NGN"
	CurrencyCodeNio CurrencyCode = "NIO"
	CurrencyCodeNok CurrencyCode = "NOK"
	CurrencyCodeNpr CurrencyCode = "NPR"
	CurrencyCodeNzd CurrencyCode = "NZD"
	CurrencyCodeOmr CurrencyCode = "OMR"
	CurrencyCodePab CurrencyCode = "PAB"
	CurrencyCodePen CurrencyCode = "PEN"
	CurrencyCodePgk CurrencyCode = "PGK"
	CurrencyCodePhp CurrencyCode = "PHP"
	CurrencyCodePkr CurrencyCode = "PKR"
	CurrencyCodePln CurrencyCode = "PLN"
	CurrencyCodePyg CurrencyCode = "PYG"
	CurrencyCodeQar CurrencyCode = "QAR"
	CurrencyCodeRon CurrencyCode = "RON"
	CurrencyCodeRsd CurrencyCode = "RSD"
	CurrencyCodeCny CurrencyCode = "CNY"
	CurrencyCodeRub CurrencyCode = "RUB"
	CurrencyCodeRwf CurrencyCode = "RWF"
	CurrencyCodeSar CurrencyCode = "SAR"
	CurrencyCodeSbd CurrencyCode = "SBD"
	CurrencyCodeScr CurrencyCode = "SCR"
	CurrencyCodeSdg CurrencyCode = "SDG"
	CurrencyCodeSek CurrencyCode = "SEK"
	CurrencyCodeSgd CurrencyCode = "SGD"
	CurrencyCodeShp CurrencyCode = "SHP"
	CurrencyCodeSle CurrencyCode = "SLE"
	CurrencyCodeSll CurrencyCode = "SLL"
	CurrencyCodeSos CurrencyCode = "SOS"
	CurrencyCodeSrd CurrencyCode = "SRD"
	CurrencyCodeSsp CurrencyCode = "SSP"
	CurrencyCodeStn CurrencyCode = "STN"
	CurrencyCodeSvc CurrencyCode = "SVC"
	CurrencyCodeSyp CurrencyCode = "SYP"
	CurrencyCodeSzl CurrencyCode = "SZL"
	CurrencyCodeThb CurrencyCode = "THB"
	CurrencyCodeTjs CurrencyCode = "TJS"
	CurrencyCodeTmt CurrencyCode = "TMT"
	CurrencyCodeTnd CurrencyCode = "TND"
	CurrencyCodeTop CurrencyCode = "TOP"
	CurrencyCodeTry CurrencyCode = "TRY"
	CurrencyCodeTtd CurrencyCode = "TTD"
	CurrencyCodeTwd CurrencyCode = "TWD"
	CurrencyCodeTzs CurrencyCode = "TZS"
	CurrencyCodeUah CurrencyCode = "UAH"
	CurrencyCodeUgx CurrencyCode = "UGX"
	CurrencyCodeUsd CurrencyCode = "USD"
	CurrencyCodeUsn CurrencyCode = "USN"
	CurrencyCodeUyi CurrencyCode = "UYI"
	CurrencyCodeUyu CurrencyCode = "UYU"
	CurrencyCodeUyw CurrencyCode = "UYW"
	CurrencyCodeUzs CurrencyCode = "UZS"
	CurrencyCodeVed CurrencyCode = "VED"
	CurrencyCodeVes CurrencyCode = "VES"
	CurrencyCodeVnd CurrencyCode = "VND"
	CurrencyCodeVuv CurrencyCode = "VUV"
	CurrencyCodeWst CurrencyCode = "WST"
	CurrencyCodeXaf CurrencyCode = "XAF"
	CurrencyCodeXag CurrencyCode = "XAG"
	CurrencyCodeXau CurrencyCode = "XAU"
	CurrencyCodeXba CurrencyCode = "XBA"
	CurrencyCodeXbb CurrencyCode = "XBB"
	CurrencyCodeXbc CurrencyCode = "XBC"
	CurrencyCodeXbd CurrencyCode = "XBD"
	CurrencyCodeXcd CurrencyCode = "XCD"
	CurrencyCodeXdr CurrencyCode = "XDR"
	CurrencyCodeXof CurrencyCode = "XOF"
	CurrencyCodeXpd CurrencyCode = "XPD"
	CurrencyCodeXpf CurrencyCode = "XPF"
	CurrencyCodeXpt CurrencyCode = "XPT"
	CurrencyCodeXsu CurrencyCode = "XSU"
	CurrencyCodeXts CurrencyCode = "XTS"
	CurrencyCodeXua CurrencyCode = "XUA"
	CurrencyCodeXxx CurrencyCode = "XXX"
	CurrencyCodeYer CurrencyCode = "YER"
	CurrencyCodeZar CurrencyCode = "ZAR"
	CurrencyCodeZmw CurrencyCode = "ZMW"
	CurrencyCodeZwl CurrencyCode = "ZWL"
)

func NewCurrencyCodeFromString(s string) (CurrencyCode, error) {
	switch s {
	case "AED":
		return CurrencyCodeAed, nil
	case "AFN":
		return CurrencyCodeAfn, nil
	case "ALL":
		return CurrencyCodeAll, nil
	case "AMD":
		return CurrencyCodeAmd, nil
	case "ANG":
		return CurrencyCodeAng, nil
	case "AOA":
		return CurrencyCodeAoa, nil
	case "ARS":
		return CurrencyCodeArs, nil
	case "AUD":
		return CurrencyCodeAud, nil
	case "AWG":
		return CurrencyCodeAwg, nil
	case "AZN":
		return CurrencyCodeAzn, nil
	case "BAM":
		return CurrencyCodeBam, nil
	case "BBD":
		return CurrencyCodeBbd, nil
	case "BDT":
		return CurrencyCodeBdt, nil
	case "BGN":
		return CurrencyCodeBgn, nil
	case "BHD":
		return CurrencyCodeBhd, nil
	case "BIF":
		return CurrencyCodeBif, nil
	case "BMD":
		return CurrencyCodeBmd, nil
	case "BND":
		return CurrencyCodeBnd, nil
	case "BOB":
		return CurrencyCodeBob, nil
	case "BOV":
		return CurrencyCodeBov, nil
	case "BRL":
		return CurrencyCodeBrl, nil
	case "BSD":
		return CurrencyCodeBsd, nil
	case "BTN":
		return CurrencyCodeBtn, nil
	case "BWP":
		return CurrencyCodeBwp, nil
	case "BYN":
		return CurrencyCodeByn, nil
	case "BZD":
		return CurrencyCodeBzd, nil
	case "CAD":
		return CurrencyCodeCad, nil
	case "CDF":
		return CurrencyCodeCdf, nil
	case "CHE":
		return CurrencyCodeChe, nil
	case "CHF":
		return CurrencyCodeChf, nil
	case "CHW":
		return CurrencyCodeChw, nil
	case "CLF":
		return CurrencyCodeClf, nil
	case "CLP":
		return CurrencyCodeClp, nil
	case "COP":
		return CurrencyCodeCop, nil
	case "COU":
		return CurrencyCodeCou, nil
	case "CRC":
		return CurrencyCodeCrc, nil
	case "CUC":
		return CurrencyCodeCuc, nil
	case "CUP":
		return CurrencyCodeCup, nil
	case "CVE":
		return CurrencyCodeCve, nil
	case "CZK":
		return CurrencyCodeCzk, nil
	case "DJF":
		return CurrencyCodeDjf, nil
	case "DKK":
		return CurrencyCodeDkk, nil
	case "DOP":
		return CurrencyCodeDop, nil
	case "DZD":
		return CurrencyCodeDzd, nil
	case "EGP":
		return CurrencyCodeEgp, nil
	case "ERN":
		return CurrencyCodeErn, nil
	case "ETB":
		return CurrencyCodeEtb, nil
	case "EUR":
		return CurrencyCodeEur, nil
	case "FJD":
		return CurrencyCodeFjd, nil
	case "FKP":
		return CurrencyCodeFkp, nil
	case "GBP":
		return CurrencyCodeGbp, nil
	case "GEL":
		return CurrencyCodeGel, nil
	case "GHS":
		return CurrencyCodeGhs, nil
	case "GIP":
		return CurrencyCodeGip, nil
	case "GMD":
		return CurrencyCodeGmd, nil
	case "GNF":
		return CurrencyCodeGnf, nil
	case "GTQ":
		return CurrencyCodeGtq, nil
	case "GYD":
		return CurrencyCodeGyd, nil
	case "HKD":
		return CurrencyCodeHkd, nil
	case "HNL":
		return CurrencyCodeHnl, nil
	case "HTG":
		return CurrencyCodeHtg, nil
	case "HUF":
		return CurrencyCodeHuf, nil
	case "IDR":
		return CurrencyCodeIdr, nil
	case "ILS":
		return CurrencyCodeIls, nil
	case "INR":
		return CurrencyCodeInr, nil
	case "IQD":
		return CurrencyCodeIqd, nil
	case "IRR":
		return CurrencyCodeIrr, nil
	case "ISK":
		return CurrencyCodeIsk, nil
	case "JMD":
		return CurrencyCodeJmd, nil
	case "JOD":
		return CurrencyCodeJod, nil
	case "JPY":
		return CurrencyCodeJpy, nil
	case "KES":
		return CurrencyCodeKes, nil
	case "KGS":
		return CurrencyCodeKgs, nil
	case "KHR":
		return CurrencyCodeKhr, nil
	case "KMF":
		return CurrencyCodeKmf, nil
	case "KPW":
		return CurrencyCodeKpw, nil
	case "KRW":
		return CurrencyCodeKrw, nil
	case "KWD":
		return CurrencyCodeKwd, nil
	case "KYD":
		return CurrencyCodeKyd, nil
	case "KZT":
		return CurrencyCodeKzt, nil
	case "LAK":
		return CurrencyCodeLak, nil
	case "LBP":
		return CurrencyCodeLbp, nil
	case "LKR":
		return CurrencyCodeLkr, nil
	case "LRD":
		return CurrencyCodeLrd, nil
	case "LSL":
		return CurrencyCodeLsl, nil
	case "LYD":
		return CurrencyCodeLyd, nil
	case "MAD":
		return CurrencyCodeMad, nil
	case "MDL":
		return CurrencyCodeMdl, nil
	case "MGA":
		return CurrencyCodeMga, nil
	case "MKD":
		return CurrencyCodeMkd, nil
	case "MMK":
		return CurrencyCodeMmk, nil
	case "MNT":
		return CurrencyCodeMnt, nil
	case "MOP":
		return CurrencyCodeMop, nil
	case "MRU":
		return CurrencyCodeMru, nil
	case "MUR":
		return CurrencyCodeMur, nil
	case "MVR":
		return CurrencyCodeMvr, nil
	case "MWK":
		return CurrencyCodeMwk, nil
	case "MXN":
		return CurrencyCodeMxn, nil
	case "MXV":
		return CurrencyCodeMxv, nil
	case "MYR":
		return CurrencyCodeMyr, nil
	case "MZN":
		return CurrencyCodeMzn, nil
	case "NAD":
		return CurrencyCodeNad, nil
	case "NGN":
		return CurrencyCodeNgn, nil
	case "NIO":
		return CurrencyCodeNio, nil
	case "NOK":
		return CurrencyCodeNok, nil
	case "NPR":
		return CurrencyCodeNpr, nil
	case "NZD":
		return CurrencyCodeNzd, nil
	case "OMR":
		return CurrencyCodeOmr, nil
	case "PAB":
		return CurrencyCodePab, nil
	case "PEN":
		return CurrencyCodePen, nil
	case "PGK":
		return CurrencyCodePgk, nil
	case "PHP":
		return CurrencyCodePhp, nil
	case "PKR":
		return CurrencyCodePkr, nil
	case "PLN":
		return CurrencyCodePln, nil
	case "PYG":
		return CurrencyCodePyg, nil
	case "QAR":
		return CurrencyCodeQar, nil
	case "RON":
		return CurrencyCodeRon, nil
	case "RSD":
		return CurrencyCodeRsd, nil
	case "CNY":
		return CurrencyCodeCny, nil
	case "RUB":
		return CurrencyCodeRub, nil
	case "RWF":
		return CurrencyCodeRwf, nil
	case "SAR":
		return CurrencyCodeSar, nil
	case "SBD":
		return CurrencyCodeSbd, nil
	case "SCR":
		return CurrencyCodeScr, nil
	case "SDG":
		return CurrencyCodeSdg, nil
	case "SEK":
		return CurrencyCodeSek, nil
	case "SGD":
		return CurrencyCodeSgd, nil
	case "SHP":
		return CurrencyCodeShp, nil
	case "SLE":
		return CurrencyCodeSle, nil
	case "SLL":
		return CurrencyCodeSll, nil
	case "SOS":
		return CurrencyCodeSos, nil
	case "SRD":
		return CurrencyCodeSrd, nil
	case "SSP":
		return CurrencyCodeSsp, nil
	case "STN":
		return CurrencyCodeStn, nil
	case "SVC":
		return CurrencyCodeSvc, nil
	case "SYP":
		return CurrencyCodeSyp, nil
	case "SZL":
		return CurrencyCodeSzl, nil
	case "THB":
		return CurrencyCodeThb, nil
	case "TJS":
		return CurrencyCodeTjs, nil
	case "TMT":
		return CurrencyCodeTmt, nil
	case "TND":
		return CurrencyCodeTnd, nil
	case "TOP":
		return CurrencyCodeTop, nil
	case "TRY":
		return CurrencyCodeTry, nil
	case "TTD":
		return CurrencyCodeTtd, nil
	case "TWD":
		return CurrencyCodeTwd, nil
	case "TZS":
		return CurrencyCodeTzs, nil
	case "UAH":
		return CurrencyCodeUah, nil
	case "UGX":
		return CurrencyCodeUgx, nil
	case "USD":
		return CurrencyCodeUsd, nil
	case "USN":
		return CurrencyCodeUsn, nil
	case "UYI":
		return CurrencyCodeUyi, nil
	case "UYU":
		return CurrencyCodeUyu, nil
	case "UYW":
		return CurrencyCodeUyw, nil
	case "UZS":
		return CurrencyCodeUzs, nil
	case "VED":
		return CurrencyCodeVed, nil
	case "VES":
		return CurrencyCodeVes, nil
	case "VND":
		return CurrencyCodeVnd, nil
	case "VUV":
		return CurrencyCodeVuv, nil
	case "WST":
		return CurrencyCodeWst, nil
	case "XAF":
		return CurrencyCodeXaf, nil
	case "XAG":
		return CurrencyCodeXag, nil
	case "XAU":
		return CurrencyCodeXau, nil
	case "XBA":
		return CurrencyCodeXba, nil
	case "XBB":
		return CurrencyCodeXbb, nil
	case "XBC":
		return CurrencyCodeXbc, nil
	case "XBD":
		return CurrencyCodeXbd, nil
	case "XCD":
		return CurrencyCodeXcd, nil
	case "XDR":
		return CurrencyCodeXdr, nil
	case "XOF":
		return CurrencyCodeXof, nil
	case "XPD":
		return CurrencyCodeXpd, nil
	case "XPF":
		return CurrencyCodeXpf, nil
	case "XPT":
		return CurrencyCodeXpt, nil
	case "XSU":
		return CurrencyCodeXsu, nil
	case "XTS":
		return CurrencyCodeXts, nil
	case "XUA":
		return CurrencyCodeXua, nil
	case "XXX":
		return CurrencyCodeXxx, nil
	case "YER":
		return CurrencyCodeYer, nil
	case "ZAR":
		return CurrencyCodeZar, nil
	case "ZMW":
		return CurrencyCodeZmw, nil
	case "ZWL":
		return CurrencyCodeZwl, nil
	}
	var t CurrencyCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CurrencyCode) Ptr() *CurrencyCode {
	return &c
}

type CustomPaymentMethodFeeType string

const (
	CustomPaymentMethodFeeTypeNone       CustomPaymentMethodFeeType = "none"
	CustomPaymentMethodFeeTypeFlat       CustomPaymentMethodFeeType = "flat"
	CustomPaymentMethodFeeTypePercentage CustomPaymentMethodFeeType = "percentage"
)

func NewCustomPaymentMethodFeeTypeFromString(s string) (CustomPaymentMethodFeeType, error) {
	switch s {
	case "none":
		return CustomPaymentMethodFeeTypeNone, nil
	case "flat":
		return CustomPaymentMethodFeeTypeFlat, nil
	case "percentage":
		return CustomPaymentMethodFeeTypePercentage, nil
	}
	var t CustomPaymentMethodFeeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomPaymentMethodFeeType) Ptr() *CustomPaymentMethodFeeType {
	return &c
}

type CustomPaymentMethodRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID `json:"schemaId" url:"schemaId"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID        `json:"schemaId" url:"schemaId"`
	Schema   *CustomPaymentMethodSchemaResponse `json:"schema,omitempty" url:"schema,omitempty"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaFee struct {
	Type CustomPaymentMethodFeeType `json:"type" url:"type"`
	// If type is 'flat', this is the flat amount that will be charged as a fee. For example, if the fee is $2.50, set this to 2.50. If type is 'percentage', this is the percentage of the payment amount that will be charged as a fee. For example, if the fee is 2.5%, set this to 2.5.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodSchemaFee) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaFee) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaFee) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaField struct {
	Name        string                             `json:"name" url:"name"`
	DisplayName *string                            `json:"displayName,omitempty" url:"displayName,omitempty"`
	Type        CustomPaymentMethodSchemaFieldType `json:"type" url:"type"`
	// Indicates whether this field is optional
	Optional bool `json:"optional" url:"optional"`
	// Indicates whether this field should be used as the name of the payment method. Only one field can be used as the name. Will set the accountName field of the payment method to the value of this field.
	UseAsAccountName *bool `json:"useAsAccountName,omitempty" url:"useAsAccountName,omitempty"`
	// Indicates whether this field should be used as the account number of the payment method. Only one field can be used as the account number. Will set the accountNumber field of the payment method to the value of this field.
	UseAsAccountNumber *bool `json:"useAsAccountNumber,omitempty" url:"useAsAccountNumber,omitempty"`
	// When type is 'select', provide options that can be selected
	Options []string `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodSchemaField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaField) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaFieldType string

const (
	CustomPaymentMethodSchemaFieldTypeText                CustomPaymentMethodSchemaFieldType = "text"
	CustomPaymentMethodSchemaFieldTypeNumber              CustomPaymentMethodSchemaFieldType = "number"
	CustomPaymentMethodSchemaFieldTypeSelect              CustomPaymentMethodSchemaFieldType = "select"
	CustomPaymentMethodSchemaFieldTypeDate                CustomPaymentMethodSchemaFieldType = "date"
	CustomPaymentMethodSchemaFieldTypePhone               CustomPaymentMethodSchemaFieldType = "phone"
	CustomPaymentMethodSchemaFieldTypeEmail               CustomPaymentMethodSchemaFieldType = "email"
	CustomPaymentMethodSchemaFieldTypeURL                 CustomPaymentMethodSchemaFieldType = "url"
	CustomPaymentMethodSchemaFieldTypeAddress             CustomPaymentMethodSchemaFieldType = "address"
	CustomPaymentMethodSchemaFieldTypeUsBankRoutingNumber CustomPaymentMethodSchemaFieldType = "usBankRoutingNumber"
	CustomPaymentMethodSchemaFieldTypeUsBankAccountNumber CustomPaymentMethodSchemaFieldType = "usBankAccountNumber"
)

func NewCustomPaymentMethodSchemaFieldTypeFromString(s string) (CustomPaymentMethodSchemaFieldType, error) {
	switch s {
	case "text":
		return CustomPaymentMethodSchemaFieldTypeText, nil
	case "number":
		return CustomPaymentMethodSchemaFieldTypeNumber, nil
	case "select":
		return CustomPaymentMethodSchemaFieldTypeSelect, nil
	case "date":
		return CustomPaymentMethodSchemaFieldTypeDate, nil
	case "phone":
		return CustomPaymentMethodSchemaFieldTypePhone, nil
	case "email":
		return CustomPaymentMethodSchemaFieldTypeEmail, nil
	case "url":
		return CustomPaymentMethodSchemaFieldTypeURL, nil
	case "address":
		return CustomPaymentMethodSchemaFieldTypeAddress, nil
	case "usBankRoutingNumber":
		return CustomPaymentMethodSchemaFieldTypeUsBankRoutingNumber, nil
	case "usBankAccountNumber":
		return CustomPaymentMethodSchemaFieldTypeUsBankAccountNumber, nil
	}
	var t CustomPaymentMethodSchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomPaymentMethodSchemaFieldType) Ptr() *CustomPaymentMethodSchemaFieldType {
	return &c
}

type CustomPaymentMethodSchemaID = string

type CustomPaymentMethodSchemaRequest struct {
	Name string `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports. If not provided, the payment method will support only USD.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields,omitempty" url:"fields,omitempty"`
	// Estimated time in days for this payment method to process a payments. Set as 0 for same-day payment methods, -1 for unknown processing time.
	EstimatedProcessingTime *int `json:"estimatedProcessingTime,omitempty" url:"estimatedProcessingTime,omitempty"`
	// The maximum amount that can be transferred from this payment method in a single transaction.
	MaxAmount *float64 `json:"maxAmount,omitempty" url:"maxAmount,omitempty"`
	// The minimum amount that can be transferred from this payment method in a single transaction. Default is 1.
	MinAmount *float64                      `json:"minAmount,omitempty" url:"minAmount,omitempty"`
	Fees      *CustomPaymentMethodSchemaFee `json:"fees,omitempty" url:"fees,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodSchemaRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaResponse struct {
	ID   CustomPaymentMethodSchemaID `json:"id" url:"id"`
	Name string                      `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields,omitempty" url:"fields,omitempty"`
	// Estimated time in days for this payment method to process a payments. 0 is an same-day payment methods, -1 is unknown processing time.
	EstimatedProcessingTime int `json:"estimatedProcessingTime" url:"estimatedProcessingTime"`
	// The maximum amount that can be transferred from this payment method in a single transaction.
	MaxAmount *float64 `json:"maxAmount,omitempty" url:"maxAmount,omitempty"`
	// The minimum amount that can be transferred from this payment method in a single transaction. Default is 1.
	MinAmount *float64                      `json:"minAmount,omitempty" url:"minAmount,omitempty"`
	Fees      *CustomPaymentMethodSchemaFee `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt time.Time                     `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time                     `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodSchemaResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodSchemaResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodSchemaResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodSchemaResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID *CustomPaymentMethodSchemaID `json:"schemaId,omitempty" url:"schemaId,omitempty"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomPaymentMethodUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodUpdateRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodUpdateRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type PaymentMethodBaseRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodBaseRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodBaseRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodBaseResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodBaseResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodBaseResponse) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodBaseResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodBaseResponse(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseResponse) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodBaseResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*p),
		CreatedAt: core.NewDateTime(p.CreatedAt),
		UpdatedAt: core.NewDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodBaseResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodID = string

type PaymentMethodRequest struct {
	Type        string
	BankAccount *BankAccountRequest
	Card        *CardRequest
	Check       *CheckRequest
	Custom      *CustomPaymentMethodRequest
	OffPlatform *PaymentMethodBaseRequest
	Utility     *UtilityPaymentMethodRequest
}

func (p *PaymentMethodRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(UtilityPaymentMethodRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	}
	return nil
}

func (p PaymentMethodRequest) MarshalJSON() ([]byte, error) {
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return core.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodRequestVisitor interface {
	VisitBankAccount(*BankAccountRequest) error
	VisitCard(*CardRequest) error
	VisitCheck(*CheckRequest) error
	VisitCustom(*CustomPaymentMethodRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
	VisitUtility(*UtilityPaymentMethodRequest) error
}

func (p *PaymentMethodRequest) Accept(visitor PaymentMethodRequestVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodResponse struct {
	Type        string
	BankAccount *BankAccountResponse
	Card        *CardResponse
	Check       *CheckResponse
	Custom      *CustomPaymentMethodResponse
	OffPlatform *PaymentMethodBaseResponse
	Utility     *UtilityPaymentMethodResponse
}

func (p *PaymentMethodResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(UtilityPaymentMethodResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	}
	return nil
}

func (p PaymentMethodResponse) MarshalJSON() ([]byte, error) {
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return core.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodResponseVisitor interface {
	VisitBankAccount(*BankAccountResponse) error
	VisitCard(*CardResponse) error
	VisitCheck(*CheckResponse) error
	VisitCustom(*CustomPaymentMethodResponse) error
	VisitOffPlatform(*PaymentMethodBaseResponse) error
	VisitUtility(*UtilityPaymentMethodResponse) error
}

func (p *PaymentMethodResponse) Accept(visitor PaymentMethodResponseVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodType string

const (
	PaymentMethodTypeCustom      PaymentMethodType = "custom"
	PaymentMethodTypeCheck       PaymentMethodType = "check"
	PaymentMethodTypeBankAccount PaymentMethodType = "bankAccount"
	PaymentMethodTypeNa          PaymentMethodType = "na"
	PaymentMethodTypeCard        PaymentMethodType = "card"
	PaymentMethodTypeBnpl        PaymentMethodType = "bnpl"
	PaymentMethodTypeVirtualCard PaymentMethodType = "virtualCard"
	PaymentMethodTypeOffPlatform PaymentMethodType = "offPlatform"
	PaymentMethodTypeUtility     PaymentMethodType = "utility"
)

func NewPaymentMethodTypeFromString(s string) (PaymentMethodType, error) {
	switch s {
	case "custom":
		return PaymentMethodTypeCustom, nil
	case "check":
		return PaymentMethodTypeCheck, nil
	case "bankAccount":
		return PaymentMethodTypeBankAccount, nil
	case "na":
		return PaymentMethodTypeNa, nil
	case "card":
		return PaymentMethodTypeCard, nil
	case "bnpl":
		return PaymentMethodTypeBnpl, nil
	case "virtualCard":
		return PaymentMethodTypeVirtualCard, nil
	case "offPlatform":
		return PaymentMethodTypeOffPlatform, nil
	case "utility":
		return PaymentMethodTypeUtility, nil
	}
	var t PaymentMethodType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMethodType) Ptr() *PaymentMethodType {
	return &p
}

// Update a payment method. for non custom payment methods.
type PaymentMethodUpdateRequest struct {
	Type   string
	Custom *CustomPaymentMethodUpdateRequest
	// Only defaultSource, defaultDestination, accountName, and checkOptions can be updated.
	BankAccount *BankAccountUpdateRequest
	// Only defaultSource and defaultDestination can be updated.
	Card *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Check *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	OffPlatform *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Utility *PaymentMethodBaseRequest
}

func (p *PaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "custom":
		value := new(CustomPaymentMethodUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "bankAccount":
		value := new(BankAccountUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	}
	return nil
}

func (p PaymentMethodUpdateRequest) MarshalJSON() ([]byte, error) {
	if p.Custom != nil {
		return core.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.BankAccount != nil {
		return core.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return core.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return core.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.OffPlatform != nil {
		return core.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return core.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodUpdateRequestVisitor interface {
	VisitCustom(*CustomPaymentMethodUpdateRequest) error
	VisitBankAccount(*BankAccountUpdateRequest) error
	VisitCard(*PaymentMethodBaseRequest) error
	VisitCheck(*PaymentMethodBaseRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
	VisitUtility(*PaymentMethodBaseRequest) error
}

func (p *PaymentMethodUpdateRequest) Accept(visitor PaymentMethodUpdateRequestVisitor) error {
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodWithEntityResponse struct {
	PaymentMethod *PaymentMethodResponse `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	Entity        *EntityResponse        `json:"entity,omitempty" url:"entity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodWithEntityResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodWithEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodWithEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodWithEntityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodWithEntityResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidAccessTokenRequest struct {
	// Plaid account ID
	AccountID string `json:"accountId" url:"accountId"`
	// Plaid access token for the account. If you already have an access token for the account (for example, you have linked the account to your app already), use this instead of publicToken.
	AccessToken string `json:"accessToken" url:"accessToken"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PlaidAccessTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidAccessTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidAccessTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidAccessTokenRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidAccessTokenRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidLinkRequest struct {
	PlaidProcessorTokenRequest *PlaidProcessorTokenRequest
	PlaidPublicTokenRequest    *PlaidPublicTokenRequest
	PlaidAccessTokenRequest    *PlaidAccessTokenRequest
}

func (p *PlaidLinkRequest) UnmarshalJSON(data []byte) error {
	valuePlaidProcessorTokenRequest := new(PlaidProcessorTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidProcessorTokenRequest); err == nil {
		p.PlaidProcessorTokenRequest = valuePlaidProcessorTokenRequest
		return nil
	}
	valuePlaidPublicTokenRequest := new(PlaidPublicTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidPublicTokenRequest); err == nil {
		p.PlaidPublicTokenRequest = valuePlaidPublicTokenRequest
		return nil
	}
	valuePlaidAccessTokenRequest := new(PlaidAccessTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidAccessTokenRequest); err == nil {
		p.PlaidAccessTokenRequest = valuePlaidAccessTokenRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PlaidLinkRequest) MarshalJSON() ([]byte, error) {
	if p.PlaidProcessorTokenRequest != nil {
		return json.Marshal(p.PlaidProcessorTokenRequest)
	}
	if p.PlaidPublicTokenRequest != nil {
		return json.Marshal(p.PlaidPublicTokenRequest)
	}
	if p.PlaidAccessTokenRequest != nil {
		return json.Marshal(p.PlaidAccessTokenRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlaidLinkRequestVisitor interface {
	VisitPlaidProcessorTokenRequest(*PlaidProcessorTokenRequest) error
	VisitPlaidPublicTokenRequest(*PlaidPublicTokenRequest) error
	VisitPlaidAccessTokenRequest(*PlaidAccessTokenRequest) error
}

func (p *PlaidLinkRequest) Accept(visitor PlaidLinkRequestVisitor) error {
	if p.PlaidProcessorTokenRequest != nil {
		return visitor.VisitPlaidProcessorTokenRequest(p.PlaidProcessorTokenRequest)
	}
	if p.PlaidPublicTokenRequest != nil {
		return visitor.VisitPlaidPublicTokenRequest(p.PlaidPublicTokenRequest)
	}
	if p.PlaidAccessTokenRequest != nil {
		return visitor.VisitPlaidAccessTokenRequest(p.PlaidAccessTokenRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlaidProcessorTokenRequest struct {
	// Plaid processor token for the account. If you already have a processor token for the account (for example, you have linked the account to your app already), use this instead of publicToken.
	ProcessorToken string `json:"processorToken" url:"processorToken"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PlaidProcessorTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidProcessorTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidProcessorTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidProcessorTokenRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidProcessorTokenRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidPublicTokenRequest struct {
	// Plaid account ID
	AccountID string `json:"accountId" url:"accountId"`
	// Public token received from Plaid Link. Use this if linking the account using the Plaid Link frontend component.
	PublicToken string `json:"publicToken" url:"publicToken"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PlaidPublicTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidPublicTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidPublicTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidPublicTokenRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidPublicTokenRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UtilityPaymentMethodRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the utility that this payment method is linked to.
	UtilityID string `json:"utilityId" url:"utilityId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UtilityPaymentMethodRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilityPaymentMethodRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilityPaymentMethodRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentMethodRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UtilityPaymentMethodResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata  map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	CreatedAt time.Time         `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time         `json:"updatedAt" url:"updatedAt"`
	// The ID of the utility that this payment method is linked to.
	UtilityID string `json:"utilityId" url:"utilityId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UtilityPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed UtilityPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UtilityPaymentMethodResponse(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed UtilityPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*u),
		CreatedAt: core.NewDateTime(u.CreatedAt),
		UpdatedAt: core.NewDateTime(u.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (u *UtilityPaymentMethodResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type FindVendorCreditResponse struct {
	// Total number of vendor credits for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more vendor credits available for the given filters.
	HasMore bool                    `json:"hasMore" url:"hasMore"`
	Data    []*VendorCreditResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FindVendorCreditResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindVendorCreditResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindVendorCreditResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindVendorCreditResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindVendorCreditResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type VendorCreditID = string

type VendorCreditRequest struct {
	// Total amount of the vendor credit in major units
	TotalAmount float64 `json:"totalAmount" url:"totalAmount"`
	// Currency code for the amount. Defaults to USD.
	Currency CurrencyCode `json:"currency" url:"currency"`
	// An optional note to attach to the vendor credit
	Note *string `json:"note,omitempty" url:"note,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorCreditRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreditRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreditRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreditResponse struct {
	ID VendorCreditID `json:"id" url:"id"`
	// Total issued amount of the vendor credit in major units
	TotalAmount *float64 `json:"totalAmount,omitempty" url:"totalAmount,omitempty"`
	// Remaining usable amount in the vendor credit in major units
	RemainingAmount *float64 `json:"remainingAmount,omitempty" url:"remainingAmount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// ID of the vendor the vendor credit may be used for
	VendorID EntityID `json:"vendorId" url:"vendorId"`
	// ID of the payer who may use the vendor credit
	PayerID EntityID `json:"payerId" url:"payerId"`
	// ID of the entity that created this vendor credit
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// An optional note to attach to the vendor credit
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The IDs of the invoices that this vendor credit has been applied to
	InvoiceIDs []InvoiceID `json:"invoiceIds,omitempty" url:"invoiceIds,omitempty"`
	CreatedAt  time.Time   `json:"createdAt" url:"createdAt"`
	UpdatedAt  time.Time   `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorCreditResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreditResponse) UnmarshalJSON(data []byte) error {
	type embed VendorCreditResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = VendorCreditResponse(unmarshaler.embed)
	v.CreatedAt = unmarshaler.CreatedAt.Time()
	v.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreditResponse) MarshalJSON() ([]byte, error) {
	type embed VendorCreditResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt"`
		UpdatedAt *core.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*v),
		CreatedAt: core.NewDateTime(v.CreatedAt),
		UpdatedAt: core.NewDateTime(v.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (v *VendorCreditResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type CounterpartyEventWebhook struct {
	EventType string `json:"eventType" url:"eventType"`
	// The ID of the entity that owns the counterparty relationship
	EntityID EntityID `json:"entityId" url:"entityId"`
	// The ID of the counterparty
	CounterpartyID EntityID `json:"counterpartyId" url:"counterpartyId"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyEventWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyEventWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyEventWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyEventWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyEventWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CounterpartyWebhook struct {
	EventType string     `json:"eventType" url:"eventType"`
	PayeeID   []EntityID `json:"payeeId,omitempty" url:"payeeId,omitempty"`
	PayorID   []EntityID `json:"payorId,omitempty" url:"payorId,omitempty"`
	// User who initiated the change.
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CounterpartyWebhook) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CounterpartyWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler CounterpartyWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CounterpartyWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CounterpartyWebhook) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EntityWebhook struct {
	EventType string          `json:"eventType" url:"eventType"`
	Entity    *EntityResponse `json:"entity,omitempty" url:"entity,omitempty"`
	// User who initiated the change.
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EntityWebhook) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityWebhook) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type InvoiceEmailWebhook struct {
	EventType string `json:"eventType" url:"eventType"`
	// If an invoice was created from the email, this will be present.
	Invoice *InvoiceResponse `json:"invoice,omitempty" url:"invoice,omitempty"`
	// If an existing invoice already exists for the email, this will be present.
	ExistingInvoiceID *InvoiceID `json:"existingInvoiceId,omitempty" url:"existingInvoiceId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceEmailWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEmailWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceEmailWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceEmailWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEmailWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceStatusChangedWebhook struct {
	EventType string           `json:"eventType" url:"eventType"`
	Invoice   *InvoiceResponse `json:"invoice,omitempty" url:"invoice,omitempty"`
	// User who initiated the change.
	User           *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`
	NewStatus      string              `json:"newStatus" url:"newStatus"`
	PreviousStatus string              `json:"previousStatus" url:"previousStatus"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceStatusChangedWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceStatusChangedWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceStatusChangedWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceStatusChangedWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceStatusChangedWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceWebhook struct {
	EventType string           `json:"eventType" url:"eventType"`
	Invoice   *InvoiceResponse `json:"invoice,omitempty" url:"invoice,omitempty"`
	// User who initiated the change.
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceWebhook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceWebhook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type PaymentMethodWebhook struct {
	EventType     string                 `json:"eventType" url:"eventType"`
	EntityID      EntityID               `json:"entityId" url:"entityId"`
	PaymentMethod *PaymentMethodResponse `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	Entity        *EntityResponse        `json:"entity,omitempty" url:"entity,omitempty"`
	// User who initiated the change.
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentMethodWebhook) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodWebhook) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
