// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type EmailLog struct {
	ID EmailLogID `json:"id" url:"id"`
	// The status of the email log. If the status is PENDING, the email has not been processed yet. If the status is PROCESSED, the email has been processed and the invoice has been created. If the status is FAILED, the email was not processed due to an error.
	Status     IncomingEmailLogStatus `json:"status" url:"status"`
	Subject    string                 `json:"subject" url:"subject"`
	From       string                 `json:"from" url:"from"`
	To         string                 `json:"to" url:"to"`
	HTMLBody   string                 `json:"htmlBody" url:"htmlBody"`
	TextBody   string                 `json:"textBody" url:"textBody"`
	Attachment *EmailLogAttachment    `json:"attachment,omitempty" url:"attachment,omitempty"`
	CreatedAt  time.Time              `json:"createdAt" url:"createdAt"`
	InvoiceID  *InvoiceID             `json:"invoiceId,omitempty" url:"invoiceId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailLog) GetID() EmailLogID {
	if e == nil {
		return ""
	}
	return e.ID
}

func (e *EmailLog) GetStatus() IncomingEmailLogStatus {
	if e == nil {
		return ""
	}
	return e.Status
}

func (e *EmailLog) GetSubject() string {
	if e == nil {
		return ""
	}
	return e.Subject
}

func (e *EmailLog) GetFrom() string {
	if e == nil {
		return ""
	}
	return e.From
}

func (e *EmailLog) GetTo() string {
	if e == nil {
		return ""
	}
	return e.To
}

func (e *EmailLog) GetHTMLBody() string {
	if e == nil {
		return ""
	}
	return e.HTMLBody
}

func (e *EmailLog) GetTextBody() string {
	if e == nil {
		return ""
	}
	return e.TextBody
}

func (e *EmailLog) GetAttachment() *EmailLogAttachment {
	if e == nil {
		return nil
	}
	return e.Attachment
}

func (e *EmailLog) GetCreatedAt() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.CreatedAt
}

func (e *EmailLog) GetInvoiceID() *InvoiceID {
	if e == nil {
		return nil
	}
	return e.InvoiceID
}

func (e *EmailLog) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailLog) UnmarshalJSON(data []byte) error {
	type embed EmailLog
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmailLog(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLog) MarshalJSON() ([]byte, error) {
	type embed EmailLog
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*e),
		CreatedAt: internal.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmailLog) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailLogAttachment struct {
	Filename    string `json:"filename" url:"filename"`
	ContentType string `json:"contentType" url:"contentType"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailLogAttachment) GetFilename() string {
	if e == nil {
		return ""
	}
	return e.Filename
}

func (e *EmailLogAttachment) GetContentType() string {
	if e == nil {
		return ""
	}
	return e.ContentType
}

func (e *EmailLogAttachment) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailLogAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailLogAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailLogAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLogAttachment) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmailLogID = string

type EmailLogResponse struct {
	// Total number of logs for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more logs available for the given filters.
	HasMore bool        `json:"hasMore" url:"hasMore"`
	Data    []*EmailLog `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmailLogResponse) GetCount() int {
	if e == nil {
		return 0
	}
	return e.Count
}

func (e *EmailLogResponse) GetHasMore() bool {
	if e == nil {
		return false
	}
	return e.HasMore
}

func (e *EmailLogResponse) GetData() []*EmailLog {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EmailLogResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailLogResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailLogResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailLogResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmailLogResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type IncomingEmailLogStatus string

const (
	IncomingEmailLogStatusPending   IncomingEmailLogStatus = "PENDING"
	IncomingEmailLogStatusProcessed IncomingEmailLogStatus = "PROCESSED"
	IncomingEmailLogStatusFailed    IncomingEmailLogStatus = "FAILED"
)

func NewIncomingEmailLogStatusFromString(s string) (IncomingEmailLogStatus, error) {
	switch s {
	case "PENDING":
		return IncomingEmailLogStatusPending, nil
	case "PROCESSED":
		return IncomingEmailLogStatusProcessed, nil
	case "FAILED":
		return IncomingEmailLogStatusFailed, nil
	}
	var t IncomingEmailLogStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IncomingEmailLogStatus) Ptr() *IncomingEmailLogStatus {
	return &i
}
