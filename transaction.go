// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type FindTransactionsRequest struct {
	// Filter transactions by the ID or foreign ID of the entity that created the transaction.
	EntityID []*EntityID `json:"-" url:"entityId,omitempty"`
	// Filter transactions by the ID or foreign ID of the entity group that the entity belongs to.
	EntityGroupID *EntityGroupID `json:"-" url:"entityGroupId,omitempty"`
	// CREATED_AT Start date filter.
	StartDate *time.Time `json:"-" url:"startDate,omitempty"`
	// CREATED_AT End date filter.
	EndDate *time.Time `json:"-" url:"endDate,omitempty"`
	// Number of transactions to return. Limit can range between 1 and 100, and the default is 10.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The ID of the transactions to start after. If not provided, the first page of transactions will be returned.
	StartingAfter *TransactionID `json:"-" url:"startingAfter,omitempty"`
	// Find transactions by vendor name, invoice number, check number, or amount. Partial matches are supported.
	Search *string `json:"-" url:"search,omitempty"`
	// Filter transactions by invoice metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.
	Metadata []*MetadataFilter `json:"-" url:"metadata,omitempty"`
	// Filter transactions by invoice line item metadata. Each filter will be applied as an AND condition. Duplicate keys will be ignored.
	LineItemMetadata []*MetadataFilter `json:"-" url:"lineItemMetadata,omitempty"`
	// Filter transactions by invoice line item GL account ID. Each filter will be applied as an OR condition. Duplicate keys will be ignored.
	LineItemGlAccountID []*string `json:"-" url:"lineItemGlAccountId,omitempty"`
	// Filter transactions by payer ID or payer foreign ID.
	PayerID []*EntityID `json:"-" url:"payerId,omitempty"`
	// Filter transactions by vendor ID or vendor foreign ID.
	VendorID []*EntityID `json:"-" url:"vendorId,omitempty"`
	// Filter transactions by invoice ID or invoice foreign ID.
	InvoiceID []*InvoiceID `json:"-" url:"invoiceId,omitempty"`
	// Filter transactions by transaction ID.
	TransactionID []*TransactionID `json:"-" url:"transactionId,omitempty"`
	// Transaction status to filter on
	Status []*TransactionStatus `json:"-" url:"status,omitempty"`
	// Filter transactions by transaction type
	TransactionType []*TransactionType `json:"-" url:"transactionType,omitempty"`
	// Filter transactions by creator user ID. Does not work, do not use.
	CreatorUserID []*string `json:"-" url:"creatorUserId,omitempty"`
}

type FindTransactionsResponse struct {
	Count   int                    `json:"count" url:"count"`
	HasMore bool                   `json:"hasMore" url:"hasMore"`
	Data    []*TransactionResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindTransactionsResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindTransactionsResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindTransactionsResponse) GetData() []*TransactionResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindTransactionsResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindTransactionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindTransactionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindTransactionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindTransactionsResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type TransactionFailureReason struct {
	// The failure reason code.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The failure reason description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionFailureReason) GetCode() *string {
	if t == nil {
		return nil
	}
	return t.Code
}

func (t *TransactionFailureReason) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TransactionFailureReason) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionFailureReason) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionFailureReason
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionFailureReason(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionFailureReason) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionID = string

type TransactionResponse struct {
	Type                      string
	BankAccountToBankAccount  *TransactionResponseBankToBankWithInvoices
	BankAccountToMailedCheck  *TransactionResponseBankToCheckWithInvoices
	BankAccountToPrintedCheck *TransactionResponseBankToCheckWithInvoices
	BankAccountToWallet       *TransactionResponseBankToWalletWithInvoices
	CardToBankAccount         *TransactionResponseCardToBankAccountWithInvoices
	CardToWallet              *TransactionResponseCardToWalletWithInvoices
	WalletToBankAccount       *TransactionResponseWalletToBankWithInvoices
	WalletToWallet            *TransactionResponseWalletToWalletWithInvoices
	Custom                    *TransactionResponseCustomWithInvoices
	OffPlatform               *TransactionResponseCustomWithInvoices
}

func (t *TransactionResponse) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TransactionResponse) GetBankAccountToBankAccount() *TransactionResponseBankToBankWithInvoices {
	if t == nil {
		return nil
	}
	return t.BankAccountToBankAccount
}

func (t *TransactionResponse) GetBankAccountToMailedCheck() *TransactionResponseBankToCheckWithInvoices {
	if t == nil {
		return nil
	}
	return t.BankAccountToMailedCheck
}

func (t *TransactionResponse) GetBankAccountToPrintedCheck() *TransactionResponseBankToCheckWithInvoices {
	if t == nil {
		return nil
	}
	return t.BankAccountToPrintedCheck
}

func (t *TransactionResponse) GetBankAccountToWallet() *TransactionResponseBankToWalletWithInvoices {
	if t == nil {
		return nil
	}
	return t.BankAccountToWallet
}

func (t *TransactionResponse) GetCardToBankAccount() *TransactionResponseCardToBankAccountWithInvoices {
	if t == nil {
		return nil
	}
	return t.CardToBankAccount
}

func (t *TransactionResponse) GetCardToWallet() *TransactionResponseCardToWalletWithInvoices {
	if t == nil {
		return nil
	}
	return t.CardToWallet
}

func (t *TransactionResponse) GetWalletToBankAccount() *TransactionResponseWalletToBankWithInvoices {
	if t == nil {
		return nil
	}
	return t.WalletToBankAccount
}

func (t *TransactionResponse) GetWalletToWallet() *TransactionResponseWalletToWalletWithInvoices {
	if t == nil {
		return nil
	}
	return t.WalletToWallet
}

func (t *TransactionResponse) GetCustom() *TransactionResponseCustomWithInvoices {
	if t == nil {
		return nil
	}
	return t.Custom
}

func (t *TransactionResponse) GetOffPlatform() *TransactionResponseCustomWithInvoices {
	if t == nil {
		return nil
	}
	return t.OffPlatform
}

func (t *TransactionResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "bankAccountToBankAccount":
		value := new(TransactionResponseBankToBankWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToBankAccount = value
	case "bankAccountToMailedCheck":
		value := new(TransactionResponseBankToCheckWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToMailedCheck = value
	case "bankAccountToPrintedCheck":
		value := new(TransactionResponseBankToCheckWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToPrintedCheck = value
	case "bankAccountToWallet":
		value := new(TransactionResponseBankToWalletWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToWallet = value
	case "cardToBankAccount":
		value := new(TransactionResponseCardToBankAccountWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.CardToBankAccount = value
	case "cardToWallet":
		value := new(TransactionResponseCardToWalletWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.CardToWallet = value
	case "walletToBankAccount":
		value := new(TransactionResponseWalletToBankWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WalletToBankAccount = value
	case "walletToWallet":
		value := new(TransactionResponseWalletToWalletWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WalletToWallet = value
	case "custom":
		value := new(TransactionResponseCustomWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Custom = value
	case "offPlatform":
		value := new(TransactionResponseCustomWithInvoices)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OffPlatform = value
	}
	return nil
}

func (t TransactionResponse) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.BankAccountToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToBankAccount, "type", "bankAccountToBankAccount")
	}
	if t.BankAccountToMailedCheck != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToMailedCheck, "type", "bankAccountToMailedCheck")
	}
	if t.BankAccountToPrintedCheck != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToPrintedCheck, "type", "bankAccountToPrintedCheck")
	}
	if t.BankAccountToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToWallet, "type", "bankAccountToWallet")
	}
	if t.CardToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.CardToBankAccount, "type", "cardToBankAccount")
	}
	if t.CardToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.CardToWallet, "type", "cardToWallet")
	}
	if t.WalletToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.WalletToBankAccount, "type", "walletToBankAccount")
	}
	if t.WalletToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.WalletToWallet, "type", "walletToWallet")
	}
	if t.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(t.Custom, "type", "custom")
	}
	if t.OffPlatform != nil {
		return internal.MarshalJSONWithExtraProperty(t.OffPlatform, "type", "offPlatform")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TransactionResponseVisitor interface {
	VisitBankAccountToBankAccount(*TransactionResponseBankToBankWithInvoices) error
	VisitBankAccountToMailedCheck(*TransactionResponseBankToCheckWithInvoices) error
	VisitBankAccountToPrintedCheck(*TransactionResponseBankToCheckWithInvoices) error
	VisitBankAccountToWallet(*TransactionResponseBankToWalletWithInvoices) error
	VisitCardToBankAccount(*TransactionResponseCardToBankAccountWithInvoices) error
	VisitCardToWallet(*TransactionResponseCardToWalletWithInvoices) error
	VisitWalletToBankAccount(*TransactionResponseWalletToBankWithInvoices) error
	VisitWalletToWallet(*TransactionResponseWalletToWalletWithInvoices) error
	VisitCustom(*TransactionResponseCustomWithInvoices) error
	VisitOffPlatform(*TransactionResponseCustomWithInvoices) error
}

func (t *TransactionResponse) Accept(visitor TransactionResponseVisitor) error {
	if t.BankAccountToBankAccount != nil {
		return visitor.VisitBankAccountToBankAccount(t.BankAccountToBankAccount)
	}
	if t.BankAccountToMailedCheck != nil {
		return visitor.VisitBankAccountToMailedCheck(t.BankAccountToMailedCheck)
	}
	if t.BankAccountToPrintedCheck != nil {
		return visitor.VisitBankAccountToPrintedCheck(t.BankAccountToPrintedCheck)
	}
	if t.BankAccountToWallet != nil {
		return visitor.VisitBankAccountToWallet(t.BankAccountToWallet)
	}
	if t.CardToBankAccount != nil {
		return visitor.VisitCardToBankAccount(t.CardToBankAccount)
	}
	if t.CardToWallet != nil {
		return visitor.VisitCardToWallet(t.CardToWallet)
	}
	if t.WalletToBankAccount != nil {
		return visitor.VisitWalletToBankAccount(t.WalletToBankAccount)
	}
	if t.WalletToWallet != nil {
		return visitor.VisitWalletToWallet(t.WalletToWallet)
	}
	if t.Custom != nil {
		return visitor.VisitCustom(t.Custom)
	}
	if t.OffPlatform != nil {
		return visitor.VisitOffPlatform(t.OffPlatform)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *TransactionResponse) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.BankAccountToBankAccount != nil {
		fields = append(fields, "bankAccountToBankAccount")
	}
	if t.BankAccountToMailedCheck != nil {
		fields = append(fields, "bankAccountToMailedCheck")
	}
	if t.BankAccountToPrintedCheck != nil {
		fields = append(fields, "bankAccountToPrintedCheck")
	}
	if t.BankAccountToWallet != nil {
		fields = append(fields, "bankAccountToWallet")
	}
	if t.CardToBankAccount != nil {
		fields = append(fields, "cardToBankAccount")
	}
	if t.CardToWallet != nil {
		fields = append(fields, "cardToWallet")
	}
	if t.WalletToBankAccount != nil {
		fields = append(fields, "walletToBankAccount")
	}
	if t.WalletToWallet != nil {
		fields = append(fields, "walletToWallet")
	}
	if t.Custom != nil {
		fields = append(fields, "custom")
	}
	if t.OffPlatform != nil {
		fields = append(fields, "offPlatform")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type TransactionResponseAchBase struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *TransactionFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseAchBase) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseAchBase) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseAchBase) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseAchBase) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseAchBase) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseAchBase) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseAchBase) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseAchBase) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseAchBase) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseAchBase) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseAchBase) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseAchBase) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseAchBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseAchBase) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseAchBase) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseAchBase) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseAchBase) GetFailureReason() *TransactionFailureReason {
	if t == nil {
		return nil
	}
	return t.FailureReason
}

func (t *TransactionResponseAchBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseAchBase) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseAchBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseAchBase(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseAchBase) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseAchBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseAchBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseBankToBankWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *TransactionFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseBankToBankWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseBankToBankWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseBankToBankWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseBankToBankWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseBankToBankWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseBankToBankWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseBankToBankWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseBankToBankWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseBankToBankWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseBankToBankWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseBankToBankWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseBankToBankWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseBankToBankWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseBankToBankWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseBankToBankWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseBankToBankWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseBankToBankWithInvoices) GetFailureReason() *TransactionFailureReason {
	if t == nil {
		return nil
	}
	return t.FailureReason
}

func (t *TransactionResponseBankToBankWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseBankToBankWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseBankToBankWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseBankToBankWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseBankToBankWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseBankToBankWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseBankToBankWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseBankToBankWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseBankToCheckWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// The number of the check
	CheckNumber int `json:"checkNumber" url:"checkNumber"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseBankToCheckWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseBankToCheckWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseBankToCheckWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseBankToCheckWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseBankToCheckWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseBankToCheckWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseBankToCheckWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseBankToCheckWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseBankToCheckWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseBankToCheckWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseBankToCheckWithInvoices) GetCheckNumber() int {
	if t == nil {
		return 0
	}
	return t.CheckNumber
}

func (t *TransactionResponseBankToCheckWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseBankToCheckWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseBankToCheckWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseBankToCheckWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseBankToCheckWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseBankToCheckWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseBankToCheckWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseBankToCheckWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseBankToWalletWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *TransactionFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseBankToWalletWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseBankToWalletWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseBankToWalletWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseBankToWalletWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseBankToWalletWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseBankToWalletWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseBankToWalletWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseBankToWalletWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseBankToWalletWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseBankToWalletWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseBankToWalletWithInvoices) GetFailureReason() *TransactionFailureReason {
	if t == nil {
		return nil
	}
	return t.FailureReason
}

func (t *TransactionResponseBankToWalletWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseBankToWalletWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseBankToWalletWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseBankToWalletWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseBankToWalletWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseBankToWalletWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseBankToWalletWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseBankToWalletWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseBase struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseBase) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseBase) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseBase) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseBase) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseBase) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseBase) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseBase) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseBase) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseBase) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseBase) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseBase) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseBase) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseBase) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseBase) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseBase) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseBase) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseBase(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseBase) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseCardToBankAccountWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *TransactionFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetFailureReason() *TransactionFailureReason {
	if t == nil {
		return nil
	}
	return t.FailureReason
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseCardToBankAccountWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseCardToBankAccountWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseCardToBankAccountWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseCardToBankAccountWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseCardToBankAccountWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseCardToBankAccountWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseCardToBankAccountWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseCardToWalletWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseCardToWalletWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseCardToWalletWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseCardToWalletWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseCardToWalletWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseCardToWalletWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseCardToWalletWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseCardToWalletWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseCardToWalletWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseCardToWalletWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseCardToWalletWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseCardToWalletWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseCardToWalletWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseCardToWalletWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseCardToWalletWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseCardToWalletWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseCardToWalletWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseCardToWalletWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseCardToWalletWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseCheckBase struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// The number of the check
	CheckNumber int `json:"checkNumber" url:"checkNumber"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseCheckBase) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseCheckBase) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseCheckBase) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseCheckBase) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseCheckBase) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseCheckBase) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseCheckBase) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseCheckBase) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseCheckBase) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseCheckBase) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseCheckBase) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseCheckBase) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseCheckBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseCheckBase) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseCheckBase) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseCheckBase) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseCheckBase) GetCheckNumber() int {
	if t == nil {
		return 0
	}
	return t.CheckNumber
}

func (t *TransactionResponseCheckBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseCheckBase) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseCheckBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseCheckBase(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseCheckBase) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseCheckBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseCheckBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseCustomWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseCustomWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseCustomWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseCustomWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseCustomWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseCustomWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseCustomWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseCustomWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseCustomWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseCustomWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseCustomWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseCustomWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseCustomWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseCustomWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseCustomWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseCustomWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseCustomWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseCustomWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseCustomWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseCustomWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseCustomWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseCustomWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseCustomWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseCustomWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseCustomWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseWalletToBankWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// If the invoice failed to be paid, this field will be populated with the reason of failure.
	FailureReason *TransactionFailureReason `json:"failureReason,omitempty" url:"failureReason,omitempty"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseWalletToBankWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseWalletToBankWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseWalletToBankWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseWalletToBankWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseWalletToBankWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseWalletToBankWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseWalletToBankWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseWalletToBankWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseWalletToBankWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseWalletToBankWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseWalletToBankWithInvoices) GetFailureReason() *TransactionFailureReason {
	if t == nil {
		return nil
	}
	return t.FailureReason
}

func (t *TransactionResponseWalletToBankWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseWalletToBankWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseWalletToBankWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseWalletToBankWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseWalletToBankWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseWalletToBankWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseWalletToBankWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseWalletToBankWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseWalletToWalletWithInvoices struct {
	ID                        TransactionID              `json:"id" url:"id"`
	Status                    TransactionStatus          `json:"status" url:"status"`
	Amount                    float64                    `json:"amount" url:"amount"`
	Currency                  string                     `json:"currency" url:"currency"`
	PayerID                   EntityID                   `json:"payerId" url:"payerId"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           PaymentMethodID            `json:"paymentSourceId" url:"paymentSourceId"`
	VendorID                  EntityID                   `json:"vendorId" url:"vendorId"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      PaymentMethodID            `json:"paymentDestinationId" url:"paymentDestinationId"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	Fees                      *InvoiceFeesResponse       `json:"fees,omitempty" url:"fees,omitempty"`
	CreatedAt                 time.Time                  `json:"createdAt" url:"createdAt"`
	UpdatedAt                 time.Time                  `json:"updatedAt" url:"updatedAt"`
	// Invoices associated with this transaction
	Invoices []*InvoiceResponse `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetID() TransactionID {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetStatus() TransactionStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetAmount() float64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetCurrency() string {
	if t == nil {
		return ""
	}
	return t.Currency
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPayerID() EntityID {
	if t == nil {
		return ""
	}
	return t.PayerID
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPayer() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Payer
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPaymentSource() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentSource
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPaymentSourceID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentSourceID
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetVendorID() EntityID {
	if t == nil {
		return ""
	}
	return t.VendorID
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetVendor() *CounterpartyResponse {
	if t == nil {
		return nil
	}
	return t.Vendor
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPaymentDestination() *PaymentMethodResponse {
	if t == nil {
		return nil
	}
	return t.PaymentDestination
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPaymentDestinationID() PaymentMethodID {
	if t == nil {
		return ""
	}
	return t.PaymentDestinationID
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if t == nil {
		return nil
	}
	return t.PaymentDestinationOptions
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetFees() *InvoiceFeesResponse {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetUpdatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.UpdatedAt
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetInvoices() []*InvoiceResponse {
	if t == nil {
		return nil
	}
	return t.Invoices
}

func (t *TransactionResponseWalletToWalletWithInvoices) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResponseWalletToWalletWithInvoices) UnmarshalJSON(data []byte) error {
	type embed TransactionResponseWalletToWalletWithInvoices
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionResponseWalletToWalletWithInvoices(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResponseWalletToWalletWithInvoices) MarshalJSON() ([]byte, error) {
	type embed TransactionResponseWalletToWalletWithInvoices
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*t),
		CreatedAt: internal.NewDateTime(t.CreatedAt),
		UpdatedAt: internal.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TransactionResponseWalletToWalletWithInvoices) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransactionResponseWithoutInvoices struct {
	Type                      string
	BankAccountToBankAccount  *TransactionResponseAchBase
	BankAccountToMailedCheck  *TransactionResponseCheckBase
	BankAccountToPrintedCheck *TransactionResponseCheckBase
	BankAccountToWallet       *TransactionResponseAchBase
	CardToBankAccount         *TransactionResponseAchBase
	CardToWallet              *TransactionResponseBase
	WalletToBankAccount       *TransactionResponseAchBase
	WalletToWallet            *TransactionResponseBase
	Custom                    *TransactionResponseBase
	OffPlatform               *TransactionResponseBase
}

func (t *TransactionResponseWithoutInvoices) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TransactionResponseWithoutInvoices) GetBankAccountToBankAccount() *TransactionResponseAchBase {
	if t == nil {
		return nil
	}
	return t.BankAccountToBankAccount
}

func (t *TransactionResponseWithoutInvoices) GetBankAccountToMailedCheck() *TransactionResponseCheckBase {
	if t == nil {
		return nil
	}
	return t.BankAccountToMailedCheck
}

func (t *TransactionResponseWithoutInvoices) GetBankAccountToPrintedCheck() *TransactionResponseCheckBase {
	if t == nil {
		return nil
	}
	return t.BankAccountToPrintedCheck
}

func (t *TransactionResponseWithoutInvoices) GetBankAccountToWallet() *TransactionResponseAchBase {
	if t == nil {
		return nil
	}
	return t.BankAccountToWallet
}

func (t *TransactionResponseWithoutInvoices) GetCardToBankAccount() *TransactionResponseAchBase {
	if t == nil {
		return nil
	}
	return t.CardToBankAccount
}

func (t *TransactionResponseWithoutInvoices) GetCardToWallet() *TransactionResponseBase {
	if t == nil {
		return nil
	}
	return t.CardToWallet
}

func (t *TransactionResponseWithoutInvoices) GetWalletToBankAccount() *TransactionResponseAchBase {
	if t == nil {
		return nil
	}
	return t.WalletToBankAccount
}

func (t *TransactionResponseWithoutInvoices) GetWalletToWallet() *TransactionResponseBase {
	if t == nil {
		return nil
	}
	return t.WalletToWallet
}

func (t *TransactionResponseWithoutInvoices) GetCustom() *TransactionResponseBase {
	if t == nil {
		return nil
	}
	return t.Custom
}

func (t *TransactionResponseWithoutInvoices) GetOffPlatform() *TransactionResponseBase {
	if t == nil {
		return nil
	}
	return t.OffPlatform
}

func (t *TransactionResponseWithoutInvoices) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "bankAccountToBankAccount":
		value := new(TransactionResponseAchBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToBankAccount = value
	case "bankAccountToMailedCheck":
		value := new(TransactionResponseCheckBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToMailedCheck = value
	case "bankAccountToPrintedCheck":
		value := new(TransactionResponseCheckBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToPrintedCheck = value
	case "bankAccountToWallet":
		value := new(TransactionResponseAchBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.BankAccountToWallet = value
	case "cardToBankAccount":
		value := new(TransactionResponseAchBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.CardToBankAccount = value
	case "cardToWallet":
		value := new(TransactionResponseBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.CardToWallet = value
	case "walletToBankAccount":
		value := new(TransactionResponseAchBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WalletToBankAccount = value
	case "walletToWallet":
		value := new(TransactionResponseBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WalletToWallet = value
	case "custom":
		value := new(TransactionResponseBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Custom = value
	case "offPlatform":
		value := new(TransactionResponseBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OffPlatform = value
	}
	return nil
}

func (t TransactionResponseWithoutInvoices) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.BankAccountToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToBankAccount, "type", "bankAccountToBankAccount")
	}
	if t.BankAccountToMailedCheck != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToMailedCheck, "type", "bankAccountToMailedCheck")
	}
	if t.BankAccountToPrintedCheck != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToPrintedCheck, "type", "bankAccountToPrintedCheck")
	}
	if t.BankAccountToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.BankAccountToWallet, "type", "bankAccountToWallet")
	}
	if t.CardToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.CardToBankAccount, "type", "cardToBankAccount")
	}
	if t.CardToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.CardToWallet, "type", "cardToWallet")
	}
	if t.WalletToBankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(t.WalletToBankAccount, "type", "walletToBankAccount")
	}
	if t.WalletToWallet != nil {
		return internal.MarshalJSONWithExtraProperty(t.WalletToWallet, "type", "walletToWallet")
	}
	if t.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(t.Custom, "type", "custom")
	}
	if t.OffPlatform != nil {
		return internal.MarshalJSONWithExtraProperty(t.OffPlatform, "type", "offPlatform")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TransactionResponseWithoutInvoicesVisitor interface {
	VisitBankAccountToBankAccount(*TransactionResponseAchBase) error
	VisitBankAccountToMailedCheck(*TransactionResponseCheckBase) error
	VisitBankAccountToPrintedCheck(*TransactionResponseCheckBase) error
	VisitBankAccountToWallet(*TransactionResponseAchBase) error
	VisitCardToBankAccount(*TransactionResponseAchBase) error
	VisitCardToWallet(*TransactionResponseBase) error
	VisitWalletToBankAccount(*TransactionResponseAchBase) error
	VisitWalletToWallet(*TransactionResponseBase) error
	VisitCustom(*TransactionResponseBase) error
	VisitOffPlatform(*TransactionResponseBase) error
}

func (t *TransactionResponseWithoutInvoices) Accept(visitor TransactionResponseWithoutInvoicesVisitor) error {
	if t.BankAccountToBankAccount != nil {
		return visitor.VisitBankAccountToBankAccount(t.BankAccountToBankAccount)
	}
	if t.BankAccountToMailedCheck != nil {
		return visitor.VisitBankAccountToMailedCheck(t.BankAccountToMailedCheck)
	}
	if t.BankAccountToPrintedCheck != nil {
		return visitor.VisitBankAccountToPrintedCheck(t.BankAccountToPrintedCheck)
	}
	if t.BankAccountToWallet != nil {
		return visitor.VisitBankAccountToWallet(t.BankAccountToWallet)
	}
	if t.CardToBankAccount != nil {
		return visitor.VisitCardToBankAccount(t.CardToBankAccount)
	}
	if t.CardToWallet != nil {
		return visitor.VisitCardToWallet(t.CardToWallet)
	}
	if t.WalletToBankAccount != nil {
		return visitor.VisitWalletToBankAccount(t.WalletToBankAccount)
	}
	if t.WalletToWallet != nil {
		return visitor.VisitWalletToWallet(t.WalletToWallet)
	}
	if t.Custom != nil {
		return visitor.VisitCustom(t.Custom)
	}
	if t.OffPlatform != nil {
		return visitor.VisitOffPlatform(t.OffPlatform)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *TransactionResponseWithoutInvoices) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.BankAccountToBankAccount != nil {
		fields = append(fields, "bankAccountToBankAccount")
	}
	if t.BankAccountToMailedCheck != nil {
		fields = append(fields, "bankAccountToMailedCheck")
	}
	if t.BankAccountToPrintedCheck != nil {
		fields = append(fields, "bankAccountToPrintedCheck")
	}
	if t.BankAccountToWallet != nil {
		fields = append(fields, "bankAccountToWallet")
	}
	if t.CardToBankAccount != nil {
		fields = append(fields, "cardToBankAccount")
	}
	if t.CardToWallet != nil {
		fields = append(fields, "cardToWallet")
	}
	if t.WalletToBankAccount != nil {
		fields = append(fields, "walletToBankAccount")
	}
	if t.WalletToWallet != nil {
		fields = append(fields, "walletToWallet")
	}
	if t.Custom != nil {
		fields = append(fields, "custom")
	}
	if t.OffPlatform != nil {
		fields = append(fields, "offPlatform")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

type TransactionStatus string

const (
	TransactionStatusCreated   TransactionStatus = "CREATED"
	TransactionStatusPending   TransactionStatus = "PENDING"
	TransactionStatusCompleted TransactionStatus = "COMPLETED"
	TransactionStatusFailed    TransactionStatus = "FAILED"
	TransactionStatusReversed  TransactionStatus = "REVERSED"
	TransactionStatusQueued    TransactionStatus = "QUEUED"
	TransactionStatusCanceled  TransactionStatus = "CANCELED"
	TransactionStatusReturned  TransactionStatus = "RETURNED"
)

func NewTransactionStatusFromString(s string) (TransactionStatus, error) {
	switch s {
	case "CREATED":
		return TransactionStatusCreated, nil
	case "PENDING":
		return TransactionStatusPending, nil
	case "COMPLETED":
		return TransactionStatusCompleted, nil
	case "FAILED":
		return TransactionStatusFailed, nil
	case "REVERSED":
		return TransactionStatusReversed, nil
	case "QUEUED":
		return TransactionStatusQueued, nil
	case "CANCELED":
		return TransactionStatusCanceled, nil
	case "RETURNED":
		return TransactionStatusReturned, nil
	}
	var t TransactionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionStatus) Ptr() *TransactionStatus {
	return &t
}

type TransactionType string

const (
	TransactionTypeBankAccountToBankAccount  TransactionType = "bankAccountToBankAccount"
	TransactionTypeBankAccountToMailedCheck  TransactionType = "bankAccountToMailedCheck"
	TransactionTypeBankAccountToPrintedCheck TransactionType = "bankAccountToPrintedCheck"
	TransactionTypeBankAccountToWallet       TransactionType = "bankAccountToWallet"
	TransactionTypeCardToBankAccount         TransactionType = "cardToBankAccount"
	TransactionTypeCardToWallet              TransactionType = "cardToWallet"
	TransactionTypeWalletToBankAccount       TransactionType = "walletToBankAccount"
	TransactionTypeWalletToWallet            TransactionType = "walletToWallet"
	TransactionTypeCustom                    TransactionType = "custom"
	TransactionTypeOffPlatform               TransactionType = "offPlatform"
)

func NewTransactionTypeFromString(s string) (TransactionType, error) {
	switch s {
	case "bankAccountToBankAccount":
		return TransactionTypeBankAccountToBankAccount, nil
	case "bankAccountToMailedCheck":
		return TransactionTypeBankAccountToMailedCheck, nil
	case "bankAccountToPrintedCheck":
		return TransactionTypeBankAccountToPrintedCheck, nil
	case "bankAccountToWallet":
		return TransactionTypeBankAccountToWallet, nil
	case "cardToBankAccount":
		return TransactionTypeCardToBankAccount, nil
	case "cardToWallet":
		return TransactionTypeCardToWallet, nil
	case "walletToBankAccount":
		return TransactionTypeWalletToBankAccount, nil
	case "walletToWallet":
		return TransactionTypeWalletToWallet, nil
	case "custom":
		return TransactionTypeCustom, nil
	case "offPlatform":
		return TransactionTypeOffPlatform, nil
	}
	var t TransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionType) Ptr() *TransactionType {
	return &t
}
