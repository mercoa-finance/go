// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type BankAccountCheckOptions struct {
	// If true, will allow the user to print checks from this bank account
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// If provided, will start the check number sequence at the provided number. If not provided, will start at 5000.
	InitialCheckNumber *int `json:"initialCheckNumber,omitempty" url:"initialCheckNumber,omitempty"`
	// If provided, will print a check with the provided routing number instead of the one from the bank account
	RoutingNumberOverride *string `json:"routingNumberOverride,omitempty" url:"routingNumberOverride,omitempty"`
	// If provided, will print a check with the provided account number instead of the one from the bank account
	AccountNumberOverride *string `json:"accountNumberOverride,omitempty" url:"accountNumberOverride,omitempty"`
	// Name of the person who's signature will be printed on the check.
	SignatoryName string `json:"signatoryName" url:"signatoryName"`
	// Base64 encoded image of the signature. If not provided, will use the signatoryName to generate a signature. Mercoa will automatically grayscale, resize, and convert the image to a PNG the image to fit on the check.
	SignatureImage *string `json:"signatureImage,omitempty" url:"signatureImage,omitempty"`
	// If true, will print checks with the provided signatureImage. If false, will print checks with a generated signature from the signatoryName. If this parameter is not set the default behavior is to use the signatureImage if provided.
	UseSignatureImage *bool `json:"useSignatureImage,omitempty" url:"useSignatureImage,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountCheckOptions) GetEnabled() *bool {
	if b == nil {
		return nil
	}
	return b.Enabled
}

func (b *BankAccountCheckOptions) GetInitialCheckNumber() *int {
	if b == nil {
		return nil
	}
	return b.InitialCheckNumber
}

func (b *BankAccountCheckOptions) GetRoutingNumberOverride() *string {
	if b == nil {
		return nil
	}
	return b.RoutingNumberOverride
}

func (b *BankAccountCheckOptions) GetAccountNumberOverride() *string {
	if b == nil {
		return nil
	}
	return b.AccountNumberOverride
}

func (b *BankAccountCheckOptions) GetSignatoryName() string {
	if b == nil {
		return ""
	}
	return b.SignatoryName
}

func (b *BankAccountCheckOptions) GetSignatureImage() *string {
	if b == nil {
		return nil
	}
	return b.SignatureImage
}

func (b *BankAccountCheckOptions) GetUseSignatureImage() *bool {
	if b == nil {
		return nil
	}
	return b.UseSignatureImage
}

func (b *BankAccountCheckOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCheckOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCheckOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCheckOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCheckOptions) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	// The name of the account. For example "My Checking Account" or "Property XYZ Checking"
	AccountName *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// The name of the bank. This is now automatically set when the bank account is linked.
	BankName      *string  `json:"bankName,omitempty" url:"bankName,omitempty"`
	RoutingNumber string   `json:"routingNumber" url:"routingNumber"`
	AccountNumber string   `json:"accountNumber" url:"accountNumber"`
	AccountType   BankType `json:"accountType" url:"accountType"`
	// If provided, will link a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountRequest) GetDefaultSource() *bool {
	if b == nil {
		return nil
	}
	return b.DefaultSource
}

func (b *BankAccountRequest) GetDefaultDestination() *bool {
	if b == nil {
		return nil
	}
	return b.DefaultDestination
}

func (b *BankAccountRequest) GetExternalAccountingSystemID() *string {
	if b == nil {
		return nil
	}
	return b.ExternalAccountingSystemID
}

func (b *BankAccountRequest) GetFrozen() *bool {
	if b == nil {
		return nil
	}
	return b.Frozen
}

func (b *BankAccountRequest) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BankAccountRequest) GetConfirmedByEntity() *bool {
	if b == nil {
		return nil
	}
	return b.ConfirmedByEntity
}

func (b *BankAccountRequest) GetAccountName() *string {
	if b == nil {
		return nil
	}
	return b.AccountName
}

func (b *BankAccountRequest) GetBankName() *string {
	if b == nil {
		return nil
	}
	return b.BankName
}

func (b *BankAccountRequest) GetRoutingNumber() string {
	if b == nil {
		return ""
	}
	return b.RoutingNumber
}

func (b *BankAccountRequest) GetAccountNumber() string {
	if b == nil {
		return ""
	}
	return b.AccountNumber
}

func (b *BankAccountRequest) GetAccountType() BankType {
	if b == nil {
		return ""
	}
	return b.AccountType
}

func (b *BankAccountRequest) GetPlaid() *PlaidLinkRequest {
	if b == nil {
		return nil
	}
	return b.Plaid
}

func (b *BankAccountRequest) GetCheckOptions() *BankAccountCheckOptions {
	if b == nil {
		return nil
	}
	return b.CheckOptions
}

func (b *BankAccountRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool      `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time  `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time  `json:"updatedAt" url:"updatedAt"`
	AccountName       string     `json:"accountName" url:"accountName"`
	BankName          string     `json:"bankName" url:"bankName"`
	RoutingNumber     string     `json:"routingNumber" url:"routingNumber"`
	AccountNumber     string     `json:"accountNumber" url:"accountNumber"`
	AccountType       BankType   `json:"accountType" url:"accountType"`
	Status            BankStatus `json:"status" url:"status"`
	// If check printing is enabled for the account, will return the check options for this bank account
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountResponse) GetID() PaymentMethodID {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BankAccountResponse) GetIsDefaultSource() bool {
	if b == nil {
		return false
	}
	return b.IsDefaultSource
}

func (b *BankAccountResponse) GetIsDefaultDestination() bool {
	if b == nil {
		return false
	}
	return b.IsDefaultDestination
}

func (b *BankAccountResponse) GetSupportedCurrencies() []CurrencyCode {
	if b == nil {
		return nil
	}
	return b.SupportedCurrencies
}

func (b *BankAccountResponse) GetExternalAccountingSystemID() *string {
	if b == nil {
		return nil
	}
	return b.ExternalAccountingSystemID
}

func (b *BankAccountResponse) GetFrozen() bool {
	if b == nil {
		return false
	}
	return b.Frozen
}

func (b *BankAccountResponse) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BankAccountResponse) GetConfirmedByEntity() *bool {
	if b == nil {
		return nil
	}
	return b.ConfirmedByEntity
}

func (b *BankAccountResponse) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BankAccountResponse) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BankAccountResponse) GetAccountName() string {
	if b == nil {
		return ""
	}
	return b.AccountName
}

func (b *BankAccountResponse) GetBankName() string {
	if b == nil {
		return ""
	}
	return b.BankName
}

func (b *BankAccountResponse) GetRoutingNumber() string {
	if b == nil {
		return ""
	}
	return b.RoutingNumber
}

func (b *BankAccountResponse) GetAccountNumber() string {
	if b == nil {
		return ""
	}
	return b.AccountNumber
}

func (b *BankAccountResponse) GetAccountType() BankType {
	if b == nil {
		return ""
	}
	return b.AccountType
}

func (b *BankAccountResponse) GetStatus() BankStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BankAccountResponse) GetCheckOptions() *BankAccountCheckOptions {
	if b == nil {
		return nil
	}
	return b.CheckOptions
}

func (b *BankAccountResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountResponse) UnmarshalJSON(data []byte) error {
	type embed BankAccountResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankAccountResponse(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountResponse) MarshalJSON() ([]byte, error) {
	type embed BankAccountResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BankAccountResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool   `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	AccountName       *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	// If provided, will update a bank account using Plaid Link
	Plaid *PlaidLinkRequest `json:"plaid,omitempty" url:"plaid,omitempty"`
	// If this bank account supports check printing, use this to enable check printing and set the check options. Checks will be printed directly from the bank account.
	CheckOptions *BankAccountCheckOptions `json:"checkOptions,omitempty" url:"checkOptions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountUpdateRequest) GetDefaultSource() *bool {
	if b == nil {
		return nil
	}
	return b.DefaultSource
}

func (b *BankAccountUpdateRequest) GetDefaultDestination() *bool {
	if b == nil {
		return nil
	}
	return b.DefaultDestination
}

func (b *BankAccountUpdateRequest) GetExternalAccountingSystemID() *string {
	if b == nil {
		return nil
	}
	return b.ExternalAccountingSystemID
}

func (b *BankAccountUpdateRequest) GetFrozen() *bool {
	if b == nil {
		return nil
	}
	return b.Frozen
}

func (b *BankAccountUpdateRequest) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BankAccountUpdateRequest) GetConfirmedByEntity() *bool {
	if b == nil {
		return nil
	}
	return b.ConfirmedByEntity
}

func (b *BankAccountUpdateRequest) GetAccountName() *string {
	if b == nil {
		return nil
	}
	return b.AccountName
}

func (b *BankAccountUpdateRequest) GetPlaid() *PlaidLinkRequest {
	if b == nil {
		return nil
	}
	return b.Plaid
}

func (b *BankAccountUpdateRequest) GetCheckOptions() *BankAccountCheckOptions {
	if b == nil {
		return nil
	}
	return b.CheckOptions
}

func (b *BankAccountUpdateRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountUpdateRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankStatus string

const (
	BankStatusNew                BankStatus = "NEW"
	BankStatusVerified           BankStatus = "VERIFIED"
	BankStatusVerificationFailed BankStatus = "VERIFICATION_FAILED"
	BankStatusPending            BankStatus = "PENDING"
	BankStatusErrored            BankStatus = "ERRORED"
)

func NewBankStatusFromString(s string) (BankStatus, error) {
	switch s {
	case "NEW":
		return BankStatusNew, nil
	case "VERIFIED":
		return BankStatusVerified, nil
	case "VERIFICATION_FAILED":
		return BankStatusVerificationFailed, nil
	case "PENDING":
		return BankStatusPending, nil
	case "ERRORED":
		return BankStatusErrored, nil
	}
	var t BankStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankStatus) Ptr() *BankStatus {
	return &b
}

type BankType string

const (
	BankTypeChecking BankType = "CHECKING"
	BankTypeSavings  BankType = "SAVINGS"
	BankTypeUnknown  BankType = "UNKNOWN"
)

func NewBankTypeFromString(s string) (BankType, error) {
	switch s {
	case "CHECKING":
		return BankTypeChecking, nil
	case "SAVINGS":
		return BankTypeSavings, nil
	case "UNKNOWN":
		return BankTypeUnknown, nil
	}
	var t BankType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankType) Ptr() *BankType {
	return &b
}

type CardBrand string

const (
	CardBrandAmericanExpress CardBrand = "AmericanExpress"
	CardBrandDiscover        CardBrand = "Discover"
	CardBrandMastercard      CardBrand = "Mastercard"
	CardBrandVisa            CardBrand = "Visa"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "AmericanExpress":
		return CardBrandAmericanExpress, nil
	case "Discover":
		return CardBrandDiscover, nil
	case "Mastercard":
		return CardBrandMastercard, nil
	case "Visa":
		return CardBrandVisa, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

type CardRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CardType          CardType  `json:"cardType" url:"cardType"`
	CardBrand         CardBrand `json:"cardBrand" url:"cardBrand"`
	LastFour          string    `json:"lastFour" url:"lastFour"`
	ExpMonth          string    `json:"expMonth" url:"expMonth"`
	ExpYear           string    `json:"expYear" url:"expYear"`
	Token             string    `json:"token" url:"token"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardRequest) GetDefaultSource() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultSource
}

func (c *CardRequest) GetDefaultDestination() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultDestination
}

func (c *CardRequest) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CardRequest) GetFrozen() *bool {
	if c == nil {
		return nil
	}
	return c.Frozen
}

func (c *CardRequest) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CardRequest) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CardRequest) GetCardType() CardType {
	if c == nil {
		return ""
	}
	return c.CardType
}

func (c *CardRequest) GetCardBrand() CardBrand {
	if c == nil {
		return ""
	}
	return c.CardBrand
}

func (c *CardRequest) GetLastFour() string {
	if c == nil {
		return ""
	}
	return c.LastFour
}

func (c *CardRequest) GetExpMonth() string {
	if c == nil {
		return ""
	}
	return c.ExpMonth
}

func (c *CardRequest) GetExpYear() string {
	if c == nil {
		return ""
	}
	return c.ExpYear
}

func (c *CardRequest) GetToken() string {
	if c == nil {
		return ""
	}
	return c.Token
}

func (c *CardRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`
	CardType          CardType  `json:"cardType" url:"cardType"`
	CardBrand         CardBrand `json:"cardBrand" url:"cardBrand"`
	LastFour          string    `json:"lastFour" url:"lastFour"`
	ExpMonth          string    `json:"expMonth" url:"expMonth"`
	ExpYear           string    `json:"expYear" url:"expYear"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardResponse) GetID() PaymentMethodID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CardResponse) GetIsDefaultSource() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultSource
}

func (c *CardResponse) GetIsDefaultDestination() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultDestination
}

func (c *CardResponse) GetSupportedCurrencies() []CurrencyCode {
	if c == nil {
		return nil
	}
	return c.SupportedCurrencies
}

func (c *CardResponse) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CardResponse) GetFrozen() bool {
	if c == nil {
		return false
	}
	return c.Frozen
}

func (c *CardResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CardResponse) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CardResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CardResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CardResponse) GetCardType() CardType {
	if c == nil {
		return ""
	}
	return c.CardType
}

func (c *CardResponse) GetCardBrand() CardBrand {
	if c == nil {
		return ""
	}
	return c.CardBrand
}

func (c *CardResponse) GetLastFour() string {
	if c == nil {
		return ""
	}
	return c.LastFour
}

func (c *CardResponse) GetExpMonth() string {
	if c == nil {
		return ""
	}
	return c.ExpMonth
}

func (c *CardResponse) GetExpYear() string {
	if c == nil {
		return ""
	}
	return c.ExpYear
}

func (c *CardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardResponse) UnmarshalJSON(data []byte) error {
	type embed CardResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CardResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardResponse) MarshalJSON() ([]byte, error) {
	type embed CardResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CardResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardType string

const (
	CardTypeCredit  CardType = "credit"
	CardTypeDebit   CardType = "debit"
	CardTypePrepaid CardType = "prepaid"
	CardTypeUnknown CardType = "unknown"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "credit":
		return CardTypeCredit, nil
	case "debit":
		return CardTypeDebit, nil
	case "prepaid":
		return CardTypePrepaid, nil
	case "unknown":
		return CardTypeUnknown, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

type CheckRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool   `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	PayToTheOrderOf   string  `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1      string  `json:"addressLine1" url:"addressLine1"`
	AddressLine2      *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City              string  `json:"city" url:"city"`
	StateOrProvince   string  `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode        string  `json:"postalCode" url:"postalCode"`
	Country           string  `json:"country" url:"country"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckRequest) GetDefaultSource() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultSource
}

func (c *CheckRequest) GetDefaultDestination() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultDestination
}

func (c *CheckRequest) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CheckRequest) GetFrozen() *bool {
	if c == nil {
		return nil
	}
	return c.Frozen
}

func (c *CheckRequest) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CheckRequest) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CheckRequest) GetPayToTheOrderOf() string {
	if c == nil {
		return ""
	}
	return c.PayToTheOrderOf
}

func (c *CheckRequest) GetAddressLine1() string {
	if c == nil {
		return ""
	}
	return c.AddressLine1
}

func (c *CheckRequest) GetAddressLine2() *string {
	if c == nil {
		return nil
	}
	return c.AddressLine2
}

func (c *CheckRequest) GetCity() string {
	if c == nil {
		return ""
	}
	return c.City
}

func (c *CheckRequest) GetStateOrProvince() string {
	if c == nil {
		return ""
	}
	return c.StateOrProvince
}

func (c *CheckRequest) GetPostalCode() string {
	if c == nil {
		return ""
	}
	return c.PostalCode
}

func (c *CheckRequest) GetCountry() string {
	if c == nil {
		return ""
	}
	return c.Country
}

func (c *CheckRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`
	PayToTheOrderOf   string    `json:"payToTheOrderOf" url:"payToTheOrderOf"`
	AddressLine1      string    `json:"addressLine1" url:"addressLine1"`
	AddressLine2      *string   `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	City              string    `json:"city" url:"city"`
	StateOrProvince   string    `json:"stateOrProvince" url:"stateOrProvince"`
	PostalCode        string    `json:"postalCode" url:"postalCode"`
	Country           string    `json:"country" url:"country"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckResponse) GetID() PaymentMethodID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CheckResponse) GetIsDefaultSource() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultSource
}

func (c *CheckResponse) GetIsDefaultDestination() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultDestination
}

func (c *CheckResponse) GetSupportedCurrencies() []CurrencyCode {
	if c == nil {
		return nil
	}
	return c.SupportedCurrencies
}

func (c *CheckResponse) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CheckResponse) GetFrozen() bool {
	if c == nil {
		return false
	}
	return c.Frozen
}

func (c *CheckResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CheckResponse) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CheckResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CheckResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CheckResponse) GetPayToTheOrderOf() string {
	if c == nil {
		return ""
	}
	return c.PayToTheOrderOf
}

func (c *CheckResponse) GetAddressLine1() string {
	if c == nil {
		return ""
	}
	return c.AddressLine1
}

func (c *CheckResponse) GetAddressLine2() *string {
	if c == nil {
		return nil
	}
	return c.AddressLine2
}

func (c *CheckResponse) GetCity() string {
	if c == nil {
		return ""
	}
	return c.City
}

func (c *CheckResponse) GetStateOrProvince() string {
	if c == nil {
		return ""
	}
	return c.StateOrProvince
}

func (c *CheckResponse) GetPostalCode() string {
	if c == nil {
		return ""
	}
	return c.PostalCode
}

func (c *CheckResponse) GetCountry() string {
	if c == nil {
		return ""
	}
	return c.Country
}

func (c *CheckResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckResponse) UnmarshalJSON(data []byte) error {
	type embed CheckResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CheckResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckResponse) MarshalJSON() ([]byte, error) {
	type embed CheckResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CheckResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CurrencyCode string

const (
	CurrencyCodeAed CurrencyCode = "AED"
	CurrencyCodeAfn CurrencyCode = "AFN"
	CurrencyCodeAll CurrencyCode = "ALL"
	CurrencyCodeAmd CurrencyCode = "AMD"
	CurrencyCodeAng CurrencyCode = "ANG"
	CurrencyCodeAoa CurrencyCode = "AOA"
	CurrencyCodeArs CurrencyCode = "ARS"
	CurrencyCodeAud CurrencyCode = "AUD"
	CurrencyCodeAwg CurrencyCode = "AWG"
	CurrencyCodeAzn CurrencyCode = "AZN"
	CurrencyCodeBam CurrencyCode = "BAM"
	CurrencyCodeBbd CurrencyCode = "BBD"
	CurrencyCodeBdt CurrencyCode = "BDT"
	CurrencyCodeBgn CurrencyCode = "BGN"
	CurrencyCodeBhd CurrencyCode = "BHD"
	CurrencyCodeBif CurrencyCode = "BIF"
	CurrencyCodeBmd CurrencyCode = "BMD"
	CurrencyCodeBnd CurrencyCode = "BND"
	CurrencyCodeBob CurrencyCode = "BOB"
	CurrencyCodeBov CurrencyCode = "BOV"
	CurrencyCodeBrl CurrencyCode = "BRL"
	CurrencyCodeBsd CurrencyCode = "BSD"
	CurrencyCodeBtn CurrencyCode = "BTN"
	CurrencyCodeBwp CurrencyCode = "BWP"
	CurrencyCodeByn CurrencyCode = "BYN"
	CurrencyCodeBzd CurrencyCode = "BZD"
	CurrencyCodeCad CurrencyCode = "CAD"
	CurrencyCodeCdf CurrencyCode = "CDF"
	CurrencyCodeChe CurrencyCode = "CHE"
	CurrencyCodeChf CurrencyCode = "CHF"
	CurrencyCodeChw CurrencyCode = "CHW"
	CurrencyCodeClf CurrencyCode = "CLF"
	CurrencyCodeClp CurrencyCode = "CLP"
	CurrencyCodeCop CurrencyCode = "COP"
	CurrencyCodeCou CurrencyCode = "COU"
	CurrencyCodeCrc CurrencyCode = "CRC"
	CurrencyCodeCuc CurrencyCode = "CUC"
	CurrencyCodeCup CurrencyCode = "CUP"
	CurrencyCodeCve CurrencyCode = "CVE"
	CurrencyCodeCzk CurrencyCode = "CZK"
	CurrencyCodeDjf CurrencyCode = "DJF"
	CurrencyCodeDkk CurrencyCode = "DKK"
	CurrencyCodeDop CurrencyCode = "DOP"
	CurrencyCodeDzd CurrencyCode = "DZD"
	CurrencyCodeEgp CurrencyCode = "EGP"
	CurrencyCodeErn CurrencyCode = "ERN"
	CurrencyCodeEtb CurrencyCode = "ETB"
	CurrencyCodeEur CurrencyCode = "EUR"
	CurrencyCodeFjd CurrencyCode = "FJD"
	CurrencyCodeFkp CurrencyCode = "FKP"
	CurrencyCodeGbp CurrencyCode = "GBP"
	CurrencyCodeGel CurrencyCode = "GEL"
	CurrencyCodeGhs CurrencyCode = "GHS"
	CurrencyCodeGip CurrencyCode = "GIP"
	CurrencyCodeGmd CurrencyCode = "GMD"
	CurrencyCodeGnf CurrencyCode = "GNF"
	CurrencyCodeGtq CurrencyCode = "GTQ"
	CurrencyCodeGyd CurrencyCode = "GYD"
	CurrencyCodeHkd CurrencyCode = "HKD"
	CurrencyCodeHnl CurrencyCode = "HNL"
	CurrencyCodeHtg CurrencyCode = "HTG"
	CurrencyCodeHuf CurrencyCode = "HUF"
	CurrencyCodeIdr CurrencyCode = "IDR"
	CurrencyCodeIls CurrencyCode = "ILS"
	CurrencyCodeInr CurrencyCode = "INR"
	CurrencyCodeIqd CurrencyCode = "IQD"
	CurrencyCodeIrr CurrencyCode = "IRR"
	CurrencyCodeIsk CurrencyCode = "ISK"
	CurrencyCodeJmd CurrencyCode = "JMD"
	CurrencyCodeJod CurrencyCode = "JOD"
	CurrencyCodeJpy CurrencyCode = "JPY"
	CurrencyCodeKes CurrencyCode = "KES"
	CurrencyCodeKgs CurrencyCode = "KGS"
	CurrencyCodeKhr CurrencyCode = "KHR"
	CurrencyCodeKmf CurrencyCode = "KMF"
	CurrencyCodeKpw CurrencyCode = "KPW"
	CurrencyCodeKrw CurrencyCode = "KRW"
	CurrencyCodeKwd CurrencyCode = "KWD"
	CurrencyCodeKyd CurrencyCode = "KYD"
	CurrencyCodeKzt CurrencyCode = "KZT"
	CurrencyCodeLak CurrencyCode = "LAK"
	CurrencyCodeLbp CurrencyCode = "LBP"
	CurrencyCodeLkr CurrencyCode = "LKR"
	CurrencyCodeLrd CurrencyCode = "LRD"
	CurrencyCodeLsl CurrencyCode = "LSL"
	CurrencyCodeLyd CurrencyCode = "LYD"
	CurrencyCodeMad CurrencyCode = "MAD"
	CurrencyCodeMdl CurrencyCode = "MDL"
	CurrencyCodeMga CurrencyCode = "MGA"
	CurrencyCodeMkd CurrencyCode = "MKD"
	CurrencyCodeMmk CurrencyCode = "MMK"
	CurrencyCodeMnt CurrencyCode = "MNT"
	CurrencyCodeMop CurrencyCode = "MOP"
	CurrencyCodeMru CurrencyCode = "MRU"
	CurrencyCodeMur CurrencyCode = "MUR"
	CurrencyCodeMvr CurrencyCode = "MVR"
	CurrencyCodeMwk CurrencyCode = "MWK"
	CurrencyCodeMxn CurrencyCode = "MXN"
	CurrencyCodeMxv CurrencyCode = "MXV"
	CurrencyCodeMyr CurrencyCode = "MYR"
	CurrencyCodeMzn CurrencyCode = "MZN"
	CurrencyCodeNad CurrencyCode = "NAD"
	CurrencyCodeNgn CurrencyCode = "NGN"
	CurrencyCodeNio CurrencyCode = "NIO"
	CurrencyCodeNok CurrencyCode = "NOK"
	CurrencyCodeNpr CurrencyCode = "NPR"
	CurrencyCodeNzd CurrencyCode = "NZD"
	CurrencyCodeOmr CurrencyCode = "OMR"
	CurrencyCodePab CurrencyCode = "PAB"
	CurrencyCodePen CurrencyCode = "PEN"
	CurrencyCodePgk CurrencyCode = "PGK"
	CurrencyCodePhp CurrencyCode = "PHP"
	CurrencyCodePkr CurrencyCode = "PKR"
	CurrencyCodePln CurrencyCode = "PLN"
	CurrencyCodePyg CurrencyCode = "PYG"
	CurrencyCodeQar CurrencyCode = "QAR"
	CurrencyCodeRon CurrencyCode = "RON"
	CurrencyCodeRsd CurrencyCode = "RSD"
	CurrencyCodeCny CurrencyCode = "CNY"
	CurrencyCodeRub CurrencyCode = "RUB"
	CurrencyCodeRwf CurrencyCode = "RWF"
	CurrencyCodeSar CurrencyCode = "SAR"
	CurrencyCodeSbd CurrencyCode = "SBD"
	CurrencyCodeScr CurrencyCode = "SCR"
	CurrencyCodeSdg CurrencyCode = "SDG"
	CurrencyCodeSek CurrencyCode = "SEK"
	CurrencyCodeSgd CurrencyCode = "SGD"
	CurrencyCodeShp CurrencyCode = "SHP"
	CurrencyCodeSle CurrencyCode = "SLE"
	CurrencyCodeSll CurrencyCode = "SLL"
	CurrencyCodeSos CurrencyCode = "SOS"
	CurrencyCodeSrd CurrencyCode = "SRD"
	CurrencyCodeSsp CurrencyCode = "SSP"
	CurrencyCodeStn CurrencyCode = "STN"
	CurrencyCodeSvc CurrencyCode = "SVC"
	CurrencyCodeSyp CurrencyCode = "SYP"
	CurrencyCodeSzl CurrencyCode = "SZL"
	CurrencyCodeThb CurrencyCode = "THB"
	CurrencyCodeTjs CurrencyCode = "TJS"
	CurrencyCodeTmt CurrencyCode = "TMT"
	CurrencyCodeTnd CurrencyCode = "TND"
	CurrencyCodeTop CurrencyCode = "TOP"
	CurrencyCodeTry CurrencyCode = "TRY"
	CurrencyCodeTtd CurrencyCode = "TTD"
	CurrencyCodeTwd CurrencyCode = "TWD"
	CurrencyCodeTzs CurrencyCode = "TZS"
	CurrencyCodeUah CurrencyCode = "UAH"
	CurrencyCodeUgx CurrencyCode = "UGX"
	CurrencyCodeUsd CurrencyCode = "USD"
	CurrencyCodeUsn CurrencyCode = "USN"
	CurrencyCodeUyi CurrencyCode = "UYI"
	CurrencyCodeUyu CurrencyCode = "UYU"
	CurrencyCodeUyw CurrencyCode = "UYW"
	CurrencyCodeUzs CurrencyCode = "UZS"
	CurrencyCodeVed CurrencyCode = "VED"
	CurrencyCodeVes CurrencyCode = "VES"
	CurrencyCodeVnd CurrencyCode = "VND"
	CurrencyCodeVuv CurrencyCode = "VUV"
	CurrencyCodeWst CurrencyCode = "WST"
	CurrencyCodeXaf CurrencyCode = "XAF"
	CurrencyCodeXag CurrencyCode = "XAG"
	CurrencyCodeXau CurrencyCode = "XAU"
	CurrencyCodeXba CurrencyCode = "XBA"
	CurrencyCodeXbb CurrencyCode = "XBB"
	CurrencyCodeXbc CurrencyCode = "XBC"
	CurrencyCodeXbd CurrencyCode = "XBD"
	CurrencyCodeXcd CurrencyCode = "XCD"
	CurrencyCodeXdr CurrencyCode = "XDR"
	CurrencyCodeXof CurrencyCode = "XOF"
	CurrencyCodeXpd CurrencyCode = "XPD"
	CurrencyCodeXpf CurrencyCode = "XPF"
	CurrencyCodeXpt CurrencyCode = "XPT"
	CurrencyCodeXsu CurrencyCode = "XSU"
	CurrencyCodeXts CurrencyCode = "XTS"
	CurrencyCodeXua CurrencyCode = "XUA"
	CurrencyCodeXxx CurrencyCode = "XXX"
	CurrencyCodeYer CurrencyCode = "YER"
	CurrencyCodeZar CurrencyCode = "ZAR"
	CurrencyCodeZmw CurrencyCode = "ZMW"
	CurrencyCodeZwl CurrencyCode = "ZWL"
)

func NewCurrencyCodeFromString(s string) (CurrencyCode, error) {
	switch s {
	case "AED":
		return CurrencyCodeAed, nil
	case "AFN":
		return CurrencyCodeAfn, nil
	case "ALL":
		return CurrencyCodeAll, nil
	case "AMD":
		return CurrencyCodeAmd, nil
	case "ANG":
		return CurrencyCodeAng, nil
	case "AOA":
		return CurrencyCodeAoa, nil
	case "ARS":
		return CurrencyCodeArs, nil
	case "AUD":
		return CurrencyCodeAud, nil
	case "AWG":
		return CurrencyCodeAwg, nil
	case "AZN":
		return CurrencyCodeAzn, nil
	case "BAM":
		return CurrencyCodeBam, nil
	case "BBD":
		return CurrencyCodeBbd, nil
	case "BDT":
		return CurrencyCodeBdt, nil
	case "BGN":
		return CurrencyCodeBgn, nil
	case "BHD":
		return CurrencyCodeBhd, nil
	case "BIF":
		return CurrencyCodeBif, nil
	case "BMD":
		return CurrencyCodeBmd, nil
	case "BND":
		return CurrencyCodeBnd, nil
	case "BOB":
		return CurrencyCodeBob, nil
	case "BOV":
		return CurrencyCodeBov, nil
	case "BRL":
		return CurrencyCodeBrl, nil
	case "BSD":
		return CurrencyCodeBsd, nil
	case "BTN":
		return CurrencyCodeBtn, nil
	case "BWP":
		return CurrencyCodeBwp, nil
	case "BYN":
		return CurrencyCodeByn, nil
	case "BZD":
		return CurrencyCodeBzd, nil
	case "CAD":
		return CurrencyCodeCad, nil
	case "CDF":
		return CurrencyCodeCdf, nil
	case "CHE":
		return CurrencyCodeChe, nil
	case "CHF":
		return CurrencyCodeChf, nil
	case "CHW":
		return CurrencyCodeChw, nil
	case "CLF":
		return CurrencyCodeClf, nil
	case "CLP":
		return CurrencyCodeClp, nil
	case "COP":
		return CurrencyCodeCop, nil
	case "COU":
		return CurrencyCodeCou, nil
	case "CRC":
		return CurrencyCodeCrc, nil
	case "CUC":
		return CurrencyCodeCuc, nil
	case "CUP":
		return CurrencyCodeCup, nil
	case "CVE":
		return CurrencyCodeCve, nil
	case "CZK":
		return CurrencyCodeCzk, nil
	case "DJF":
		return CurrencyCodeDjf, nil
	case "DKK":
		return CurrencyCodeDkk, nil
	case "DOP":
		return CurrencyCodeDop, nil
	case "DZD":
		return CurrencyCodeDzd, nil
	case "EGP":
		return CurrencyCodeEgp, nil
	case "ERN":
		return CurrencyCodeErn, nil
	case "ETB":
		return CurrencyCodeEtb, nil
	case "EUR":
		return CurrencyCodeEur, nil
	case "FJD":
		return CurrencyCodeFjd, nil
	case "FKP":
		return CurrencyCodeFkp, nil
	case "GBP":
		return CurrencyCodeGbp, nil
	case "GEL":
		return CurrencyCodeGel, nil
	case "GHS":
		return CurrencyCodeGhs, nil
	case "GIP":
		return CurrencyCodeGip, nil
	case "GMD":
		return CurrencyCodeGmd, nil
	case "GNF":
		return CurrencyCodeGnf, nil
	case "GTQ":
		return CurrencyCodeGtq, nil
	case "GYD":
		return CurrencyCodeGyd, nil
	case "HKD":
		return CurrencyCodeHkd, nil
	case "HNL":
		return CurrencyCodeHnl, nil
	case "HTG":
		return CurrencyCodeHtg, nil
	case "HUF":
		return CurrencyCodeHuf, nil
	case "IDR":
		return CurrencyCodeIdr, nil
	case "ILS":
		return CurrencyCodeIls, nil
	case "INR":
		return CurrencyCodeInr, nil
	case "IQD":
		return CurrencyCodeIqd, nil
	case "IRR":
		return CurrencyCodeIrr, nil
	case "ISK":
		return CurrencyCodeIsk, nil
	case "JMD":
		return CurrencyCodeJmd, nil
	case "JOD":
		return CurrencyCodeJod, nil
	case "JPY":
		return CurrencyCodeJpy, nil
	case "KES":
		return CurrencyCodeKes, nil
	case "KGS":
		return CurrencyCodeKgs, nil
	case "KHR":
		return CurrencyCodeKhr, nil
	case "KMF":
		return CurrencyCodeKmf, nil
	case "KPW":
		return CurrencyCodeKpw, nil
	case "KRW":
		return CurrencyCodeKrw, nil
	case "KWD":
		return CurrencyCodeKwd, nil
	case "KYD":
		return CurrencyCodeKyd, nil
	case "KZT":
		return CurrencyCodeKzt, nil
	case "LAK":
		return CurrencyCodeLak, nil
	case "LBP":
		return CurrencyCodeLbp, nil
	case "LKR":
		return CurrencyCodeLkr, nil
	case "LRD":
		return CurrencyCodeLrd, nil
	case "LSL":
		return CurrencyCodeLsl, nil
	case "LYD":
		return CurrencyCodeLyd, nil
	case "MAD":
		return CurrencyCodeMad, nil
	case "MDL":
		return CurrencyCodeMdl, nil
	case "MGA":
		return CurrencyCodeMga, nil
	case "MKD":
		return CurrencyCodeMkd, nil
	case "MMK":
		return CurrencyCodeMmk, nil
	case "MNT":
		return CurrencyCodeMnt, nil
	case "MOP":
		return CurrencyCodeMop, nil
	case "MRU":
		return CurrencyCodeMru, nil
	case "MUR":
		return CurrencyCodeMur, nil
	case "MVR":
		return CurrencyCodeMvr, nil
	case "MWK":
		return CurrencyCodeMwk, nil
	case "MXN":
		return CurrencyCodeMxn, nil
	case "MXV":
		return CurrencyCodeMxv, nil
	case "MYR":
		return CurrencyCodeMyr, nil
	case "MZN":
		return CurrencyCodeMzn, nil
	case "NAD":
		return CurrencyCodeNad, nil
	case "NGN":
		return CurrencyCodeNgn, nil
	case "NIO":
		return CurrencyCodeNio, nil
	case "NOK":
		return CurrencyCodeNok, nil
	case "NPR":
		return CurrencyCodeNpr, nil
	case "NZD":
		return CurrencyCodeNzd, nil
	case "OMR":
		return CurrencyCodeOmr, nil
	case "PAB":
		return CurrencyCodePab, nil
	case "PEN":
		return CurrencyCodePen, nil
	case "PGK":
		return CurrencyCodePgk, nil
	case "PHP":
		return CurrencyCodePhp, nil
	case "PKR":
		return CurrencyCodePkr, nil
	case "PLN":
		return CurrencyCodePln, nil
	case "PYG":
		return CurrencyCodePyg, nil
	case "QAR":
		return CurrencyCodeQar, nil
	case "RON":
		return CurrencyCodeRon, nil
	case "RSD":
		return CurrencyCodeRsd, nil
	case "CNY":
		return CurrencyCodeCny, nil
	case "RUB":
		return CurrencyCodeRub, nil
	case "RWF":
		return CurrencyCodeRwf, nil
	case "SAR":
		return CurrencyCodeSar, nil
	case "SBD":
		return CurrencyCodeSbd, nil
	case "SCR":
		return CurrencyCodeScr, nil
	case "SDG":
		return CurrencyCodeSdg, nil
	case "SEK":
		return CurrencyCodeSek, nil
	case "SGD":
		return CurrencyCodeSgd, nil
	case "SHP":
		return CurrencyCodeShp, nil
	case "SLE":
		return CurrencyCodeSle, nil
	case "SLL":
		return CurrencyCodeSll, nil
	case "SOS":
		return CurrencyCodeSos, nil
	case "SRD":
		return CurrencyCodeSrd, nil
	case "SSP":
		return CurrencyCodeSsp, nil
	case "STN":
		return CurrencyCodeStn, nil
	case "SVC":
		return CurrencyCodeSvc, nil
	case "SYP":
		return CurrencyCodeSyp, nil
	case "SZL":
		return CurrencyCodeSzl, nil
	case "THB":
		return CurrencyCodeThb, nil
	case "TJS":
		return CurrencyCodeTjs, nil
	case "TMT":
		return CurrencyCodeTmt, nil
	case "TND":
		return CurrencyCodeTnd, nil
	case "TOP":
		return CurrencyCodeTop, nil
	case "TRY":
		return CurrencyCodeTry, nil
	case "TTD":
		return CurrencyCodeTtd, nil
	case "TWD":
		return CurrencyCodeTwd, nil
	case "TZS":
		return CurrencyCodeTzs, nil
	case "UAH":
		return CurrencyCodeUah, nil
	case "UGX":
		return CurrencyCodeUgx, nil
	case "USD":
		return CurrencyCodeUsd, nil
	case "USN":
		return CurrencyCodeUsn, nil
	case "UYI":
		return CurrencyCodeUyi, nil
	case "UYU":
		return CurrencyCodeUyu, nil
	case "UYW":
		return CurrencyCodeUyw, nil
	case "UZS":
		return CurrencyCodeUzs, nil
	case "VED":
		return CurrencyCodeVed, nil
	case "VES":
		return CurrencyCodeVes, nil
	case "VND":
		return CurrencyCodeVnd, nil
	case "VUV":
		return CurrencyCodeVuv, nil
	case "WST":
		return CurrencyCodeWst, nil
	case "XAF":
		return CurrencyCodeXaf, nil
	case "XAG":
		return CurrencyCodeXag, nil
	case "XAU":
		return CurrencyCodeXau, nil
	case "XBA":
		return CurrencyCodeXba, nil
	case "XBB":
		return CurrencyCodeXbb, nil
	case "XBC":
		return CurrencyCodeXbc, nil
	case "XBD":
		return CurrencyCodeXbd, nil
	case "XCD":
		return CurrencyCodeXcd, nil
	case "XDR":
		return CurrencyCodeXdr, nil
	case "XOF":
		return CurrencyCodeXof, nil
	case "XPD":
		return CurrencyCodeXpd, nil
	case "XPF":
		return CurrencyCodeXpf, nil
	case "XPT":
		return CurrencyCodeXpt, nil
	case "XSU":
		return CurrencyCodeXsu, nil
	case "XTS":
		return CurrencyCodeXts, nil
	case "XUA":
		return CurrencyCodeXua, nil
	case "XXX":
		return CurrencyCodeXxx, nil
	case "YER":
		return CurrencyCodeYer, nil
	case "ZAR":
		return CurrencyCodeZar, nil
	case "ZMW":
		return CurrencyCodeZmw, nil
	case "ZWL":
		return CurrencyCodeZwl, nil
	}
	var t CurrencyCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CurrencyCode) Ptr() *CurrencyCode {
	return &c
}

type CustomPaymentMethodRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID `json:"schemaId" url:"schemaId"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodRequest) GetDefaultSource() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultSource
}

func (c *CustomPaymentMethodRequest) GetDefaultDestination() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultDestination
}

func (c *CustomPaymentMethodRequest) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CustomPaymentMethodRequest) GetFrozen() *bool {
	if c == nil {
		return nil
	}
	return c.Frozen
}

func (c *CustomPaymentMethodRequest) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CustomPaymentMethodRequest) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CustomPaymentMethodRequest) GetForeignID() *string {
	if c == nil {
		return nil
	}
	return c.ForeignID
}

func (c *CustomPaymentMethodRequest) GetAccountName() *string {
	if c == nil {
		return nil
	}
	return c.AccountName
}

func (c *CustomPaymentMethodRequest) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CustomPaymentMethodRequest) GetAvailableBalance() *float64 {
	if c == nil {
		return nil
	}
	return c.AvailableBalance
}

func (c *CustomPaymentMethodRequest) GetSchemaID() CustomPaymentMethodSchemaID {
	if c == nil {
		return ""
	}
	return c.SchemaID
}

func (c *CustomPaymentMethodRequest) GetData() map[string]string {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomPaymentMethodRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID CustomPaymentMethodSchemaID        `json:"schemaId" url:"schemaId"`
	Schema   *CustomPaymentMethodSchemaResponse `json:"schema" url:"schema"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodResponse) GetID() PaymentMethodID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CustomPaymentMethodResponse) GetIsDefaultSource() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultSource
}

func (c *CustomPaymentMethodResponse) GetIsDefaultDestination() bool {
	if c == nil {
		return false
	}
	return c.IsDefaultDestination
}

func (c *CustomPaymentMethodResponse) GetSupportedCurrencies() []CurrencyCode {
	if c == nil {
		return nil
	}
	return c.SupportedCurrencies
}

func (c *CustomPaymentMethodResponse) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CustomPaymentMethodResponse) GetFrozen() bool {
	if c == nil {
		return false
	}
	return c.Frozen
}

func (c *CustomPaymentMethodResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CustomPaymentMethodResponse) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CustomPaymentMethodResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CustomPaymentMethodResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CustomPaymentMethodResponse) GetForeignID() *string {
	if c == nil {
		return nil
	}
	return c.ForeignID
}

func (c *CustomPaymentMethodResponse) GetAccountName() *string {
	if c == nil {
		return nil
	}
	return c.AccountName
}

func (c *CustomPaymentMethodResponse) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CustomPaymentMethodResponse) GetAvailableBalance() *float64 {
	if c == nil {
		return nil
	}
	return c.AvailableBalance
}

func (c *CustomPaymentMethodResponse) GetSchemaID() CustomPaymentMethodSchemaID {
	if c == nil {
		return ""
	}
	return c.SchemaID
}

func (c *CustomPaymentMethodResponse) GetSchema() *CustomPaymentMethodSchemaResponse {
	if c == nil {
		return nil
	}
	return c.Schema
}

func (c *CustomPaymentMethodResponse) GetData() map[string]string {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaField struct {
	Name        string                             `json:"name" url:"name"`
	DisplayName *string                            `json:"displayName,omitempty" url:"displayName,omitempty"`
	Type        CustomPaymentMethodSchemaFieldType `json:"type" url:"type"`
	// Indicates whether this field is optional
	Optional bool `json:"optional" url:"optional"`
	// Indicates whether this field should be used as the name of the payment method. Only one field can be used as the name. Will set the accountName field of the payment method to the value of this field.
	UseAsAccountName *bool `json:"useAsAccountName,omitempty" url:"useAsAccountName,omitempty"`
	// Indicates whether this field should be used as the account number of the payment method. Only one field can be used as the account number. Will set the accountNumber field of the payment method to the value of this field.
	UseAsAccountNumber *bool `json:"useAsAccountNumber,omitempty" url:"useAsAccountNumber,omitempty"`
	// When type is 'select', provide options that can be selected
	Options []string `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodSchemaField) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CustomPaymentMethodSchemaField) GetDisplayName() *string {
	if c == nil {
		return nil
	}
	return c.DisplayName
}

func (c *CustomPaymentMethodSchemaField) GetType() CustomPaymentMethodSchemaFieldType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CustomPaymentMethodSchemaField) GetOptional() bool {
	if c == nil {
		return false
	}
	return c.Optional
}

func (c *CustomPaymentMethodSchemaField) GetUseAsAccountName() *bool {
	if c == nil {
		return nil
	}
	return c.UseAsAccountName
}

func (c *CustomPaymentMethodSchemaField) GetUseAsAccountNumber() *bool {
	if c == nil {
		return nil
	}
	return c.UseAsAccountNumber
}

func (c *CustomPaymentMethodSchemaField) GetOptions() []string {
	if c == nil {
		return nil
	}
	return c.Options
}

func (c *CustomPaymentMethodSchemaField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaField) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaFieldType string

const (
	CustomPaymentMethodSchemaFieldTypeText                CustomPaymentMethodSchemaFieldType = "text"
	CustomPaymentMethodSchemaFieldTypeNumber              CustomPaymentMethodSchemaFieldType = "number"
	CustomPaymentMethodSchemaFieldTypeSelect              CustomPaymentMethodSchemaFieldType = "select"
	CustomPaymentMethodSchemaFieldTypeDate                CustomPaymentMethodSchemaFieldType = "date"
	CustomPaymentMethodSchemaFieldTypePhone               CustomPaymentMethodSchemaFieldType = "phone"
	CustomPaymentMethodSchemaFieldTypeEmail               CustomPaymentMethodSchemaFieldType = "email"
	CustomPaymentMethodSchemaFieldTypeURL                 CustomPaymentMethodSchemaFieldType = "url"
	CustomPaymentMethodSchemaFieldTypeDynamicURL          CustomPaymentMethodSchemaFieldType = "dynamicUrl"
	CustomPaymentMethodSchemaFieldTypeEmbeddedURL         CustomPaymentMethodSchemaFieldType = "embeddedUrl"
	CustomPaymentMethodSchemaFieldTypeAddress             CustomPaymentMethodSchemaFieldType = "address"
	CustomPaymentMethodSchemaFieldTypeUsBankRoutingNumber CustomPaymentMethodSchemaFieldType = "usBankRoutingNumber"
	CustomPaymentMethodSchemaFieldTypeUsBankAccountNumber CustomPaymentMethodSchemaFieldType = "usBankAccountNumber"
)

func NewCustomPaymentMethodSchemaFieldTypeFromString(s string) (CustomPaymentMethodSchemaFieldType, error) {
	switch s {
	case "text":
		return CustomPaymentMethodSchemaFieldTypeText, nil
	case "number":
		return CustomPaymentMethodSchemaFieldTypeNumber, nil
	case "select":
		return CustomPaymentMethodSchemaFieldTypeSelect, nil
	case "date":
		return CustomPaymentMethodSchemaFieldTypeDate, nil
	case "phone":
		return CustomPaymentMethodSchemaFieldTypePhone, nil
	case "email":
		return CustomPaymentMethodSchemaFieldTypeEmail, nil
	case "url":
		return CustomPaymentMethodSchemaFieldTypeURL, nil
	case "dynamicUrl":
		return CustomPaymentMethodSchemaFieldTypeDynamicURL, nil
	case "embeddedUrl":
		return CustomPaymentMethodSchemaFieldTypeEmbeddedURL, nil
	case "address":
		return CustomPaymentMethodSchemaFieldTypeAddress, nil
	case "usBankRoutingNumber":
		return CustomPaymentMethodSchemaFieldTypeUsBankRoutingNumber, nil
	case "usBankAccountNumber":
		return CustomPaymentMethodSchemaFieldTypeUsBankAccountNumber, nil
	}
	var t CustomPaymentMethodSchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomPaymentMethodSchemaFieldType) Ptr() *CustomPaymentMethodSchemaFieldType {
	return &c
}

type CustomPaymentMethodSchemaID = string

type CustomPaymentMethodSchemaRequest struct {
	Name string `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports. If not provided, the payment method will support only USD.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies,omitempty" url:"supportedCurrencies,omitempty"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields" url:"fields"`
	// Estimated time in days for this payment method to process a payments. Set as 0 for same-day payment methods, -1 for unknown processing time.
	EstimatedProcessingTime *int `json:"estimatedProcessingTime,omitempty" url:"estimatedProcessingTime,omitempty"`
	// The maximum amount that can be transferred from this payment method in a single transaction.
	MaxAmount *float64 `json:"maxAmount,omitempty" url:"maxAmount,omitempty"`
	// The minimum amount that can be transferred from this payment method in a single transaction. Default is 1.
	MinAmount *float64 `json:"minAmount,omitempty" url:"minAmount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodSchemaRequest) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CustomPaymentMethodSchemaRequest) GetIsSource() bool {
	if c == nil {
		return false
	}
	return c.IsSource
}

func (c *CustomPaymentMethodSchemaRequest) GetIsDestination() bool {
	if c == nil {
		return false
	}
	return c.IsDestination
}

func (c *CustomPaymentMethodSchemaRequest) GetSupportedCurrencies() []CurrencyCode {
	if c == nil {
		return nil
	}
	return c.SupportedCurrencies
}

func (c *CustomPaymentMethodSchemaRequest) GetFields() []*CustomPaymentMethodSchemaField {
	if c == nil {
		return nil
	}
	return c.Fields
}

func (c *CustomPaymentMethodSchemaRequest) GetEstimatedProcessingTime() *int {
	if c == nil {
		return nil
	}
	return c.EstimatedProcessingTime
}

func (c *CustomPaymentMethodSchemaRequest) GetMaxAmount() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxAmount
}

func (c *CustomPaymentMethodSchemaRequest) GetMinAmount() *float64 {
	if c == nil {
		return nil
	}
	return c.MinAmount
}

func (c *CustomPaymentMethodSchemaRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodSchemaRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodSchemaResponse struct {
	ID   CustomPaymentMethodSchemaID `json:"id" url:"id"`
	Name string                      `json:"name" url:"name"`
	// This payment method can be used as a payment source for an invoice
	IsSource bool `json:"isSource" url:"isSource"`
	// This payment method can be used as a payment destination for an invoice
	IsDestination bool `json:"isDestination" url:"isDestination"`
	// List of currencies that this payment method supports.
	SupportedCurrencies []CurrencyCode                    `json:"supportedCurrencies" url:"supportedCurrencies"`
	Fields              []*CustomPaymentMethodSchemaField `json:"fields" url:"fields"`
	// Estimated time in days for this payment method to process a payments. 0 is an same-day payment methods, -1 is unknown processing time.
	EstimatedProcessingTime int `json:"estimatedProcessingTime" url:"estimatedProcessingTime"`
	// The maximum amount that can be transferred from this payment method in a single transaction.
	MaxAmount *float64 `json:"maxAmount,omitempty" url:"maxAmount,omitempty"`
	// The minimum amount that can be transferred from this payment method in a single transaction. Default is 1.
	MinAmount *float64  `json:"minAmount,omitempty" url:"minAmount,omitempty"`
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodSchemaResponse) GetID() CustomPaymentMethodSchemaID {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CustomPaymentMethodSchemaResponse) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CustomPaymentMethodSchemaResponse) GetIsSource() bool {
	if c == nil {
		return false
	}
	return c.IsSource
}

func (c *CustomPaymentMethodSchemaResponse) GetIsDestination() bool {
	if c == nil {
		return false
	}
	return c.IsDestination
}

func (c *CustomPaymentMethodSchemaResponse) GetSupportedCurrencies() []CurrencyCode {
	if c == nil {
		return nil
	}
	return c.SupportedCurrencies
}

func (c *CustomPaymentMethodSchemaResponse) GetFields() []*CustomPaymentMethodSchemaField {
	if c == nil {
		return nil
	}
	return c.Fields
}

func (c *CustomPaymentMethodSchemaResponse) GetEstimatedProcessingTime() int {
	if c == nil {
		return 0
	}
	return c.EstimatedProcessingTime
}

func (c *CustomPaymentMethodSchemaResponse) GetMaxAmount() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxAmount
}

func (c *CustomPaymentMethodSchemaResponse) GetMinAmount() *float64 {
	if c == nil {
		return nil
	}
	return c.MinAmount
}

func (c *CustomPaymentMethodSchemaResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CustomPaymentMethodSchemaResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CustomPaymentMethodSchemaResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodSchemaResponse) UnmarshalJSON(data []byte) error {
	type embed CustomPaymentMethodSchemaResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CustomPaymentMethodSchemaResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodSchemaResponse) MarshalJSON() ([]byte, error) {
	type embed CustomPaymentMethodSchemaResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CustomPaymentMethodSchemaResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentMethodUpdateRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	// ID for this payment method in your system
	ForeignID     *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	AccountName   *string `json:"accountName,omitempty" url:"accountName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty" url:"accountNumber,omitempty"`
	// The available balance for this payment method.
	AvailableBalance *float64 `json:"availableBalance,omitempty" url:"availableBalance,omitempty"`
	// Payment method schema used for this payment method. Defines the fields that this payment method contains.
	SchemaID *CustomPaymentMethodSchemaID `json:"schemaId,omitempty" url:"schemaId,omitempty"`
	// Object of key/value pairs that matches the keys in the linked payment method schema.
	Data map[string]string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentMethodUpdateRequest) GetDefaultSource() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultSource
}

func (c *CustomPaymentMethodUpdateRequest) GetDefaultDestination() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultDestination
}

func (c *CustomPaymentMethodUpdateRequest) GetExternalAccountingSystemID() *string {
	if c == nil {
		return nil
	}
	return c.ExternalAccountingSystemID
}

func (c *CustomPaymentMethodUpdateRequest) GetFrozen() *bool {
	if c == nil {
		return nil
	}
	return c.Frozen
}

func (c *CustomPaymentMethodUpdateRequest) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CustomPaymentMethodUpdateRequest) GetConfirmedByEntity() *bool {
	if c == nil {
		return nil
	}
	return c.ConfirmedByEntity
}

func (c *CustomPaymentMethodUpdateRequest) GetForeignID() *string {
	if c == nil {
		return nil
	}
	return c.ForeignID
}

func (c *CustomPaymentMethodUpdateRequest) GetAccountName() *string {
	if c == nil {
		return nil
	}
	return c.AccountName
}

func (c *CustomPaymentMethodUpdateRequest) GetAccountNumber() *string {
	if c == nil {
		return nil
	}
	return c.AccountNumber
}

func (c *CustomPaymentMethodUpdateRequest) GetAvailableBalance() *float64 {
	if c == nil {
		return nil
	}
	return c.AvailableBalance
}

func (c *CustomPaymentMethodUpdateRequest) GetSchemaID() *CustomPaymentMethodSchemaID {
	if c == nil {
		return nil
	}
	return c.SchemaID
}

func (c *CustomPaymentMethodUpdateRequest) GetData() map[string]string {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomPaymentMethodUpdateRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentMethodUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentMethodUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentMethodUpdateRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type PaymentMethodBaseRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodBaseRequest) GetDefaultSource() *bool {
	if p == nil {
		return nil
	}
	return p.DefaultSource
}

func (p *PaymentMethodBaseRequest) GetDefaultDestination() *bool {
	if p == nil {
		return nil
	}
	return p.DefaultDestination
}

func (p *PaymentMethodBaseRequest) GetExternalAccountingSystemID() *string {
	if p == nil {
		return nil
	}
	return p.ExternalAccountingSystemID
}

func (p *PaymentMethodBaseRequest) GetFrozen() *bool {
	if p == nil {
		return nil
	}
	return p.Frozen
}

func (p *PaymentMethodBaseRequest) GetMetadata() map[string]string {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *PaymentMethodBaseRequest) GetConfirmedByEntity() *bool {
	if p == nil {
		return nil
	}
	return p.ConfirmedByEntity
}

func (p *PaymentMethodBaseRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodBaseRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodBaseResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodBaseResponse) GetID() PaymentMethodID {
	if p == nil {
		return ""
	}
	return p.ID
}

func (p *PaymentMethodBaseResponse) GetIsDefaultSource() bool {
	if p == nil {
		return false
	}
	return p.IsDefaultSource
}

func (p *PaymentMethodBaseResponse) GetIsDefaultDestination() bool {
	if p == nil {
		return false
	}
	return p.IsDefaultDestination
}

func (p *PaymentMethodBaseResponse) GetSupportedCurrencies() []CurrencyCode {
	if p == nil {
		return nil
	}
	return p.SupportedCurrencies
}

func (p *PaymentMethodBaseResponse) GetExternalAccountingSystemID() *string {
	if p == nil {
		return nil
	}
	return p.ExternalAccountingSystemID
}

func (p *PaymentMethodBaseResponse) GetFrozen() bool {
	if p == nil {
		return false
	}
	return p.Frozen
}

func (p *PaymentMethodBaseResponse) GetMetadata() map[string]string {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *PaymentMethodBaseResponse) GetConfirmedByEntity() *bool {
	if p == nil {
		return nil
	}
	return p.ConfirmedByEntity
}

func (p *PaymentMethodBaseResponse) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PaymentMethodBaseResponse) GetUpdatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.UpdatedAt
}

func (p *PaymentMethodBaseResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodBaseResponse) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodBaseResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodBaseResponse(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	p.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodBaseResponse) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodBaseResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
		UpdatedAt: internal.NewDateTime(p.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodBaseResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodEvent struct {
	// The ID of the event
	ID PaymentMethodEventID `json:"id" url:"id"`
	// The payment method data at the time of the event
	Data *PaymentMethodResponse `json:"data" url:"data"`
	// The list of webhook IDs associated with this event
	WebhookIDs []string `json:"webhookIds" url:"webhookIds"`
	// The ID of the user who triggered the event
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`
	// The ID of the entity that updated the payment method
	UpdatedByEntityID *EntityID `json:"updatedByEntityId,omitempty" url:"updatedByEntityId,omitempty"`
	// The timestamp when the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodEvent) GetID() PaymentMethodEventID {
	if p == nil {
		return ""
	}
	return p.ID
}

func (p *PaymentMethodEvent) GetData() *PaymentMethodResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentMethodEvent) GetWebhookIDs() []string {
	if p == nil {
		return nil
	}
	return p.WebhookIDs
}

func (p *PaymentMethodEvent) GetUserID() *EntityUserID {
	if p == nil {
		return nil
	}
	return p.UserID
}

func (p *PaymentMethodEvent) GetUpdatedByEntityID() *EntityID {
	if p == nil {
		return nil
	}
	return p.UpdatedByEntityID
}

func (p *PaymentMethodEvent) GetCreatedAt() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.CreatedAt
}

func (p *PaymentMethodEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodEvent) UnmarshalJSON(data []byte) error {
	type embed PaymentMethodEvent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentMethodEvent(unmarshaler.embed)
	p.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodEvent) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodEvent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*p),
		CreatedAt: internal.NewDateTime(p.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (p *PaymentMethodEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodEventID = string

type PaymentMethodEventsResponse struct {
	// The list of events
	Data []*PaymentMethodEvent `json:"data" url:"data"`
	// The total number of events
	Count int `json:"count" url:"count"`
	// Whether there are more events to fetch
	HasMore bool `json:"hasMore" url:"hasMore"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodEventsResponse) GetData() []*PaymentMethodEvent {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentMethodEventsResponse) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PaymentMethodEventsResponse) GetHasMore() bool {
	if p == nil {
		return false
	}
	return p.HasMore
}

func (p *PaymentMethodEventsResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodEventsResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodID = string

type PaymentMethodRequest struct {
	Type        string
	BankAccount *BankAccountRequest
	Card        *CardRequest
	Check       *CheckRequest
	Custom      *CustomPaymentMethodRequest
	OffPlatform *PaymentMethodBaseRequest
	Utility     *UtilityPaymentMethodRequest
	Wallet      *PaymentMethodBaseRequest
}

func (p *PaymentMethodRequest) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentMethodRequest) GetBankAccount() *BankAccountRequest {
	if p == nil {
		return nil
	}
	return p.BankAccount
}

func (p *PaymentMethodRequest) GetCard() *CardRequest {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PaymentMethodRequest) GetCheck() *CheckRequest {
	if p == nil {
		return nil
	}
	return p.Check
}

func (p *PaymentMethodRequest) GetCustom() *CustomPaymentMethodRequest {
	if p == nil {
		return nil
	}
	return p.Custom
}

func (p *PaymentMethodRequest) GetOffPlatform() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.OffPlatform
}

func (p *PaymentMethodRequest) GetUtility() *UtilityPaymentMethodRequest {
	if p == nil {
		return nil
	}
	return p.Utility
}

func (p *PaymentMethodRequest) GetWallet() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.Wallet
}

func (p *PaymentMethodRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(UtilityPaymentMethodRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	case "wallet":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Wallet = value
	}
	return nil
}

func (p PaymentMethodRequest) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.BankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return internal.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return internal.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return internal.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return internal.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	if p.Wallet != nil {
		return internal.MarshalJSONWithExtraProperty(p.Wallet, "type", "wallet")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodRequestVisitor interface {
	VisitBankAccount(*BankAccountRequest) error
	VisitCard(*CardRequest) error
	VisitCheck(*CheckRequest) error
	VisitCustom(*CustomPaymentMethodRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
	VisitUtility(*UtilityPaymentMethodRequest) error
	VisitWallet(*PaymentMethodBaseRequest) error
}

func (p *PaymentMethodRequest) Accept(visitor PaymentMethodRequestVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	if p.Wallet != nil {
		return visitor.VisitWallet(p.Wallet)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentMethodRequest) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.BankAccount != nil {
		fields = append(fields, "bankAccount")
	}
	if p.Card != nil {
		fields = append(fields, "card")
	}
	if p.Check != nil {
		fields = append(fields, "check")
	}
	if p.Custom != nil {
		fields = append(fields, "custom")
	}
	if p.OffPlatform != nil {
		fields = append(fields, "offPlatform")
	}
	if p.Utility != nil {
		fields = append(fields, "utility")
	}
	if p.Wallet != nil {
		fields = append(fields, "wallet")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentMethodResponse struct {
	Type        string
	BankAccount *BankAccountResponse
	Card        *CardResponse
	Check       *CheckResponse
	Custom      *CustomPaymentMethodResponse
	OffPlatform *PaymentMethodBaseResponse
	Utility     *UtilityPaymentMethodResponse
	Wallet      *WalletResponse
}

func (p *PaymentMethodResponse) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentMethodResponse) GetBankAccount() *BankAccountResponse {
	if p == nil {
		return nil
	}
	return p.BankAccount
}

func (p *PaymentMethodResponse) GetCard() *CardResponse {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PaymentMethodResponse) GetCheck() *CheckResponse {
	if p == nil {
		return nil
	}
	return p.Check
}

func (p *PaymentMethodResponse) GetCustom() *CustomPaymentMethodResponse {
	if p == nil {
		return nil
	}
	return p.Custom
}

func (p *PaymentMethodResponse) GetOffPlatform() *PaymentMethodBaseResponse {
	if p == nil {
		return nil
	}
	return p.OffPlatform
}

func (p *PaymentMethodResponse) GetUtility() *UtilityPaymentMethodResponse {
	if p == nil {
		return nil
	}
	return p.Utility
}

func (p *PaymentMethodResponse) GetWallet() *WalletResponse {
	if p == nil {
		return nil
	}
	return p.Wallet
}

func (p *PaymentMethodResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "bankAccount":
		value := new(BankAccountResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(CardResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(CheckResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "custom":
		value := new(CustomPaymentMethodResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "offPlatform":
		value := new(PaymentMethodBaseResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(UtilityPaymentMethodResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	case "wallet":
		value := new(WalletResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Wallet = value
	}
	return nil
}

func (p PaymentMethodResponse) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.BankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return internal.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return internal.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.OffPlatform != nil {
		return internal.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return internal.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	if p.Wallet != nil {
		return internal.MarshalJSONWithExtraProperty(p.Wallet, "type", "wallet")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodResponseVisitor interface {
	VisitBankAccount(*BankAccountResponse) error
	VisitCard(*CardResponse) error
	VisitCheck(*CheckResponse) error
	VisitCustom(*CustomPaymentMethodResponse) error
	VisitOffPlatform(*PaymentMethodBaseResponse) error
	VisitUtility(*UtilityPaymentMethodResponse) error
	VisitWallet(*WalletResponse) error
}

func (p *PaymentMethodResponse) Accept(visitor PaymentMethodResponseVisitor) error {
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	if p.Wallet != nil {
		return visitor.VisitWallet(p.Wallet)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentMethodResponse) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.BankAccount != nil {
		fields = append(fields, "bankAccount")
	}
	if p.Card != nil {
		fields = append(fields, "card")
	}
	if p.Check != nil {
		fields = append(fields, "check")
	}
	if p.Custom != nil {
		fields = append(fields, "custom")
	}
	if p.OffPlatform != nil {
		fields = append(fields, "offPlatform")
	}
	if p.Utility != nil {
		fields = append(fields, "utility")
	}
	if p.Wallet != nil {
		fields = append(fields, "wallet")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentMethodType string

const (
	PaymentMethodTypeCustom      PaymentMethodType = "custom"
	PaymentMethodTypeCheck       PaymentMethodType = "check"
	PaymentMethodTypeBankAccount PaymentMethodType = "bankAccount"
	PaymentMethodTypeNa          PaymentMethodType = "na"
	PaymentMethodTypeCard        PaymentMethodType = "card"
	PaymentMethodTypeBnpl        PaymentMethodType = "bnpl"
	PaymentMethodTypeVirtualCard PaymentMethodType = "virtualCard"
	PaymentMethodTypeOffPlatform PaymentMethodType = "offPlatform"
	PaymentMethodTypeUtility     PaymentMethodType = "utility"
	PaymentMethodTypeWallet      PaymentMethodType = "wallet"
)

func NewPaymentMethodTypeFromString(s string) (PaymentMethodType, error) {
	switch s {
	case "custom":
		return PaymentMethodTypeCustom, nil
	case "check":
		return PaymentMethodTypeCheck, nil
	case "bankAccount":
		return PaymentMethodTypeBankAccount, nil
	case "na":
		return PaymentMethodTypeNa, nil
	case "card":
		return PaymentMethodTypeCard, nil
	case "bnpl":
		return PaymentMethodTypeBnpl, nil
	case "virtualCard":
		return PaymentMethodTypeVirtualCard, nil
	case "offPlatform":
		return PaymentMethodTypeOffPlatform, nil
	case "utility":
		return PaymentMethodTypeUtility, nil
	case "wallet":
		return PaymentMethodTypeWallet, nil
	}
	var t PaymentMethodType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentMethodType) Ptr() *PaymentMethodType {
	return &p
}

// Update a payment method. for non custom payment methods.
type PaymentMethodUpdateRequest struct {
	Type   string
	Custom *CustomPaymentMethodUpdateRequest
	// Only defaultSource, defaultDestination, accountName, and checkOptions can be updated.
	BankAccount *BankAccountUpdateRequest
	// Only defaultSource and defaultDestination can be updated.
	Card *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Check *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	OffPlatform *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Utility *PaymentMethodBaseRequest
	// Only defaultSource and defaultDestination can be updated.
	Wallet *PaymentMethodBaseRequest
}

func (p *PaymentMethodUpdateRequest) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentMethodUpdateRequest) GetCustom() *CustomPaymentMethodUpdateRequest {
	if p == nil {
		return nil
	}
	return p.Custom
}

func (p *PaymentMethodUpdateRequest) GetBankAccount() *BankAccountUpdateRequest {
	if p == nil {
		return nil
	}
	return p.BankAccount
}

func (p *PaymentMethodUpdateRequest) GetCard() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PaymentMethodUpdateRequest) GetCheck() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.Check
}

func (p *PaymentMethodUpdateRequest) GetOffPlatform() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.OffPlatform
}

func (p *PaymentMethodUpdateRequest) GetUtility() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.Utility
}

func (p *PaymentMethodUpdateRequest) GetWallet() *PaymentMethodBaseRequest {
	if p == nil {
		return nil
	}
	return p.Wallet
}

func (p *PaymentMethodUpdateRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "custom":
		value := new(CustomPaymentMethodUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	case "bankAccount":
		value := new(BankAccountUpdateRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "card":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "check":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "offPlatform":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OffPlatform = value
	case "utility":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	case "wallet":
		value := new(PaymentMethodBaseRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Wallet = value
	}
	return nil
}

func (p PaymentMethodUpdateRequest) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	if p.BankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Card != nil {
		return internal.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.Check != nil {
		return internal.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.OffPlatform != nil {
		return internal.MarshalJSONWithExtraProperty(p.OffPlatform, "type", "offPlatform")
	}
	if p.Utility != nil {
		return internal.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	if p.Wallet != nil {
		return internal.MarshalJSONWithExtraProperty(p.Wallet, "type", "wallet")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodUpdateRequestVisitor interface {
	VisitCustom(*CustomPaymentMethodUpdateRequest) error
	VisitBankAccount(*BankAccountUpdateRequest) error
	VisitCard(*PaymentMethodBaseRequest) error
	VisitCheck(*PaymentMethodBaseRequest) error
	VisitOffPlatform(*PaymentMethodBaseRequest) error
	VisitUtility(*PaymentMethodBaseRequest) error
	VisitWallet(*PaymentMethodBaseRequest) error
}

func (p *PaymentMethodUpdateRequest) Accept(visitor PaymentMethodUpdateRequestVisitor) error {
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.OffPlatform != nil {
		return visitor.VisitOffPlatform(p.OffPlatform)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	if p.Wallet != nil {
		return visitor.VisitWallet(p.Wallet)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentMethodUpdateRequest) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Custom != nil {
		fields = append(fields, "custom")
	}
	if p.BankAccount != nil {
		fields = append(fields, "bankAccount")
	}
	if p.Card != nil {
		fields = append(fields, "card")
	}
	if p.Check != nil {
		fields = append(fields, "check")
	}
	if p.OffPlatform != nil {
		fields = append(fields, "offPlatform")
	}
	if p.Utility != nil {
		fields = append(fields, "utility")
	}
	if p.Wallet != nil {
		fields = append(fields, "wallet")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentMethodWithEntityFindResponse struct {
	Count   int                                `json:"count" url:"count"`
	HasMore bool                               `json:"hasMore" url:"hasMore"`
	Data    []*PaymentMethodWithEntityResponse `json:"data" url:"data"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodWithEntityFindResponse) GetCount() int {
	if p == nil {
		return 0
	}
	return p.Count
}

func (p *PaymentMethodWithEntityFindResponse) GetHasMore() bool {
	if p == nil {
		return false
	}
	return p.HasMore
}

func (p *PaymentMethodWithEntityFindResponse) GetData() []*PaymentMethodWithEntityResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentMethodWithEntityFindResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodWithEntityFindResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodWithEntityFindResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodWithEntityFindResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodWithEntityFindResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentMethodWithEntityResponse struct {
	PaymentMethod *PaymentMethodResponse `json:"paymentMethod" url:"paymentMethod"`
	Entity        *EntityResponse        `json:"entity" url:"entity"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodWithEntityResponse) GetPaymentMethod() *PaymentMethodResponse {
	if p == nil {
		return nil
	}
	return p.PaymentMethod
}

func (p *PaymentMethodWithEntityResponse) GetEntity() *EntityResponse {
	if p == nil {
		return nil
	}
	return p.Entity
}

func (p *PaymentMethodWithEntityResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodWithEntityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodWithEntityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodWithEntityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodWithEntityResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidAccessTokenRequest struct {
	// Plaid account ID. If not provided, will try to match the provided routing number and account number.
	AccountID *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Plaid access token for the account. If you already have an access token for the account (for example, you have linked the account to your app already), use this instead of publicToken.
	AccessToken string `json:"accessToken" url:"accessToken"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlaidAccessTokenRequest) GetAccountID() *string {
	if p == nil {
		return nil
	}
	return p.AccountID
}

func (p *PlaidAccessTokenRequest) GetAccessToken() string {
	if p == nil {
		return ""
	}
	return p.AccessToken
}

func (p *PlaidAccessTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidAccessTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidAccessTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidAccessTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidAccessTokenRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidLinkRequest struct {
	PlaidProcessorTokenRequest *PlaidProcessorTokenRequest
	PlaidPublicTokenRequest    *PlaidPublicTokenRequest
	PlaidAccessTokenRequest    *PlaidAccessTokenRequest

	typ string
}

func (p *PlaidLinkRequest) GetPlaidProcessorTokenRequest() *PlaidProcessorTokenRequest {
	if p == nil {
		return nil
	}
	return p.PlaidProcessorTokenRequest
}

func (p *PlaidLinkRequest) GetPlaidPublicTokenRequest() *PlaidPublicTokenRequest {
	if p == nil {
		return nil
	}
	return p.PlaidPublicTokenRequest
}

func (p *PlaidLinkRequest) GetPlaidAccessTokenRequest() *PlaidAccessTokenRequest {
	if p == nil {
		return nil
	}
	return p.PlaidAccessTokenRequest
}

func (p *PlaidLinkRequest) UnmarshalJSON(data []byte) error {
	valuePlaidProcessorTokenRequest := new(PlaidProcessorTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidProcessorTokenRequest); err == nil {
		p.typ = "PlaidProcessorTokenRequest"
		p.PlaidProcessorTokenRequest = valuePlaidProcessorTokenRequest
		return nil
	}
	valuePlaidPublicTokenRequest := new(PlaidPublicTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidPublicTokenRequest); err == nil {
		p.typ = "PlaidPublicTokenRequest"
		p.PlaidPublicTokenRequest = valuePlaidPublicTokenRequest
		return nil
	}
	valuePlaidAccessTokenRequest := new(PlaidAccessTokenRequest)
	if err := json.Unmarshal(data, &valuePlaidAccessTokenRequest); err == nil {
		p.typ = "PlaidAccessTokenRequest"
		p.PlaidAccessTokenRequest = valuePlaidAccessTokenRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PlaidLinkRequest) MarshalJSON() ([]byte, error) {
	if p.typ == "PlaidProcessorTokenRequest" || p.PlaidProcessorTokenRequest != nil {
		return json.Marshal(p.PlaidProcessorTokenRequest)
	}
	if p.typ == "PlaidPublicTokenRequest" || p.PlaidPublicTokenRequest != nil {
		return json.Marshal(p.PlaidPublicTokenRequest)
	}
	if p.typ == "PlaidAccessTokenRequest" || p.PlaidAccessTokenRequest != nil {
		return json.Marshal(p.PlaidAccessTokenRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlaidLinkRequestVisitor interface {
	VisitPlaidProcessorTokenRequest(*PlaidProcessorTokenRequest) error
	VisitPlaidPublicTokenRequest(*PlaidPublicTokenRequest) error
	VisitPlaidAccessTokenRequest(*PlaidAccessTokenRequest) error
}

func (p *PlaidLinkRequest) Accept(visitor PlaidLinkRequestVisitor) error {
	if p.typ == "PlaidProcessorTokenRequest" || p.PlaidProcessorTokenRequest != nil {
		return visitor.VisitPlaidProcessorTokenRequest(p.PlaidProcessorTokenRequest)
	}
	if p.typ == "PlaidPublicTokenRequest" || p.PlaidPublicTokenRequest != nil {
		return visitor.VisitPlaidPublicTokenRequest(p.PlaidPublicTokenRequest)
	}
	if p.typ == "PlaidAccessTokenRequest" || p.PlaidAccessTokenRequest != nil {
		return visitor.VisitPlaidAccessTokenRequest(p.PlaidAccessTokenRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PlaidProcessorTokenRequest struct {
	// Plaid processor token for the account. If you already have a processor token for the account (for example, you have linked the account to your app already), use this instead of publicToken.
	ProcessorToken string `json:"processorToken" url:"processorToken"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlaidProcessorTokenRequest) GetProcessorToken() string {
	if p == nil {
		return ""
	}
	return p.ProcessorToken
}

func (p *PlaidProcessorTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidProcessorTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidProcessorTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidProcessorTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidProcessorTokenRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlaidPublicTokenRequest struct {
	// Plaid account ID. If not provided, will try to match the provided routing number and account number.
	AccountID *string `json:"accountId,omitempty" url:"accountId,omitempty"`
	// Public token received from Plaid Link. Use this if linking the account using the Plaid Link frontend component.
	PublicToken string `json:"publicToken" url:"publicToken"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlaidPublicTokenRequest) GetAccountID() *string {
	if p == nil {
		return nil
	}
	return p.AccountID
}

func (p *PlaidPublicTokenRequest) GetPublicToken() string {
	if p == nil {
		return ""
	}
	return p.PublicToken
}

func (p *PlaidPublicTokenRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlaidPublicTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PlaidPublicTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlaidPublicTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlaidPublicTokenRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UtilityPaymentMethodRequest struct {
	// If true, this payment method will be set as the default source. Only one payment method can be set as the default source. If another payment method is already set as the default source, it will be unset.
	DefaultSource *bool `json:"defaultSource,omitempty" url:"defaultSource,omitempty"`
	// If true, this payment method will be set as the default destination. Only one payment method can be set as the default destination. If another payment method is already set as the default destination, it will be unset.
	DefaultDestination *bool `json:"defaultDestination,omitempty" url:"defaultDestination,omitempty"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// If true, this payment method will be frozen. Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen *bool `json:"frozen,omitempty" url:"frozen,omitempty"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// (ALPHA, MAY BE REMOVED) Indicate whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	// The ID of the utility that this payment method is linked to.
	UtilityID string `json:"utilityId" url:"utilityId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UtilityPaymentMethodRequest) GetDefaultSource() *bool {
	if u == nil {
		return nil
	}
	return u.DefaultSource
}

func (u *UtilityPaymentMethodRequest) GetDefaultDestination() *bool {
	if u == nil {
		return nil
	}
	return u.DefaultDestination
}

func (u *UtilityPaymentMethodRequest) GetExternalAccountingSystemID() *string {
	if u == nil {
		return nil
	}
	return u.ExternalAccountingSystemID
}

func (u *UtilityPaymentMethodRequest) GetFrozen() *bool {
	if u == nil {
		return nil
	}
	return u.Frozen
}

func (u *UtilityPaymentMethodRequest) GetMetadata() map[string]string {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UtilityPaymentMethodRequest) GetConfirmedByEntity() *bool {
	if u == nil {
		return nil
	}
	return u.ConfirmedByEntity
}

func (u *UtilityPaymentMethodRequest) GetUtilityID() string {
	if u == nil {
		return ""
	}
	return u.UtilityID
}

func (u *UtilityPaymentMethodRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentMethodRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilityPaymentMethodRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilityPaymentMethodRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentMethodRequest) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UtilityPaymentMethodResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`
	// The ID of the utility that this payment method is linked to.
	UtilityID string `json:"utilityId" url:"utilityId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UtilityPaymentMethodResponse) GetID() PaymentMethodID {
	if u == nil {
		return ""
	}
	return u.ID
}

func (u *UtilityPaymentMethodResponse) GetIsDefaultSource() bool {
	if u == nil {
		return false
	}
	return u.IsDefaultSource
}

func (u *UtilityPaymentMethodResponse) GetIsDefaultDestination() bool {
	if u == nil {
		return false
	}
	return u.IsDefaultDestination
}

func (u *UtilityPaymentMethodResponse) GetSupportedCurrencies() []CurrencyCode {
	if u == nil {
		return nil
	}
	return u.SupportedCurrencies
}

func (u *UtilityPaymentMethodResponse) GetExternalAccountingSystemID() *string {
	if u == nil {
		return nil
	}
	return u.ExternalAccountingSystemID
}

func (u *UtilityPaymentMethodResponse) GetFrozen() bool {
	if u == nil {
		return false
	}
	return u.Frozen
}

func (u *UtilityPaymentMethodResponse) GetMetadata() map[string]string {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UtilityPaymentMethodResponse) GetConfirmedByEntity() *bool {
	if u == nil {
		return nil
	}
	return u.ConfirmedByEntity
}

func (u *UtilityPaymentMethodResponse) GetCreatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.CreatedAt
}

func (u *UtilityPaymentMethodResponse) GetUpdatedAt() time.Time {
	if u == nil {
		return time.Time{}
	}
	return u.UpdatedAt
}

func (u *UtilityPaymentMethodResponse) GetUtilityID() string {
	if u == nil {
		return ""
	}
	return u.UtilityID
}

func (u *UtilityPaymentMethodResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentMethodResponse) UnmarshalJSON(data []byte) error {
	type embed UtilityPaymentMethodResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UtilityPaymentMethodResponse(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.Time()
	u.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentMethodResponse) MarshalJSON() ([]byte, error) {
	type embed UtilityPaymentMethodResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewDateTime(u.CreatedAt),
		UpdatedAt: internal.NewDateTime(u.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (u *UtilityPaymentMethodResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type WalletBalance struct {
	// The amount in major units of the currency.
	Amount   float64      `json:"amount" url:"amount"`
	Currency CurrencyCode `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WalletBalance) GetAmount() float64 {
	if w == nil {
		return 0
	}
	return w.Amount
}

func (w *WalletBalance) GetCurrency() CurrencyCode {
	if w == nil {
		return ""
	}
	return w.Currency
}

func (w *WalletBalance) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WalletBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler WalletBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WalletBalance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WalletBalance) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WalletBalanceResponse struct {
	// The ID of the wallet payment method.
	PaymentMethodID PaymentMethodID `json:"paymentMethodId" url:"paymentMethodId"`
	// The ID of the entity that this wallet belongs to.
	EntityID EntityID `json:"entityId" url:"entityId"`
	// The available balance in this wallet.
	AvailableBalance *WalletBalance `json:"availableBalance" url:"availableBalance"`
	// The pending balance in this wallet.
	PendingBalance *WalletBalance `json:"pendingBalance" url:"pendingBalance"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WalletBalanceResponse) GetPaymentMethodID() PaymentMethodID {
	if w == nil {
		return ""
	}
	return w.PaymentMethodID
}

func (w *WalletBalanceResponse) GetEntityID() EntityID {
	if w == nil {
		return ""
	}
	return w.EntityID
}

func (w *WalletBalanceResponse) GetAvailableBalance() *WalletBalance {
	if w == nil {
		return nil
	}
	return w.AvailableBalance
}

func (w *WalletBalanceResponse) GetPendingBalance() *WalletBalance {
	if w == nil {
		return nil
	}
	return w.PendingBalance
}

func (w *WalletBalanceResponse) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WalletBalanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler WalletBalanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WalletBalanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WalletBalanceResponse) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WalletResponse struct {
	ID PaymentMethodID `json:"id" url:"id"`
	// Indicates whether this payment method is the default source for the entity
	IsDefaultSource bool `json:"isDefaultSource" url:"isDefaultSource"`
	// Indicates whether this payment method is the default destination for the entity
	IsDefaultDestination bool           `json:"isDefaultDestination" url:"isDefaultDestination"`
	SupportedCurrencies  []CurrencyCode `json:"supportedCurrencies" url:"supportedCurrencies"`
	// ID for this payment method in the external accounting system (e.g Rutter or Codat)
	ExternalAccountingSystemID *string `json:"externalAccountingSystemId,omitempty" url:"externalAccountingSystemId,omitempty"`
	// Frozen payment methods cannot be used for payments, but will still be returned in API responses.
	Frozen bool `json:"frozen" url:"frozen"`
	// Metadata associated with this payment method.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// (ALPHA, MAY BE REMOVED) Indicates whether the payment method has been verified by the entity. This is useful if another entity has added this payment method to this entity, and you want the owner of the payment method to verify it is correct.
	ConfirmedByEntity *bool     `json:"confirmedByEntity,omitempty" url:"confirmedByEntity,omitempty"`
	CreatedAt         time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt" url:"updatedAt"`
	// The balance available for use in this wallet.
	AvailableBalance *WalletBalance `json:"availableBalance" url:"availableBalance"`
	// The in-flight balance into/out of this wallet.
	PendingBalance *WalletBalance `json:"pendingBalance" url:"pendingBalance"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WalletResponse) GetID() PaymentMethodID {
	if w == nil {
		return ""
	}
	return w.ID
}

func (w *WalletResponse) GetIsDefaultSource() bool {
	if w == nil {
		return false
	}
	return w.IsDefaultSource
}

func (w *WalletResponse) GetIsDefaultDestination() bool {
	if w == nil {
		return false
	}
	return w.IsDefaultDestination
}

func (w *WalletResponse) GetSupportedCurrencies() []CurrencyCode {
	if w == nil {
		return nil
	}
	return w.SupportedCurrencies
}

func (w *WalletResponse) GetExternalAccountingSystemID() *string {
	if w == nil {
		return nil
	}
	return w.ExternalAccountingSystemID
}

func (w *WalletResponse) GetFrozen() bool {
	if w == nil {
		return false
	}
	return w.Frozen
}

func (w *WalletResponse) GetMetadata() map[string]string {
	if w == nil {
		return nil
	}
	return w.Metadata
}

func (w *WalletResponse) GetConfirmedByEntity() *bool {
	if w == nil {
		return nil
	}
	return w.ConfirmedByEntity
}

func (w *WalletResponse) GetCreatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.CreatedAt
}

func (w *WalletResponse) GetUpdatedAt() time.Time {
	if w == nil {
		return time.Time{}
	}
	return w.UpdatedAt
}

func (w *WalletResponse) GetAvailableBalance() *WalletBalance {
	if w == nil {
		return nil
	}
	return w.AvailableBalance
}

func (w *WalletResponse) GetPendingBalance() *WalletBalance {
	if w == nil {
		return nil
	}
	return w.PendingBalance
}

func (w *WalletResponse) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WalletResponse) UnmarshalJSON(data []byte) error {
	type embed WalletResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WalletResponse(unmarshaler.embed)
	w.CreatedAt = unmarshaler.CreatedAt.Time()
	w.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WalletResponse) MarshalJSON() ([]byte, error) {
	type embed WalletResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*w),
		CreatedAt: internal.NewDateTime(w.CreatedAt),
		UpdatedAt: internal.NewDateTime(w.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (w *WalletResponse) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
