// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type AddApproverRequest struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID *ApprovalSlotID `json:"approvalSlotId,omitempty" url:"approvalSlotId,omitempty"`
	// The ID or the Foreign ID of the user to add to the approval slot.
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddApproverRequest) GetApprovalSlotID() *ApprovalSlotID {
	if a == nil {
		return nil
	}
	return a.ApprovalSlotID
}

func (a *AddApproverRequest) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *AddApproverRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddApproverRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddApproverRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddApproverRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddApproverRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalRequest struct {
	// Comment associated with this approval action.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID or the Foreign ID of the user
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalRequest) GetText() *string {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *ApprovalRequest) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *ApprovalRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlot struct {
	// The identifier for the upstream policy this slot is associated with.
	UpstreamPolicyID *ApprovalPolicyID `json:"upstreamPolicyId,omitempty" url:"upstreamPolicyId,omitempty"`
	// Whether all upstream policies are approved.
	UpstreamPoliciesApproved *bool `json:"upstreamPoliciesApproved,omitempty" url:"upstreamPoliciesApproved,omitempty"`
	// The identifier for the approval policy this slot is associated with.
	ApprovalPolicyID ApprovalPolicyID `json:"approvalPolicyId" url:"approvalPolicyId"`
	// The identifier for this approval slot
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	// The ID of the user who is assigned to the approval slot. If undefined, the approval slot is assigned to all eligible approvers.
	AssignedUserID  *EntityUserID  `json:"assignedUserId,omitempty" url:"assignedUserId,omitempty"`
	Action          ApproverAction `json:"action" url:"action"`
	EligibleRoles   []string       `json:"eligibleRoles,omitempty" url:"eligibleRoles,omitempty"`
	EligibleUserIDs []EntityUserID `json:"eligibleUserIds,omitempty" url:"eligibleUserIds,omitempty"`
	// Either the date the invoice was created, date the approver was assigned, or date of last action by approver, whichever is latest.
	Date time.Time `json:"date" url:"date"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalSlot) GetUpstreamPolicyID() *ApprovalPolicyID {
	if a == nil {
		return nil
	}
	return a.UpstreamPolicyID
}

func (a *ApprovalSlot) GetUpstreamPoliciesApproved() *bool {
	if a == nil {
		return nil
	}
	return a.UpstreamPoliciesApproved
}

func (a *ApprovalSlot) GetApprovalPolicyID() ApprovalPolicyID {
	if a == nil {
		return ""
	}
	return a.ApprovalPolicyID
}

func (a *ApprovalSlot) GetApprovalSlotID() ApprovalSlotID {
	if a == nil {
		return ""
	}
	return a.ApprovalSlotID
}

func (a *ApprovalSlot) GetAssignedUserID() *EntityUserID {
	if a == nil {
		return nil
	}
	return a.AssignedUserID
}

func (a *ApprovalSlot) GetAction() ApproverAction {
	if a == nil {
		return ""
	}
	return a.Action
}

func (a *ApprovalSlot) GetEligibleRoles() []string {
	if a == nil {
		return nil
	}
	return a.EligibleRoles
}

func (a *ApprovalSlot) GetEligibleUserIDs() []EntityUserID {
	if a == nil {
		return nil
	}
	return a.EligibleUserIDs
}

func (a *ApprovalSlot) GetDate() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.Date
}

func (a *ApprovalSlot) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlot) UnmarshalJSON(data []byte) error {
	type embed ApprovalSlot
	var unmarshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalSlot(unmarshaler.embed)
	a.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlot) MarshalJSON() ([]byte, error) {
	type embed ApprovalSlot
	var marshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*a),
		Date:  internal.NewDateTime(a.Date),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalSlot) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotAssignment struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	// The ID of the user who is assigned to the approval slot. To assign all eligible users to an approval slot, use "ANY".
	AssignedUserID EntityUserID `json:"assignedUserId" url:"assignedUserId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalSlotAssignment) GetApprovalSlotID() ApprovalSlotID {
	if a == nil {
		return ""
	}
	return a.ApprovalSlotID
}

func (a *ApprovalSlotAssignment) GetAssignedUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.AssignedUserID
}

func (a *ApprovalSlotAssignment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlotAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalSlotAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalSlotAssignment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlotAssignment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotID = string

type ApproverAction string

const (
	ApproverActionNone    ApproverAction = "NONE"
	ApproverActionApprove ApproverAction = "APPROVE"
	ApproverActionReject  ApproverAction = "REJECT"
)

func NewApproverActionFromString(s string) (ApproverAction, error) {
	switch s {
	case "NONE":
		return ApproverActionNone, nil
	case "APPROVE":
		return ApproverActionApprove, nil
	case "REJECT":
		return ApproverActionReject, nil
	}
	var t ApproverAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApproverAction) Ptr() *ApproverAction {
	return &a
}

type AssociatedApprovalAction struct {
	UserID EntityUserID   `json:"userId" url:"userId"`
	Action ApproverAction `json:"action" url:"action"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssociatedApprovalAction) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *AssociatedApprovalAction) GetAction() ApproverAction {
	if a == nil {
		return ""
	}
	return a.Action
}

func (a *AssociatedApprovalAction) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssociatedApprovalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler AssociatedApprovalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssociatedApprovalAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssociatedApprovalAction) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BankAccountPaymentDestinationOptions struct {
	// Delivery method for ACH payments. Defaults to ACH_SAME_DAY.
	Delivery *BankDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`
	// ACH Statement Description.
	// By default, this will be 'AP' followed by the first 8 characters of the invoice ID (for a single invoice) or the first 8 characters of the transaction ID (for a batch payment).
	// Must be at least 4 characters and no more than 10 characters, and follow this regex pattern `^[a-zA-Z0-9\-#.$&* ]{4,10}$`
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountPaymentDestinationOptions) GetDelivery() *BankDeliveryMethod {
	if b == nil {
		return nil
	}
	return b.Delivery
}

func (b *BankAccountPaymentDestinationOptions) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankAccountPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDestinationOptions) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankDeliveryMethod string

const (
	BankDeliveryMethodAchStandard    BankDeliveryMethod = "ACH_STANDARD"
	BankDeliveryMethodAchSameDay     BankDeliveryMethod = "ACH_SAME_DAY"
	BankDeliveryMethodAchAccelerated BankDeliveryMethod = "ACH_ACCELERATED"
)

func NewBankDeliveryMethodFromString(s string) (BankDeliveryMethod, error) {
	switch s {
	case "ACH_STANDARD":
		return BankDeliveryMethodAchStandard, nil
	case "ACH_SAME_DAY":
		return BankDeliveryMethodAchSameDay, nil
	case "ACH_ACCELERATED":
		return BankDeliveryMethodAchAccelerated, nil
	}
	var t BankDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankDeliveryMethod) Ptr() *BankDeliveryMethod {
	return &b
}

type BulkInvoiceCreationFromObjectResponse struct {
	// The ID of the invoice that was created. If the invoice was not created, this will be undefined
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// If provided, this is the foreign ID of the invoice that was created.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// The error message if the invoice was not created
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationFromObjectResponse) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BulkInvoiceCreationFromObjectResponse) GetForeignID() *string {
	if b == nil {
		return nil
	}
	return b.ForeignID
}

func (b *BulkInvoiceCreationFromObjectResponse) GetError() *string {
	if b == nil {
		return nil
	}
	return b.Error
}

func (b *BulkInvoiceCreationFromObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationFromObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationFromObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationFromObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationFromObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceCreationRequest struct {
	Invoices []*InvoiceCreationRequest `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationRequest) GetInvoices() []*InvoiceCreationRequest {
	if b == nil {
		return nil
	}
	return b.Invoices
}

func (b *BulkInvoiceCreationRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceCreationResponse struct {
	Data []*BulkInvoiceCreationFromObjectResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationResponse) GetData() []*BulkInvoiceCreationFromObjectResponse {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BulkInvoiceCreationResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CheckDeliveryMethod string

const (
	CheckDeliveryMethodPrint CheckDeliveryMethod = "PRINT"
	CheckDeliveryMethodMail  CheckDeliveryMethod = "MAIL"
)

func NewCheckDeliveryMethodFromString(s string) (CheckDeliveryMethod, error) {
	switch s {
	case "PRINT":
		return CheckDeliveryMethodPrint, nil
	case "MAIL":
		return CheckDeliveryMethodMail, nil
	}
	var t CheckDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckDeliveryMethod) Ptr() *CheckDeliveryMethod {
	return &c
}

type CheckPaymentDestinationOptions struct {
	// Delivery method for check disbursements. Defaults to MAIL.
	Delivery *CheckDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`
	// If true, prints the invoice description (noteToSelf) on the check note. Defaults to false.
	PrintDescription *bool `json:"printDescription,omitempty" url:"printDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckPaymentDestinationOptions) GetDelivery() *CheckDeliveryMethod {
	if c == nil {
		return nil
	}
	return c.Delivery
}

func (c *CheckPaymentDestinationOptions) GetPrintDescription() *bool {
	if c == nil {
		return nil
	}
	return c.PrintDescription
}

func (c *CheckPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckPaymentDestinationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentID = string

type CommentRequest struct {
	Text string `json:"text" url:"text"`
	// The ID or the Foreign ID of the user who created the comment.
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CommentRequest) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *CommentRequest) GetUserID() *EntityUserID {
	if c == nil {
		return nil
	}
	return c.UserID
}

func (c *CommentRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentResponse struct {
	ID   string              `json:"id" url:"id"`
	Text string              `json:"text" url:"text"`
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`
	// If an approval action has triggered the generation of this comment, returns the associated approval action and actor
	AssociatedApprovalAction *AssociatedApprovalAction `json:"associatedApprovalAction,omitempty" url:"associatedApprovalAction,omitempty"`
	CreatedAt                time.Time                 `json:"createdAt" url:"createdAt"`
	UpdatedAt                time.Time                 `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CommentResponse) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CommentResponse) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *CommentResponse) GetUser() *EntityUserResponse {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CommentResponse) GetAssociatedApprovalAction() *AssociatedApprovalAction {
	if c == nil {
		return nil
	}
	return c.AssociatedApprovalAction
}

func (c *CommentResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CommentResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CommentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentResponse) UnmarshalJSON(data []byte) error {
	type embed CommentResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CommentResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentResponse) MarshalJSON() ([]byte, error) {
	type embed CommentResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CommentResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DayOfWeek string

const (
	DayOfWeekSunday    DayOfWeek = "0"
	DayOfWeekMonday    DayOfWeek = "1"
	DayOfWeekTuesday   DayOfWeek = "2"
	DayOfWeekWednesday DayOfWeek = "3"
	DayOfWeekThursday  DayOfWeek = "4"
	DayOfWeekFriday    DayOfWeek = "5"
	DayOfWeekSaturday  DayOfWeek = "6"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "0":
		return DayOfWeekSunday, nil
	case "1":
		return DayOfWeekMonday, nil
	case "2":
		return DayOfWeekTuesday, nil
	case "3":
		return DayOfWeekWednesday, nil
	case "4":
		return DayOfWeekThursday, nil
	case "5":
		return DayOfWeekFriday, nil
	case "6":
		return DayOfWeekSaturday, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

type FindInvoiceResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool               `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindInvoiceResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindInvoiceResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindInvoiceResponse) GetData() []*InvoiceResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindInvoiceTemplateResponse struct {
	// Total number of invoice templates for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more invoice templates available for the given filters.
	HasMore bool                       `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceTemplateResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindInvoiceTemplateResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindInvoiceTemplateResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindInvoiceTemplateResponse) GetData() []*InvoiceTemplateResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindInvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceTemplateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceTemplateResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type InvoiceCreationRequest struct {
	InvoiceCreationWithEntityRequest      *InvoiceCreationWithEntityRequest
	InvoiceCreationWithEntityGroupRequest *InvoiceCreationWithEntityGroupRequest

	typ string
}

func (i *InvoiceCreationRequest) GetInvoiceCreationWithEntityRequest() *InvoiceCreationWithEntityRequest {
	if i == nil {
		return nil
	}
	return i.InvoiceCreationWithEntityRequest
}

func (i *InvoiceCreationRequest) GetInvoiceCreationWithEntityGroupRequest() *InvoiceCreationWithEntityGroupRequest {
	if i == nil {
		return nil
	}
	return i.InvoiceCreationWithEntityGroupRequest
}

func (i *InvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	valueInvoiceCreationWithEntityRequest := new(InvoiceCreationWithEntityRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityRequest); err == nil {
		i.typ = "InvoiceCreationWithEntityRequest"
		i.InvoiceCreationWithEntityRequest = valueInvoiceCreationWithEntityRequest
		return nil
	}
	valueInvoiceCreationWithEntityGroupRequest := new(InvoiceCreationWithEntityGroupRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityGroupRequest); err == nil {
		i.typ = "InvoiceCreationWithEntityGroupRequest"
		i.InvoiceCreationWithEntityGroupRequest = valueInvoiceCreationWithEntityGroupRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCreationRequest) MarshalJSON() ([]byte, error) {
	if i.typ == "InvoiceCreationWithEntityRequest" || i.InvoiceCreationWithEntityRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityRequest)
	}
	if i.typ == "InvoiceCreationWithEntityGroupRequest" || i.InvoiceCreationWithEntityGroupRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityGroupRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationRequestVisitor interface {
	VisitInvoiceCreationWithEntityRequest(*InvoiceCreationWithEntityRequest) error
	VisitInvoiceCreationWithEntityGroupRequest(*InvoiceCreationWithEntityGroupRequest) error
}

func (i *InvoiceCreationRequest) Accept(visitor InvoiceCreationRequestVisitor) error {
	if i.typ == "InvoiceCreationWithEntityRequest" || i.InvoiceCreationWithEntityRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityRequest(i.InvoiceCreationWithEntityRequest)
	}
	if i.typ == "InvoiceCreationWithEntityGroupRequest" || i.InvoiceCreationWithEntityGroupRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityGroupRequest(i.InvoiceCreationWithEntityGroupRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationWithEntityGroupRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID  *OcrJobID                         `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	LineItems []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity group who created this invoice.
	CreatorEntityGroupID EntityGroupID `json:"creatorEntityGroupId" url:"creatorEntityGroupId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreationWithEntityGroupRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceCreationWithEntityGroupRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceCreationWithEntityGroupRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceCreationWithEntityGroupRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceCreationWithEntityGroupRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceCreationWithEntityGroupRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceCreationWithEntityGroupRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceCreationWithEntityGroupRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceCreationWithEntityGroupRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceCreationWithEntityGroupRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceCreationWithEntityGroupRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceCreationWithEntityGroupRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceCreationWithEntityGroupRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCreatorEntityGroupID() EntityGroupID {
	if i == nil {
		return ""
	}
	return i.CreatorEntityGroupID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityGroupRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityGroupRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityGroupRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityGroupRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityGroupRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityGroupRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreationWithEntityRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID  *OcrJobID                         `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	LineItems []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice.
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreationWithEntityRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceCreationWithEntityRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceCreationWithEntityRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceCreationWithEntityRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceCreationWithEntityRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceCreationWithEntityRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceCreationWithEntityRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceCreationWithEntityRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceCreationWithEntityRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceCreationWithEntityRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceCreationWithEntityRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceCreationWithEntityRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceCreationWithEntityRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceCreationWithEntityRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceCreationWithEntityRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceCreationWithEntityRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceCreationWithEntityRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceCreationWithEntityRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceCreationWithEntityRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceCreationWithEntityRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceCreationWithEntityRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceCreationWithEntityRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceCreationWithEntityRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceCreationWithEntityRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceCreationWithEntityRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceCreationWithEntityRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceCreationWithEntityRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceCreationWithEntityRequest) GetCreatorEntityID() EntityID {
	if i == nil {
		return ""
	}
	return i.CreatorEntityID
}

func (i *InvoiceCreationWithEntityRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceDateFilter string

const (
	InvoiceDateFilterInvoiceDate    InvoiceDateFilter = "INVOICE_DATE"
	InvoiceDateFilterDeductionDate  InvoiceDateFilter = "DEDUCTION_DATE"
	InvoiceDateFilterDueDate        InvoiceDateFilter = "DUE_DATE"
	InvoiceDateFilterSettlementDate InvoiceDateFilter = "SETTLEMENT_DATE"
	InvoiceDateFilterCreatedAt      InvoiceDateFilter = "CREATED_AT"
	InvoiceDateFilterUpdatedAt      InvoiceDateFilter = "UPDATED_AT"
)

func NewInvoiceDateFilterFromString(s string) (InvoiceDateFilter, error) {
	switch s {
	case "INVOICE_DATE":
		return InvoiceDateFilterInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceDateFilterDeductionDate, nil
	case "DUE_DATE":
		return InvoiceDateFilterDueDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceDateFilterSettlementDate, nil
	case "CREATED_AT":
		return InvoiceDateFilterCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceDateFilterUpdatedAt, nil
	}
	var t InvoiceDateFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceDateFilter) Ptr() *InvoiceDateFilter {
	return &i
}

type InvoiceEvent struct {
	WebhookIDs []string              `json:"webhookIds,omitempty" url:"webhookIds,omitempty"`
	Data       *InvoiceUpdateRequest `json:"data,omitempty" url:"data,omitempty"`
	// The ID of the user who triggered this event
	UserID    *EntityUserID  `json:"userId,omitempty" url:"userId,omitempty"`
	CreatedAt time.Time      `json:"createdAt" url:"createdAt"`
	IPAddress *string        `json:"ipAddress,omitempty" url:"ipAddress,omitempty"`
	Status    *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceEvent) GetWebhookIDs() []string {
	if i == nil {
		return nil
	}
	return i.WebhookIDs
}

func (i *InvoiceEvent) GetData() *InvoiceUpdateRequest {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceEvent) GetUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.UserID
}

func (i *InvoiceEvent) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceEvent) GetIPAddress() *string {
	if i == nil {
		return nil
	}
	return i.IPAddress
}

func (i *InvoiceEvent) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEvent) UnmarshalJSON(data []byte) error {
	type embed InvoiceEvent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceEvent(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEvent) MarshalJSON() ([]byte, error) {
	type embed InvoiceEvent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceEventsResponse struct {
	Data  []*InvoiceEvent `json:"data,omitempty" url:"data,omitempty"`
	Count int             `json:"count" url:"count"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceEventsResponse) GetData() []*InvoiceEvent {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceEventsResponse) GetCount() int {
	if i == nil {
		return 0
	}
	return i.Count
}

func (i *InvoiceEventsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEventsResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFailureType string

const (
	InvoiceFailureTypeSourcePaymentError      InvoiceFailureType = "SOURCE_PAYMENT_ERROR"
	InvoiceFailureTypeDestinationPaymentError InvoiceFailureType = "DESTINATION_PAYMENT_ERROR"
	InvoiceFailureTypeRejectedHighRisk        InvoiceFailureType = "REJECTED_HIGH_RISK"
	InvoiceFailureTypeInsufficientFunds       InvoiceFailureType = "INSUFFICIENT_FUNDS"
	InvoiceFailureTypeProcessingError         InvoiceFailureType = "PROCESSING_ERROR"
)

func NewInvoiceFailureTypeFromString(s string) (InvoiceFailureType, error) {
	switch s {
	case "SOURCE_PAYMENT_ERROR":
		return InvoiceFailureTypeSourcePaymentError, nil
	case "DESTINATION_PAYMENT_ERROR":
		return InvoiceFailureTypeDestinationPaymentError, nil
	case "REJECTED_HIGH_RISK":
		return InvoiceFailureTypeRejectedHighRisk, nil
	case "INSUFFICIENT_FUNDS":
		return InvoiceFailureTypeInsufficientFunds, nil
	case "PROCESSING_ERROR":
		return InvoiceFailureTypeProcessingError, nil
	}
	var t InvoiceFailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceFailureType) Ptr() *InvoiceFailureType {
	return &i
}

type InvoiceFeesRequest struct {
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceFeesRequest) GetSourcePlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePlatformMarkupFee
}

func (i *InvoiceFeesRequest) GetDestinationPlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPlatformMarkupFee
}

func (i *InvoiceFeesRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFeesResponse struct {
	// Fee charged to the platform (C1) for processing the source payment method. For example, credit card interchange and acquiring fees.
	SourcePaymentMethodFee float64 `json:"sourcePaymentMethodFee" url:"sourcePaymentMethodFee"`
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the platform (C1) for processing the destination payment method. For example, postage for a check payment.
	DestinationPaymentMethodFee float64 `json:"destinationPaymentMethodFee" url:"destinationPaymentMethodFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceFeesResponse) GetSourcePaymentMethodFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePaymentMethodFee
}

func (i *InvoiceFeesResponse) GetSourcePlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePlatformMarkupFee
}

func (i *InvoiceFeesResponse) GetDestinationPaymentMethodFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPaymentMethodFee
}

func (i *InvoiceFeesResponse) GetDestinationPlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPlatformMarkupFee
}

func (i *InvoiceFeesResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceID = string

type InvoiceLineItemCreationRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	Description *string  `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemCreationRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemCreationRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemCreationRequest) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemCreationRequest) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemCreationRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemCreationRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemCreationRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemCreationRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemCreationRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemCreationRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemCreationRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemCreationRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemCreationRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemCreationRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemCreationRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemID = string

type InvoiceLineItemIndividualUpdateRequest struct {
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemIndividualUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemIndividualUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemIndividualUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemIndividualUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemIndividualUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemIndividualUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemRequestBase struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemRequestBase) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemRequestBase) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemRequestBase) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemRequestBase) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemRequestBase) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemRequestBase
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemRequestBase(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemRequestBase
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemResponse struct {
	ID InvoiceLineItemID `json:"id" url:"id"`
	// Total amount of line item in major units.
	Amount      *float64     `json:"amount,omitempty" url:"amount,omitempty"`
	Currency    CurrencyCode `json:"currency" url:"currency"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Name        *string      `json:"name,omitempty" url:"name,omitempty"`
	Quantity    *float64     `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of line item in major units.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item. Defaults to 'EXPENSE'.
	Category         string            `json:"category" url:"category"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string   `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemResponse) GetID() InvoiceLineItemID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceLineItemResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceLineItemResponse) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemResponse) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemResponse) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemResponse) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemResponse) GetCategory() string {
	if i == nil {
		return ""
	}
	return i.Category
}

func (i *InvoiceLineItemResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemResponse) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceLineItemResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceLineItemResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemResponse
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *internal.DateTime `json:"createdAt"`
		UpdatedAt        *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemResponse(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemResponse
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *internal.DateTime `json:"createdAt"`
		UpdatedAt        *internal.DateTime `json:"updatedAt"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:        internal.NewDateTime(i.CreatedAt),
		UpdatedAt:        internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemUpdateRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// If provided, will overwrite line item on the invoice with this ID. If not provided, will create a new line item.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	Description *string  `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemUpdateRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemUpdateRequest) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemUpdateRequest) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemUpdateRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemUpdateRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemUpdateRequest) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceLineItemUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemUpdateRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsGroupBy string

const (
	InvoiceMetricsGroupByStatus InvoiceMetricsGroupBy = "STATUS"
)

func NewInvoiceMetricsGroupByFromString(s string) (InvoiceMetricsGroupBy, error) {
	switch s {
	case "STATUS":
		return InvoiceMetricsGroupByStatus, nil
	}
	var t InvoiceMetricsGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsGroupBy) Ptr() *InvoiceMetricsGroupBy {
	return &i
}

type InvoiceMetricsPerDateFrequency string

const (
	InvoiceMetricsPerDateFrequencyDaily   InvoiceMetricsPerDateFrequency = "DAILY"
	InvoiceMetricsPerDateFrequencyWeekly  InvoiceMetricsPerDateFrequency = "WEEKLY"
	InvoiceMetricsPerDateFrequencyMonthly InvoiceMetricsPerDateFrequency = "MONTHLY"
	InvoiceMetricsPerDateFrequencyYearly  InvoiceMetricsPerDateFrequency = "YEARLY"
)

func NewInvoiceMetricsPerDateFrequencyFromString(s string) (InvoiceMetricsPerDateFrequency, error) {
	switch s {
	case "DAILY":
		return InvoiceMetricsPerDateFrequencyDaily, nil
	case "WEEKLY":
		return InvoiceMetricsPerDateFrequencyWeekly, nil
	case "MONTHLY":
		return InvoiceMetricsPerDateFrequencyMonthly, nil
	case "YEARLY":
		return InvoiceMetricsPerDateFrequencyYearly, nil
	}
	var t InvoiceMetricsPerDateFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateFrequency) Ptr() *InvoiceMetricsPerDateFrequency {
	return &i
}

type InvoiceMetricsPerDateGroupBy string

const (
	InvoiceMetricsPerDateGroupByCreationDate  InvoiceMetricsPerDateGroupBy = "CREATION_DATE"
	InvoiceMetricsPerDateGroupByDueDate       InvoiceMetricsPerDateGroupBy = "DUE_DATE"
	InvoiceMetricsPerDateGroupByInvoiceDate   InvoiceMetricsPerDateGroupBy = "INVOICE_DATE"
	InvoiceMetricsPerDateGroupByDeductionDate InvoiceMetricsPerDateGroupBy = "DEDUCTION_DATE"
)

func NewInvoiceMetricsPerDateGroupByFromString(s string) (InvoiceMetricsPerDateGroupBy, error) {
	switch s {
	case "CREATION_DATE":
		return InvoiceMetricsPerDateGroupByCreationDate, nil
	case "DUE_DATE":
		return InvoiceMetricsPerDateGroupByDueDate, nil
	case "INVOICE_DATE":
		return InvoiceMetricsPerDateGroupByInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceMetricsPerDateGroupByDeductionDate, nil
	}
	var t InvoiceMetricsPerDateGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateGroupBy) Ptr() *InvoiceMetricsPerDateGroupBy {
	return &i
}

type InvoiceMetricsPerDateResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string `json:"group,omitempty" url:"group,omitempty"`
	Date          time.Time           `json:"date" url:"date"`
	TotalAmount   float64             `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                 `json:"totalCount" url:"totalCount"`
	AverageAmount float64             `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode        `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceMetricsPerDateResponse) GetGroup() []map[string]string {
	if i == nil {
		return nil
	}
	return i.Group
}

func (i *InvoiceMetricsPerDateResponse) GetDate() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.Date
}

func (i *InvoiceMetricsPerDateResponse) GetTotalAmount() float64 {
	if i == nil {
		return 0
	}
	return i.TotalAmount
}

func (i *InvoiceMetricsPerDateResponse) GetTotalCount() int {
	if i == nil {
		return 0
	}
	return i.TotalCount
}

func (i *InvoiceMetricsPerDateResponse) GetAverageAmount() float64 {
	if i == nil {
		return 0
	}
	return i.AverageAmount
}

func (i *InvoiceMetricsPerDateResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceMetricsPerDateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsPerDateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceMetricsPerDateResponse
	var unmarshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceMetricsPerDateResponse(unmarshaler.embed)
	i.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsPerDateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceMetricsPerDateResponse
	var marshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*i),
		Date:  internal.NewDateTime(i.Date),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceMetricsPerDateResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string                       `json:"group,omitempty" url:"group,omitempty"`
	TotalAmount   float64                                   `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                                       `json:"totalCount" url:"totalCount"`
	AverageAmount float64                                   `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode                              `json:"currency" url:"currency"`
	Dates         map[string]*InvoiceMetricsPerDateResponse `json:"dates,omitempty" url:"dates,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceMetricsResponse) GetGroup() []map[string]string {
	if i == nil {
		return nil
	}
	return i.Group
}

func (i *InvoiceMetricsResponse) GetTotalAmount() float64 {
	if i == nil {
		return 0
	}
	return i.TotalAmount
}

func (i *InvoiceMetricsResponse) GetTotalCount() int {
	if i == nil {
		return 0
	}
	return i.TotalCount
}

func (i *InvoiceMetricsResponse) GetAverageAmount() float64 {
	if i == nil {
		return 0
	}
	return i.AverageAmount
}

func (i *InvoiceMetricsResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceMetricsResponse) GetDates() map[string]*InvoiceMetricsPerDateResponse {
	if i == nil {
		return nil
	}
	return i.Dates
}

func (i *InvoiceMetricsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceMetricsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceOrderByField string

const (
	InvoiceOrderByFieldAmount         InvoiceOrderByField = "AMOUNT"
	InvoiceOrderByFieldDueDate        InvoiceOrderByField = "DUE_DATE"
	InvoiceOrderByFieldCreatedAt      InvoiceOrderByField = "CREATED_AT"
	InvoiceOrderByFieldUpdatedAt      InvoiceOrderByField = "UPDATED_AT"
	InvoiceOrderByFieldDeductionDate  InvoiceOrderByField = "DEDUCTION_DATE"
	InvoiceOrderByFieldInvoiceDate    InvoiceOrderByField = "INVOICE_DATE"
	InvoiceOrderByFieldSettlementDate InvoiceOrderByField = "SETTLEMENT_DATE"
	InvoiceOrderByFieldInvoiceNumber  InvoiceOrderByField = "INVOICE_NUMBER"
	InvoiceOrderByFieldVendorName     InvoiceOrderByField = "VENDOR_NAME"
	InvoiceOrderByFieldPayerName      InvoiceOrderByField = "PAYER_NAME"
)

func NewInvoiceOrderByFieldFromString(s string) (InvoiceOrderByField, error) {
	switch s {
	case "AMOUNT":
		return InvoiceOrderByFieldAmount, nil
	case "DUE_DATE":
		return InvoiceOrderByFieldDueDate, nil
	case "CREATED_AT":
		return InvoiceOrderByFieldCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceOrderByFieldUpdatedAt, nil
	case "DEDUCTION_DATE":
		return InvoiceOrderByFieldDeductionDate, nil
	case "INVOICE_DATE":
		return InvoiceOrderByFieldInvoiceDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceOrderByFieldSettlementDate, nil
	case "INVOICE_NUMBER":
		return InvoiceOrderByFieldInvoiceNumber, nil
	case "VENDOR_NAME":
		return InvoiceOrderByFieldVendorName, nil
	case "PAYER_NAME":
		return InvoiceOrderByFieldPayerName, nil
	}
	var t InvoiceOrderByField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceOrderByField) Ptr() *InvoiceOrderByField {
	return &i
}

type InvoiceRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRequestBase) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceRequestBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceRequestBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceRequestBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceRequestBase) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceRequestBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceRequestBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceRequestBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceRequestBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceRequestBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceRequestBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceRequestBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceRequestBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceRequestBase) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceRequestBase) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceRequestBase) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceRequestBase) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceRequestBase) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceRequestBase) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceRequestBase) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceRequestBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceRequestBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceRequestBase) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceRequestBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceRequestBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceRequestBase) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	ID       InvoiceID `json:"id" url:"id"`
	// Date when the invoice payment was processed.
	ProcessedAt *time.Time `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// If the invoice failed to be paid, this field will be populated with the type of failure.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// Transactions associated with this invoice.
	Transactions []*TransactionResponseWithoutInvoices `json:"transactions,omitempty" url:"transactions,omitempty"`
	// The IDs of the vendor credits that are currently applied to this invoice.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceResponse) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceResponse) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceResponse) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceResponse) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceResponse) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceResponse) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceResponse) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceResponse) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceResponse) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceResponse) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceResponse) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceResponse) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceResponse) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceResponse) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceResponse) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceResponse) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceResponse) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceResponse) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceResponse) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceResponse) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceResponse) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceResponse) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceResponse) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceResponse) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceResponse) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceResponse) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceResponse) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceResponse) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceResponse) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceResponse) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceResponse) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceResponse) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceResponse) GetID() InvoiceID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceResponse) GetProcessedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ProcessedAt
}

func (i *InvoiceResponse) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceResponse) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceResponse) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceResponse) GetTransactions() []*TransactionResponseWithoutInvoices {
	if i == nil {
		return nil
	}
	return i.Transactions
}

func (i *InvoiceResponse) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
		ProcessedAt       *internal.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *internal.DateTime `json:"settlementDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	i.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponse
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
		ProcessedAt       *internal.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *internal.DateTime `json:"settlementDate,omitempty"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
		ProcessedAt:       internal.NewOptionalDateTime(i.ProcessedAt),
		SettlementDate:    internal.NewOptionalDateTime(i.SettlementDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponseBase struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceResponseBase) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceResponseBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceResponseBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceResponseBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceResponseBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceResponseBase) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceResponseBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceResponseBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceResponseBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceResponseBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceResponseBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceResponseBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceResponseBase) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceResponseBase) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceResponseBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceResponseBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceResponseBase) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceResponseBase) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceResponseBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceResponseBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceResponseBase) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceResponseBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceResponseBase) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceResponseBase) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceResponseBase) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceResponseBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceResponseBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceResponseBase) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceResponseBase) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceResponseBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceResponseBase) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceResponseBase) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceResponseBase) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceResponseBase) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceResponseBase) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceResponseBase) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceResponseBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceResponseBase) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceResponseBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponseBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponseBase
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponseBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponseBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponseBase
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponseBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceStatus string

const (
	InvoiceStatusUnassigned InvoiceStatus = "UNASSIGNED"
	InvoiceStatusDraft      InvoiceStatus = "DRAFT"
	InvoiceStatusNew        InvoiceStatus = "NEW"
	InvoiceStatusApproved   InvoiceStatus = "APPROVED"
	InvoiceStatusScheduled  InvoiceStatus = "SCHEDULED"
	InvoiceStatusPending    InvoiceStatus = "PENDING"
	InvoiceStatusPaid       InvoiceStatus = "PAID"
	InvoiceStatusArchived   InvoiceStatus = "ARCHIVED"
	InvoiceStatusRefused    InvoiceStatus = "REFUSED"
	InvoiceStatusCanceled   InvoiceStatus = "CANCELED"
	InvoiceStatusFailed     InvoiceStatus = "FAILED"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "UNASSIGNED":
		return InvoiceStatusUnassigned, nil
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "NEW":
		return InvoiceStatusNew, nil
	case "APPROVED":
		return InvoiceStatusApproved, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PENDING":
		return InvoiceStatusPending, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "ARCHIVED":
		return InvoiceStatusArchived, nil
	case "REFUSED":
		return InvoiceStatusRefused, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

type InvoiceTemplateCreationRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                          `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	LineItems      []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice template.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateCreationRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateCreationRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateCreationRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateCreationRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateCreationRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateCreationRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateCreationRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateCreationRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateCreationRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateCreationRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateCreationRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateCreationRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateCreationRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateCreationRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateCreationRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateCreationRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateCreationRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateCreationRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateCreationRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateCreationRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateCreationRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateCreationRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateCreationRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateCreationRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateCreationRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateCreationRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateCreationRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateID = string

type InvoiceTemplateRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateRequestBase) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateRequestBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateRequestBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateRequestBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateRequestBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateRequestBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateRequestBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateRequestBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateRequestBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateRequestBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateRequestBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateRequestBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateRequestBase) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateRequestBase) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateRequestBase) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateRequestBase) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateRequestBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateRequestBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateRequestBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateRequestBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate                   *time.Time                 `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber             *string                    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf                *string                    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate          *time.Time                 `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate            *time.Time                 `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	PayerID                   *EntityID                  `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse      `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse     `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID           `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	VendorID                  *EntityID                  `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse      `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse     `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID           `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID         `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	ID       InvoiceTemplateID `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateResponse) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceTemplateResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateResponse) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateResponse) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateResponse) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateResponse) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceTemplateResponse) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateResponse) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateResponse) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateResponse) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateResponse) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceTemplateResponse) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceTemplateResponse) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateResponse) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateResponse) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceTemplateResponse) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceTemplateResponse) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateResponse) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceTemplateResponse) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceTemplateResponse) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateResponse) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateResponse) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateResponse) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateResponse) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceTemplateResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateResponse) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateResponse) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceTemplateResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceTemplateResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceTemplateResponse) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceTemplateResponse) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateResponse) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateResponse) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceTemplateResponse) GetID() InvoiceTemplateID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateResponse
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                        `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	LineItems      []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateUpdateRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateUpdateRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateUpdateRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateUpdateRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateUpdateRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateUpdateRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateUpdateRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateUpdateRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateUpdateRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateUpdateRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateUpdateRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateUpdateRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateUpdateRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateUpdateRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateUpdateRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateUpdateRequest) GetLineItems() []*InvoiceLineItemUpdateRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateUpdateRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID  *OcrJobID                       `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	LineItems []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdateRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceUpdateRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceUpdateRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceUpdateRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceUpdateRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceUpdateRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceUpdateRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceUpdateRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceUpdateRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceUpdateRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceUpdateRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceUpdateRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceUpdateRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceUpdateRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceUpdateRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceUpdateRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceUpdateRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceUpdateRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceUpdateRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceUpdateRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceUpdateRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceUpdateRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceUpdateRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceUpdateRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceUpdateRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceUpdateRequest) GetLineItems() []*InvoiceLineItemUpdateRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceUpdateRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MetadataFilter struct {
	Key string `json:"key" url:"key"`
	// If multiple values are provided, the filter will match if any of the values match (OR filter). To filter for the absence of a key, use the value 'NULL'.
	Value *StringOrStringArray `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetadataFilter) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MetadataFilter) GetValue() *StringOrStringArray {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MetadataFilter) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataFilter) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaymentDestinationOptions struct {
	Type        string
	Check       *CheckPaymentDestinationOptions
	BankAccount *BankAccountPaymentDestinationOptions
	Utility     *UtilityPaymentDestinationOptions
}

func (p *PaymentDestinationOptions) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentDestinationOptions) GetCheck() *CheckPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.Check
}

func (p *PaymentDestinationOptions) GetBankAccount() *BankAccountPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.BankAccount
}

func (p *PaymentDestinationOptions) GetUtility() *UtilityPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.Utility
}

func (p *PaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "check":
		value := new(CheckPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "bankAccount":
		value := new(BankAccountPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "utility":
		value := new(UtilityPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	}
	return nil
}

func (p PaymentDestinationOptions) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Check != nil {
		return internal.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.BankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Utility != nil {
		return internal.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentDestinationOptionsVisitor interface {
	VisitCheck(*CheckPaymentDestinationOptions) error
	VisitBankAccount(*BankAccountPaymentDestinationOptions) error
	VisitUtility(*UtilityPaymentDestinationOptions) error
}

func (p *PaymentDestinationOptions) Accept(visitor PaymentDestinationOptionsVisitor) error {
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentDestinationOptions) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Check != nil {
		fields = append(fields, "check")
	}
	if p.BankAccount != nil {
		fields = append(fields, "bankAccount")
	}
	if p.Utility != nil {
		fields = append(fields, "utility")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentMonthSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// deprecated. will be removed in the future and will always be 0.
	DayOffset *int `json:"dayOffset,omitempty" url:"dayOffset,omitempty"`
	// Day of the month to repeat on. Positive values (1-31): Represent the day of the month counting from the start (e.g., 10 is the 10th day of the month). Negative values (-1 to -31): Represent the day of the month counting backward from the end (e.g., -1 is the last day of the month, -2 is the second-to-last day).
	RepeatOnDay int `json:"repeatOnDay" url:"repeatOnDay"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMonthSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentMonthSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentMonthSchedule) GetDayOffset() *int {
	if p == nil {
		return nil
	}
	return p.DayOffset
}

func (p *PaymentMonthSchedule) GetRepeatOnDay() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnDay
}

func (p *PaymentMonthSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMonthSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMonthSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMonthSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMonthSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentSchedule struct {
	Type    string
	OneTime *PaymentScheduleBase
	Daily   *PaymentScheduleBase
	Weekly  *PaymentWeekSchedule
	Monthly *PaymentMonthSchedule
	Yearly  *PaymentYearSchedule
}

func (p *PaymentSchedule) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentSchedule) GetOneTime() *PaymentScheduleBase {
	if p == nil {
		return nil
	}
	return p.OneTime
}

func (p *PaymentSchedule) GetDaily() *PaymentScheduleBase {
	if p == nil {
		return nil
	}
	return p.Daily
}

func (p *PaymentSchedule) GetWeekly() *PaymentWeekSchedule {
	if p == nil {
		return nil
	}
	return p.Weekly
}

func (p *PaymentSchedule) GetMonthly() *PaymentMonthSchedule {
	if p == nil {
		return nil
	}
	return p.Monthly
}

func (p *PaymentSchedule) GetYearly() *PaymentYearSchedule {
	if p == nil {
		return nil
	}
	return p.Yearly
}

func (p *PaymentSchedule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "oneTime":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OneTime = value
	case "daily":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Daily = value
	case "weekly":
		value := new(PaymentWeekSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Weekly = value
	case "monthly":
		value := new(PaymentMonthSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Monthly = value
	case "yearly":
		value := new(PaymentYearSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Yearly = value
	}
	return nil
}

func (p PaymentSchedule) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.OneTime != nil {
		return internal.MarshalJSONWithExtraProperty(p.OneTime, "type", "oneTime")
	}
	if p.Daily != nil {
		return internal.MarshalJSONWithExtraProperty(p.Daily, "type", "daily")
	}
	if p.Weekly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Weekly, "type", "weekly")
	}
	if p.Monthly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Monthly, "type", "monthly")
	}
	if p.Yearly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Yearly, "type", "yearly")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentScheduleVisitor interface {
	VisitOneTime(*PaymentScheduleBase) error
	VisitDaily(*PaymentScheduleBase) error
	VisitWeekly(*PaymentWeekSchedule) error
	VisitMonthly(*PaymentMonthSchedule) error
	VisitYearly(*PaymentYearSchedule) error
}

func (p *PaymentSchedule) Accept(visitor PaymentScheduleVisitor) error {
	if p.OneTime != nil {
		return visitor.VisitOneTime(p.OneTime)
	}
	if p.Daily != nil {
		return visitor.VisitDaily(p.Daily)
	}
	if p.Weekly != nil {
		return visitor.VisitWeekly(p.Weekly)
	}
	if p.Monthly != nil {
		return visitor.VisitMonthly(p.Monthly)
	}
	if p.Yearly != nil {
		return visitor.VisitYearly(p.Yearly)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentSchedule) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.OneTime != nil {
		fields = append(fields, "oneTime")
	}
	if p.Daily != nil {
		fields = append(fields, "daily")
	}
	if p.Weekly != nil {
		fields = append(fields, "weekly")
	}
	if p.Monthly != nil {
		fields = append(fields, "monthly")
	}
	if p.Yearly != nil {
		fields = append(fields, "yearly")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentScheduleBase struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentScheduleBase) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentScheduleBase) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentScheduleBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentScheduleBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentScheduleBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentScheduleBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentScheduleBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentScheduleEndCondition struct {
	Integer  int
	DateTime time.Time

	typ string
}

func (p *PaymentScheduleEndCondition) GetInteger() int {
	if p == nil {
		return 0
	}
	return p.Integer
}

func (p *PaymentScheduleEndCondition) GetDateTime() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.DateTime
}

func (p *PaymentScheduleEndCondition) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		p.typ = "Integer"
		p.Integer = valueInteger
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		p.typ = "DateTime"
		p.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentScheduleEndCondition) MarshalJSON() ([]byte, error) {
	if p.typ == "Integer" || p.Integer != 0 {
		return json.Marshal(p.Integer)
	}
	if p.typ == "DateTime" || !p.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(p.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentScheduleEndConditionVisitor interface {
	VisitInteger(int) error
	VisitDateTime(time.Time) error
}

func (p *PaymentScheduleEndCondition) Accept(visitor PaymentScheduleEndConditionVisitor) error {
	if p.typ == "Integer" || p.Integer != 0 {
		return visitor.VisitInteger(p.Integer)
	}
	if p.typ == "DateTime" || !p.DateTime.IsZero() {
		return visitor.VisitDateTime(p.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentType string

const (
	PaymentTypeOneTime   PaymentType = "oneTime"
	PaymentTypeRecurring PaymentType = "recurring"
)

func NewPaymentTypeFromString(s string) (PaymentType, error) {
	switch s {
	case "oneTime":
		return PaymentTypeOneTime, nil
	case "recurring":
		return PaymentTypeRecurring, nil
	}
	var t PaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentType) Ptr() *PaymentType {
	return &p
}

type PaymentWeekSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends     *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	RepeatOn []DayOfWeek                  `json:"repeatOn,omitempty" url:"repeatOn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentWeekSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentWeekSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentWeekSchedule) GetRepeatOn() []DayOfWeek {
	if p == nil {
		return nil
	}
	return p.RepeatOn
}

func (p *PaymentWeekSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentWeekSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentWeekSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentWeekSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentWeekSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentYearSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// Day of the month to repeat on. Positive values (1-31): Represent the day of the month counting from the start (e.g., 10 is the 10th day of the month). Negative values (-1 to -31): Represent the day of the month counting backward from the end (e.g., -1 is the last day of the month, -2 is the second-to-last day).
	RepeatOnDay int `json:"repeatOnDay" url:"repeatOnDay"`
	// Month to repeat on (1-12).
	RepeatOnMonth int `json:"repeatOnMonth" url:"repeatOnMonth"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentYearSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentYearSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentYearSchedule) GetRepeatOnDay() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnDay
}

func (p *PaymentYearSchedule) GetRepeatOnMonth() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnMonth
}

func (p *PaymentYearSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentYearSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentYearSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentYearSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentYearSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UtilityPaymentDestinationOptions struct {
	// The ID for the utility account to pay with. Links to accounts listed on payor/payee relationship.
	AccountID string `json:"accountId" url:"accountId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UtilityPaymentDestinationOptions) GetAccountID() string {
	if u == nil {
		return ""
	}
	return u.AccountID
}

func (u *UtilityPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilityPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilityPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentDestinationOptions) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
