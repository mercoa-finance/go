// This file was auto-generated by Fern from our API Definition.

package mercoa

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mercoa-finance/go/internal"
	time "time"
)

type AddApproverRequest struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID *ApprovalSlotID `json:"approvalSlotId,omitempty" url:"approvalSlotId,omitempty"`
	// The ID or the Foreign ID of the user to add to the approval slot.
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddApproverRequest) GetApprovalSlotID() *ApprovalSlotID {
	if a == nil {
		return nil
	}
	return a.ApprovalSlotID
}

func (a *AddApproverRequest) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *AddApproverRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddApproverRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddApproverRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddApproverRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddApproverRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalRequest struct {
	// Comment associated with this approval action.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID or the Foreign ID of the user
	UserID EntityUserID `json:"userId" url:"userId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalRequest) GetText() *string {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *ApprovalRequest) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *ApprovalRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalRequestWithID struct {
	// Comment associated with this approval action.
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID or the Foreign ID of the user
	UserID EntityUserID `json:"userId" url:"userId"`
	// The ID or foreign ID of the invoice to approve
	InvoiceID InvoiceID `json:"invoiceId" url:"invoiceId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalRequestWithID) GetText() *string {
	if a == nil {
		return nil
	}
	return a.Text
}

func (a *ApprovalRequestWithID) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *ApprovalRequestWithID) GetInvoiceID() InvoiceID {
	if a == nil {
		return ""
	}
	return a.InvoiceID
}

func (a *ApprovalRequestWithID) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalRequestWithID) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalRequestWithID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalRequestWithID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalRequestWithID) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlot struct {
	// The identifier for the upstream policy this slot is associated with.
	UpstreamPolicyID *ApprovalPolicyID `json:"upstreamPolicyId,omitempty" url:"upstreamPolicyId,omitempty"`
	// Whether all upstream policies are approved.
	UpstreamPoliciesApproved *bool `json:"upstreamPoliciesApproved,omitempty" url:"upstreamPoliciesApproved,omitempty"`
	// The identifier for the approval policy this slot is associated with.
	ApprovalPolicyID ApprovalPolicyID `json:"approvalPolicyId" url:"approvalPolicyId"`
	// The identifier for this approval slot
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	// The ID of the user who is assigned to the approval slot. If undefined, the approval slot is assigned to all eligible approvers.
	AssignedUserID  *EntityUserID  `json:"assignedUserId,omitempty" url:"assignedUserId,omitempty"`
	Action          ApproverAction `json:"action" url:"action"`
	EligibleRoles   []string       `json:"eligibleRoles,omitempty" url:"eligibleRoles,omitempty"`
	EligibleUserIDs []EntityUserID `json:"eligibleUserIds,omitempty" url:"eligibleUserIds,omitempty"`
	// Either the date the invoice was created, date the approver was assigned, or date of last action by approver, whichever is latest.
	Date time.Time `json:"date" url:"date"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalSlot) GetUpstreamPolicyID() *ApprovalPolicyID {
	if a == nil {
		return nil
	}
	return a.UpstreamPolicyID
}

func (a *ApprovalSlot) GetUpstreamPoliciesApproved() *bool {
	if a == nil {
		return nil
	}
	return a.UpstreamPoliciesApproved
}

func (a *ApprovalSlot) GetApprovalPolicyID() ApprovalPolicyID {
	if a == nil {
		return ""
	}
	return a.ApprovalPolicyID
}

func (a *ApprovalSlot) GetApprovalSlotID() ApprovalSlotID {
	if a == nil {
		return ""
	}
	return a.ApprovalSlotID
}

func (a *ApprovalSlot) GetAssignedUserID() *EntityUserID {
	if a == nil {
		return nil
	}
	return a.AssignedUserID
}

func (a *ApprovalSlot) GetAction() ApproverAction {
	if a == nil {
		return ""
	}
	return a.Action
}

func (a *ApprovalSlot) GetEligibleRoles() []string {
	if a == nil {
		return nil
	}
	return a.EligibleRoles
}

func (a *ApprovalSlot) GetEligibleUserIDs() []EntityUserID {
	if a == nil {
		return nil
	}
	return a.EligibleUserIDs
}

func (a *ApprovalSlot) GetDate() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.Date
}

func (a *ApprovalSlot) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlot) UnmarshalJSON(data []byte) error {
	type embed ApprovalSlot
	var unmarshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = ApprovalSlot(unmarshaler.embed)
	a.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlot) MarshalJSON() ([]byte, error) {
	type embed ApprovalSlot
	var marshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*a),
		Date:  internal.NewDateTime(a.Date),
	}
	return json.Marshal(marshaler)
}

func (a *ApprovalSlot) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotAssignment struct {
	// The identifier for the approval slot this user is assigned to.
	ApprovalSlotID ApprovalSlotID `json:"approvalSlotId" url:"approvalSlotId"`
	// The ID of the user who is assigned to the approval slot. To assign all eligible users to an approval slot, use "ANY".
	AssignedUserID EntityUserID `json:"assignedUserId" url:"assignedUserId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApprovalSlotAssignment) GetApprovalSlotID() ApprovalSlotID {
	if a == nil {
		return ""
	}
	return a.ApprovalSlotID
}

func (a *ApprovalSlotAssignment) GetAssignedUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.AssignedUserID
}

func (a *ApprovalSlotAssignment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApprovalSlotAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler ApprovalSlotAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApprovalSlotAssignment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApprovalSlotAssignment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApprovalSlotID = string

type ApproverAction string

const (
	ApproverActionNone    ApproverAction = "NONE"
	ApproverActionApprove ApproverAction = "APPROVE"
	ApproverActionReject  ApproverAction = "REJECT"
)

func NewApproverActionFromString(s string) (ApproverAction, error) {
	switch s {
	case "NONE":
		return ApproverActionNone, nil
	case "APPROVE":
		return ApproverActionApprove, nil
	case "REJECT":
		return ApproverActionReject, nil
	}
	var t ApproverAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApproverAction) Ptr() *ApproverAction {
	return &a
}

type AssociatedApprovalAction struct {
	UserID EntityUserID   `json:"userId" url:"userId"`
	Action ApproverAction `json:"action" url:"action"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AssociatedApprovalAction) GetUserID() EntityUserID {
	if a == nil {
		return ""
	}
	return a.UserID
}

func (a *AssociatedApprovalAction) GetAction() ApproverAction {
	if a == nil {
		return ""
	}
	return a.Action
}

func (a *AssociatedApprovalAction) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssociatedApprovalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler AssociatedApprovalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssociatedApprovalAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssociatedApprovalAction) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BankAccountPaymentDestinationOptions struct {
	// Delivery method for ACH payments. Defaults to ACH_SAME_DAY.
	Delivery *BankDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`
	// ACH Statement Description.
	// By default, this will be 'AP' followed by the first 8 characters of the invoice ID (for a single invoice) or the first 8 characters of the transaction ID (for a batch payment).
	// Must be at least 4 characters and no more than 10 characters, and follow this regex pattern `^[a-zA-Z0-9\-#.$&* ]{4,10}$`
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountPaymentDestinationOptions) GetDelivery() *BankDeliveryMethod {
	if b == nil {
		return nil
	}
	return b.Delivery
}

func (b *BankAccountPaymentDestinationOptions) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankAccountPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDestinationOptions) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankDeliveryMethod string

const (
	BankDeliveryMethodAchStandard    BankDeliveryMethod = "ACH_STANDARD"
	BankDeliveryMethodAchSameDay     BankDeliveryMethod = "ACH_SAME_DAY"
	BankDeliveryMethodAchAccelerated BankDeliveryMethod = "ACH_ACCELERATED"
)

func NewBankDeliveryMethodFromString(s string) (BankDeliveryMethod, error) {
	switch s {
	case "ACH_STANDARD":
		return BankDeliveryMethodAchStandard, nil
	case "ACH_SAME_DAY":
		return BankDeliveryMethodAchSameDay, nil
	case "ACH_ACCELERATED":
		return BankDeliveryMethodAchAccelerated, nil
	}
	var t BankDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankDeliveryMethod) Ptr() *BankDeliveryMethod {
	return &b
}

type BnplCadence string

const (
	BnplCadenceWeekly   BnplCadence = "WEEKLY"
	BnplCadenceBiweekly BnplCadence = "BIWEEKLY"
	BnplCadenceMonthly  BnplCadence = "MONTHLY"
)

func NewBnplCadenceFromString(s string) (BnplCadence, error) {
	switch s {
	case "WEEKLY":
		return BnplCadenceWeekly, nil
	case "BIWEEKLY":
		return BnplCadenceBiweekly, nil
	case "MONTHLY":
		return BnplCadenceMonthly, nil
	}
	var t BnplCadence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BnplCadence) Ptr() *BnplCadence {
	return &b
}

type BnplDayOfWeek string

const (
	BnplDayOfWeekMonday    BnplDayOfWeek = "MONDAY"
	BnplDayOfWeekTuesday   BnplDayOfWeek = "TUESDAY"
	BnplDayOfWeekWednesday BnplDayOfWeek = "WEDNESDAY"
	BnplDayOfWeekThursday  BnplDayOfWeek = "THURSDAY"
	BnplDayOfWeekFriday    BnplDayOfWeek = "FRIDAY"
	BnplDayOfWeekSaturday  BnplDayOfWeek = "SATURDAY"
	BnplDayOfWeekSunday    BnplDayOfWeek = "SUNDAY"
)

func NewBnplDayOfWeekFromString(s string) (BnplDayOfWeek, error) {
	switch s {
	case "MONDAY":
		return BnplDayOfWeekMonday, nil
	case "TUESDAY":
		return BnplDayOfWeekTuesday, nil
	case "WEDNESDAY":
		return BnplDayOfWeekWednesday, nil
	case "THURSDAY":
		return BnplDayOfWeekThursday, nil
	case "FRIDAY":
		return BnplDayOfWeekFriday, nil
	case "SATURDAY":
		return BnplDayOfWeekSaturday, nil
	case "SUNDAY":
		return BnplDayOfWeekSunday, nil
	}
	var t BnplDayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BnplDayOfWeek) Ptr() *BnplDayOfWeek {
	return &b
}

type BnplFees struct {
	// Total fees in cents
	BaseFeeAmount int `json:"baseFeeAmount" url:"baseFeeAmount"`
	// Fee percentage as a decimal (e.g., 1.4 for 1.4%)
	BaseFeePercentage float64 `json:"baseFeePercentage" url:"baseFeePercentage"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplFees) GetBaseFeeAmount() int {
	if b == nil {
		return 0
	}
	return b.BaseFeeAmount
}

func (b *BnplFees) GetBaseFeePercentage() float64 {
	if b == nil {
		return 0
	}
	return b.BaseFeePercentage
}

func (b *BnplFees) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplFees) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplFees) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplInstallment struct {
	Number  int                 `json:"number" url:"number"`
	DueDate string              `json:"dueDate" url:"dueDate"`
	Amount  int                 `json:"amount" url:"amount"`
	Type    BnplInstallmentType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplInstallment) GetNumber() int {
	if b == nil {
		return 0
	}
	return b.Number
}

func (b *BnplInstallment) GetDueDate() string {
	if b == nil {
		return ""
	}
	return b.DueDate
}

func (b *BnplInstallment) GetAmount() int {
	if b == nil {
		return 0
	}
	return b.Amount
}

func (b *BnplInstallment) GetType() BnplInstallmentType {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BnplInstallment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplInstallment) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplInstallment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplInstallment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplInstallment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplInstallmentTotalPaid struct {
	// Total principal paid in cents
	PrincipalBalance int `json:"principalBalance" url:"principalBalance"`
	// Total interest paid in cents
	DueInterest int `json:"dueInterest" url:"dueInterest"`
	// Total late fees paid in cents
	TotalLateFees int `json:"totalLateFees" url:"totalLateFees"`
	// Total fees paid in cents
	FeeAmount int `json:"feeAmount" url:"feeAmount"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplInstallmentTotalPaid) GetPrincipalBalance() int {
	if b == nil {
		return 0
	}
	return b.PrincipalBalance
}

func (b *BnplInstallmentTotalPaid) GetDueInterest() int {
	if b == nil {
		return 0
	}
	return b.DueInterest
}

func (b *BnplInstallmentTotalPaid) GetTotalLateFees() int {
	if b == nil {
		return 0
	}
	return b.TotalLateFees
}

func (b *BnplInstallmentTotalPaid) GetFeeAmount() int {
	if b == nil {
		return 0
	}
	return b.FeeAmount
}

func (b *BnplInstallmentTotalPaid) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplInstallmentTotalPaid) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplInstallmentTotalPaid
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplInstallmentTotalPaid(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplInstallmentTotalPaid) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplInstallmentType string

const (
	BnplInstallmentTypeDownPayment BnplInstallmentType = "DOWN_PAYMENT"
	BnplInstallmentTypeRegular     BnplInstallmentType = "REGULAR"
)

func NewBnplInstallmentTypeFromString(s string) (BnplInstallmentType, error) {
	switch s {
	case "DOWN_PAYMENT":
		return BnplInstallmentTypeDownPayment, nil
	case "REGULAR":
		return BnplInstallmentTypeRegular, nil
	}
	var t BnplInstallmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BnplInstallmentType) Ptr() *BnplInstallmentType {
	return &b
}

type BnplLoanInstallment struct {
	// Installment number (0 for down payment)
	Number int `json:"number" url:"number"`
	// Start date as timestamp in milliseconds
	StartDate int `json:"startDate" url:"startDate"`
	// Due date as timestamp in milliseconds
	DueDate int `json:"dueDate" url:"dueDate"`
	// Maturity date as timestamp in milliseconds
	MaturityDate int `json:"maturityDate" url:"maturityDate"`
	// Outstanding balance for this installment in cents
	OutstandingBalance int `json:"outstandingBalance" url:"outstandingBalance"`
	// Total amount for this installment in cents
	Amount int `json:"amount" url:"amount"`
	// Status of this installment
	Status BnplLoanStatus `json:"status" url:"status"`
	// Type of installment
	Type BnplInstallmentType `json:"type" url:"type"`
	// Total amounts paid for this installment
	TotalPaid *BnplInstallmentTotalPaid `json:"totalPaid,omitempty" url:"totalPaid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplLoanInstallment) GetNumber() int {
	if b == nil {
		return 0
	}
	return b.Number
}

func (b *BnplLoanInstallment) GetStartDate() int {
	if b == nil {
		return 0
	}
	return b.StartDate
}

func (b *BnplLoanInstallment) GetDueDate() int {
	if b == nil {
		return 0
	}
	return b.DueDate
}

func (b *BnplLoanInstallment) GetMaturityDate() int {
	if b == nil {
		return 0
	}
	return b.MaturityDate
}

func (b *BnplLoanInstallment) GetOutstandingBalance() int {
	if b == nil {
		return 0
	}
	return b.OutstandingBalance
}

func (b *BnplLoanInstallment) GetAmount() int {
	if b == nil {
		return 0
	}
	return b.Amount
}

func (b *BnplLoanInstallment) GetStatus() BnplLoanStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BnplLoanInstallment) GetType() BnplInstallmentType {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BnplLoanInstallment) GetTotalPaid() *BnplInstallmentTotalPaid {
	if b == nil {
		return nil
	}
	return b.TotalPaid
}

func (b *BnplLoanInstallment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplLoanInstallment) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplLoanInstallment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplLoanInstallment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplLoanInstallment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplLoanResponse struct {
	// The unique identifier for the loan
	LoanID string `json:"loanId" url:"loanId"`
	// The external ID of the business entity
	BusinessExternalID string `json:"businessExternalId" url:"businessExternalId"`
	// The final due date as timestamp in milliseconds
	DueDate int `json:"dueDate" url:"dueDate"`
	// The original principal balance in cents
	OriginalPrincipalBalance int `json:"originalPrincipalBalance" url:"originalPrincipalBalance"`
	// The date the loan was drawn as timestamp in milliseconds
	DrawDate int `json:"drawDate" url:"drawDate"`
	// The total amount repaid in cents
	RepaidAmount int `json:"repaidAmount" url:"repaidAmount"`
	// The ID of the payment method used
	PaymentMethodID string `json:"paymentMethodId" url:"paymentMethodId"`
	// The ID of the repayment method
	RepaymentMethodID string `json:"repaymentMethodId" url:"repaymentMethodId"`
	// The current status of the loan
	Status BnplLoanStatus `json:"status" url:"status"`
	// The current outstanding balance breakdown
	OutstandingBalance *BnplOutstandingBalance `json:"outstandingBalance,omitempty" url:"outstandingBalance,omitempty"`
	// URL to the terms agreement file
	TermsAgreementFile *string `json:"termsAgreementFile,omitempty" url:"termsAgreementFile,omitempty"`
	// URL to the invoice PDF
	InvoiceURL *string `json:"invoiceUrl,omitempty" url:"invoiceUrl,omitempty"`
	// The original invoice amount in cents
	InvoiceAmount int `json:"invoiceAmount" url:"invoiceAmount"`
	// The external ID of the associated invoice
	InvoiceExternalID string `json:"invoiceExternalId" url:"invoiceExternalId"`
	// The original invoice due date as timestamp in milliseconds
	InvoiceDueDate int `json:"invoiceDueDate" url:"invoiceDueDate"`
	// The down payment amount in cents
	DownPaymentAmount int `json:"downPaymentAmount" url:"downPaymentAmount"`
	// List of all installments for this loan
	Installments []*BnplLoanInstallment `json:"installments,omitempty" url:"installments,omitempty"`
	// The payment cadence for the loan
	Cadence BnplCadence `json:"cadence" url:"cadence"`
	// The base fee rate as a percentage
	BaseFeeRate float64 `json:"baseFeeRate" url:"baseFeeRate"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplLoanResponse) GetLoanID() string {
	if b == nil {
		return ""
	}
	return b.LoanID
}

func (b *BnplLoanResponse) GetBusinessExternalID() string {
	if b == nil {
		return ""
	}
	return b.BusinessExternalID
}

func (b *BnplLoanResponse) GetDueDate() int {
	if b == nil {
		return 0
	}
	return b.DueDate
}

func (b *BnplLoanResponse) GetOriginalPrincipalBalance() int {
	if b == nil {
		return 0
	}
	return b.OriginalPrincipalBalance
}

func (b *BnplLoanResponse) GetDrawDate() int {
	if b == nil {
		return 0
	}
	return b.DrawDate
}

func (b *BnplLoanResponse) GetRepaidAmount() int {
	if b == nil {
		return 0
	}
	return b.RepaidAmount
}

func (b *BnplLoanResponse) GetPaymentMethodID() string {
	if b == nil {
		return ""
	}
	return b.PaymentMethodID
}

func (b *BnplLoanResponse) GetRepaymentMethodID() string {
	if b == nil {
		return ""
	}
	return b.RepaymentMethodID
}

func (b *BnplLoanResponse) GetStatus() BnplLoanStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BnplLoanResponse) GetOutstandingBalance() *BnplOutstandingBalance {
	if b == nil {
		return nil
	}
	return b.OutstandingBalance
}

func (b *BnplLoanResponse) GetTermsAgreementFile() *string {
	if b == nil {
		return nil
	}
	return b.TermsAgreementFile
}

func (b *BnplLoanResponse) GetInvoiceURL() *string {
	if b == nil {
		return nil
	}
	return b.InvoiceURL
}

func (b *BnplLoanResponse) GetInvoiceAmount() int {
	if b == nil {
		return 0
	}
	return b.InvoiceAmount
}

func (b *BnplLoanResponse) GetInvoiceExternalID() string {
	if b == nil {
		return ""
	}
	return b.InvoiceExternalID
}

func (b *BnplLoanResponse) GetInvoiceDueDate() int {
	if b == nil {
		return 0
	}
	return b.InvoiceDueDate
}

func (b *BnplLoanResponse) GetDownPaymentAmount() int {
	if b == nil {
		return 0
	}
	return b.DownPaymentAmount
}

func (b *BnplLoanResponse) GetInstallments() []*BnplLoanInstallment {
	if b == nil {
		return nil
	}
	return b.Installments
}

func (b *BnplLoanResponse) GetCadence() BnplCadence {
	if b == nil {
		return ""
	}
	return b.Cadence
}

func (b *BnplLoanResponse) GetBaseFeeRate() float64 {
	if b == nil {
		return 0
	}
	return b.BaseFeeRate
}

func (b *BnplLoanResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplLoanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplLoanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplLoanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplLoanResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplLoanStatus string

const (
	BnplLoanStatusPending    BnplLoanStatus = "PENDING"
	BnplLoanStatusActive     BnplLoanStatus = "ACTIVE"
	BnplLoanStatusPaidOff    BnplLoanStatus = "PAID_OFF"
	BnplLoanStatusDelinquent BnplLoanStatus = "DELINQUENT"
)

func NewBnplLoanStatusFromString(s string) (BnplLoanStatus, error) {
	switch s {
	case "PENDING":
		return BnplLoanStatusPending, nil
	case "ACTIVE":
		return BnplLoanStatusActive, nil
	case "PAID_OFF":
		return BnplLoanStatusPaidOff, nil
	case "DELINQUENT":
		return BnplLoanStatusDelinquent, nil
	}
	var t BnplLoanStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BnplLoanStatus) Ptr() *BnplLoanStatus {
	return &b
}

type BnplOfferRequest struct {
	// The payment cadence for the BNPL offer
	Cadence BnplCadence `json:"cadence" url:"cadence"`
	// The start date for installments in YYYY-MM-DD format
	InstallmentsStartDate string `json:"installmentsStartDate" url:"installmentsStartDate"`
	// The number of installments
	NumberOfInstallments int `json:"numberOfInstallments" url:"numberOfInstallments"`
	// The day of the week for payments
	PaymentDayOfWeek BnplDayOfWeek `json:"paymentDayOfWeek" url:"paymentDayOfWeek"`
	// The due date for the down payment in YYYY-MM-DD format
	DownPaymentDueDate string `json:"downPaymentDueDate" url:"downPaymentDueDate"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplOfferRequest) GetCadence() BnplCadence {
	if b == nil {
		return ""
	}
	return b.Cadence
}

func (b *BnplOfferRequest) GetInstallmentsStartDate() string {
	if b == nil {
		return ""
	}
	return b.InstallmentsStartDate
}

func (b *BnplOfferRequest) GetNumberOfInstallments() int {
	if b == nil {
		return 0
	}
	return b.NumberOfInstallments
}

func (b *BnplOfferRequest) GetPaymentDayOfWeek() BnplDayOfWeek {
	if b == nil {
		return ""
	}
	return b.PaymentDayOfWeek
}

func (b *BnplOfferRequest) GetDownPaymentDueDate() string {
	if b == nil {
		return ""
	}
	return b.DownPaymentDueDate
}

func (b *BnplOfferRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplOfferRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplOfferRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplOfferRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplOfferRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplOfferResponse struct {
	// The total amount of the invoice in cents.
	InvoiceAmount int `json:"invoiceAmount" url:"invoiceAmount"`
	// Total amount to be repaid, including fees. In cents.
	TotalRepaymentAmount int `json:"totalRepaymentAmount" url:"totalRepaymentAmount"`
	// The currency code for the amount
	Currency string `json:"currency" url:"currency"`
	// The down payment amount in cents
	DownPaymentAmount int `json:"downPaymentAmount" url:"downPaymentAmount"`
	// The number of payments/installments
	NumberOfPayments int `json:"numberOfPayments" url:"numberOfPayments"`
	// The date of the first payment in YYYY-MM-DD format
	FirstPaymentDate string `json:"firstPaymentDate" url:"firstPaymentDate"`
	// The date of the final payment in YYYY-MM-DD format
	FinalPaymentDate string `json:"finalPaymentDate" url:"finalPaymentDate"`
	// The fees associated with the offer
	Fees *BnplFees `json:"fees,omitempty" url:"fees,omitempty"`
	// A link to the terms and conditions for the offer
	TermsLink *string `json:"termsLink,omitempty" url:"termsLink,omitempty"`
	// A list of all installments, including down payment.
	Installments []*BnplInstallment `json:"installments,omitempty" url:"installments,omitempty"`
	// The day of the week for payments, e.g. "Wednesday"
	PaymentDayOfWeek BnplDayOfWeek `json:"paymentDayOfWeek" url:"paymentDayOfWeek"`
	// The amount for each regular installment. The last installment may have a different amount. In cents.
	InstallmentAmount int `json:"installmentAmount" url:"installmentAmount"`
	// e.g. "1.5% per 28 days"
	FinanceFeeRate string `json:"financeFeeRate" url:"financeFeeRate"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplOfferResponse) GetInvoiceAmount() int {
	if b == nil {
		return 0
	}
	return b.InvoiceAmount
}

func (b *BnplOfferResponse) GetTotalRepaymentAmount() int {
	if b == nil {
		return 0
	}
	return b.TotalRepaymentAmount
}

func (b *BnplOfferResponse) GetCurrency() string {
	if b == nil {
		return ""
	}
	return b.Currency
}

func (b *BnplOfferResponse) GetDownPaymentAmount() int {
	if b == nil {
		return 0
	}
	return b.DownPaymentAmount
}

func (b *BnplOfferResponse) GetNumberOfPayments() int {
	if b == nil {
		return 0
	}
	return b.NumberOfPayments
}

func (b *BnplOfferResponse) GetFirstPaymentDate() string {
	if b == nil {
		return ""
	}
	return b.FirstPaymentDate
}

func (b *BnplOfferResponse) GetFinalPaymentDate() string {
	if b == nil {
		return ""
	}
	return b.FinalPaymentDate
}

func (b *BnplOfferResponse) GetFees() *BnplFees {
	if b == nil {
		return nil
	}
	return b.Fees
}

func (b *BnplOfferResponse) GetTermsLink() *string {
	if b == nil {
		return nil
	}
	return b.TermsLink
}

func (b *BnplOfferResponse) GetInstallments() []*BnplInstallment {
	if b == nil {
		return nil
	}
	return b.Installments
}

func (b *BnplOfferResponse) GetPaymentDayOfWeek() BnplDayOfWeek {
	if b == nil {
		return ""
	}
	return b.PaymentDayOfWeek
}

func (b *BnplOfferResponse) GetInstallmentAmount() int {
	if b == nil {
		return 0
	}
	return b.InstallmentAmount
}

func (b *BnplOfferResponse) GetFinanceFeeRate() string {
	if b == nil {
		return ""
	}
	return b.FinanceFeeRate
}

func (b *BnplOfferResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplOfferResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplOfferResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplOfferResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplOfferResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplOutstandingBalance struct {
	// Outstanding principal balance in cents
	PrincipalBalance int `json:"principalBalance" url:"principalBalance"`
	// Outstanding fee balance in cents
	FeeBalance int `json:"feeBalance" url:"feeBalance"`
	// Total outstanding balance in cents
	TotalBalance int `json:"totalBalance" url:"totalBalance"`
	// Outstanding late fee balance in cents
	LateFeeBalance int `json:"lateFeeBalance" url:"lateFeeBalance"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplOutstandingBalance) GetPrincipalBalance() int {
	if b == nil {
		return 0
	}
	return b.PrincipalBalance
}

func (b *BnplOutstandingBalance) GetFeeBalance() int {
	if b == nil {
		return 0
	}
	return b.FeeBalance
}

func (b *BnplOutstandingBalance) GetTotalBalance() int {
	if b == nil {
		return 0
	}
	return b.TotalBalance
}

func (b *BnplOutstandingBalance) GetLateFeeBalance() int {
	if b == nil {
		return 0
	}
	return b.LateFeeBalance
}

func (b *BnplOutstandingBalance) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplOutstandingBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplOutstandingBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplOutstandingBalance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplOutstandingBalance) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BnplPaymentSourceOptions struct {
	// The start date for installments in YYYY-MM-DD format
	InstallmentsStartDate string `json:"installmentsStartDate" url:"installmentsStartDate"`
	// The number of weeks to defer repayment
	DefermentWeeks int `json:"defermentWeeks" url:"defermentWeeks"`
	// Whether the user has agreed to the BNPL terms
	AcceptedTerms bool `json:"acceptedTerms" url:"acceptedTerms"`
	// The ID of the loan to use for the BNPL payment.
	LoanID *string `json:"loanId,omitempty" url:"loanId,omitempty"`
	// The ID of the downpayment to use for the BNPL payment.
	DownpaymentID *string `json:"downpaymentId,omitempty" url:"downpaymentId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BnplPaymentSourceOptions) GetInstallmentsStartDate() string {
	if b == nil {
		return ""
	}
	return b.InstallmentsStartDate
}

func (b *BnplPaymentSourceOptions) GetDefermentWeeks() int {
	if b == nil {
		return 0
	}
	return b.DefermentWeeks
}

func (b *BnplPaymentSourceOptions) GetAcceptedTerms() bool {
	if b == nil {
		return false
	}
	return b.AcceptedTerms
}

func (b *BnplPaymentSourceOptions) GetLoanID() *string {
	if b == nil {
		return nil
	}
	return b.LoanID
}

func (b *BnplPaymentSourceOptions) GetDownpaymentID() *string {
	if b == nil {
		return nil
	}
	return b.DownpaymentID
}

func (b *BnplPaymentSourceOptions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BnplPaymentSourceOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler BnplPaymentSourceOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BnplPaymentSourceOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BnplPaymentSourceOptions) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceApprovalFromObjectResponse struct {
	// The ID of the invoice that was approved. If the invoice was not approved, this will be undefined
	ID *InvoiceID `json:"id,omitempty" url:"id,omitempty"`
	// If provided, this is the foreign ID of the invoice that was approved.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// The error message if the invoice was not approved
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceApprovalFromObjectResponse) GetID() *InvoiceID {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BulkInvoiceApprovalFromObjectResponse) GetForeignID() *string {
	if b == nil {
		return nil
	}
	return b.ForeignID
}

func (b *BulkInvoiceApprovalFromObjectResponse) GetError() *string {
	if b == nil {
		return nil
	}
	return b.Error
}

func (b *BulkInvoiceApprovalFromObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceApprovalFromObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceApprovalFromObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceApprovalFromObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceApprovalFromObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceApprovalRequest struct {
	Invoices []*ApprovalRequestWithID `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceApprovalRequest) GetInvoices() []*ApprovalRequestWithID {
	if b == nil {
		return nil
	}
	return b.Invoices
}

func (b *BulkInvoiceApprovalRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceApprovalRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceApprovalRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceApprovalRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceApprovalRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceApprovalResponse struct {
	Data []*BulkInvoiceApprovalFromObjectResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceApprovalResponse) GetData() []*BulkInvoiceApprovalFromObjectResponse {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BulkInvoiceApprovalResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceApprovalResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceApprovalResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceApprovalResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceApprovalResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceCreationFromObjectResponse struct {
	// The ID of the invoice that was created. If the invoice was not created, this will be undefined
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// If provided, this is the foreign ID of the invoice that was created.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// The error message if the invoice was not created
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationFromObjectResponse) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BulkInvoiceCreationFromObjectResponse) GetForeignID() *string {
	if b == nil {
		return nil
	}
	return b.ForeignID
}

func (b *BulkInvoiceCreationFromObjectResponse) GetError() *string {
	if b == nil {
		return nil
	}
	return b.Error
}

func (b *BulkInvoiceCreationFromObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationFromObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationFromObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationFromObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationFromObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceCreationRequest struct {
	Invoices []*InvoiceCreationRequest `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationRequest) GetInvoices() []*InvoiceCreationRequest {
	if b == nil {
		return nil
	}
	return b.Invoices
}

func (b *BulkInvoiceCreationRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceCreationResponse struct {
	Data []*BulkInvoiceCreationFromObjectResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceCreationResponse) GetData() []*BulkInvoiceCreationFromObjectResponse {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BulkInvoiceCreationResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceCreationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceCreationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceCreationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceCreationResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceUpdateFromObjectResponse struct {
	// The ID of the invoice that was updated. If the invoice was not updated, this will be undefined
	ID *InvoiceID `json:"id,omitempty" url:"id,omitempty"`
	// If provided, this is the foreign ID of the invoice that was updated.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// The error message if the invoice was not updated
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceUpdateFromObjectResponse) GetID() *InvoiceID {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BulkInvoiceUpdateFromObjectResponse) GetForeignID() *string {
	if b == nil {
		return nil
	}
	return b.ForeignID
}

func (b *BulkInvoiceUpdateFromObjectResponse) GetError() *string {
	if b == nil {
		return nil
	}
	return b.Error
}

func (b *BulkInvoiceUpdateFromObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceUpdateFromObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceUpdateFromObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceUpdateFromObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceUpdateFromObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceUpdateRequest struct {
	Invoices []*InvoiceUpdateRequestWithID `json:"invoices,omitempty" url:"invoices,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceUpdateRequest) GetInvoices() []*InvoiceUpdateRequestWithID {
	if b == nil {
		return nil
	}
	return b.Invoices
}

func (b *BulkInvoiceUpdateRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceUpdateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceUpdateRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceUpdateRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceUpdateRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkInvoiceUpdateResponse struct {
	Data []*BulkInvoiceUpdateFromObjectResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkInvoiceUpdateResponse) GetData() []*BulkInvoiceUpdateFromObjectResponse {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BulkInvoiceUpdateResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkInvoiceUpdateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkInvoiceUpdateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkInvoiceUpdateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkInvoiceUpdateResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CheckDeliveryMethod string

const (
	CheckDeliveryMethodPrint          CheckDeliveryMethod = "PRINT"
	CheckDeliveryMethodMail           CheckDeliveryMethod = "MAIL"
	CheckDeliveryMethodMailPriority   CheckDeliveryMethod = "MAIL_PRIORITY"
	CheckDeliveryMethodMailUpsNextDay CheckDeliveryMethod = "MAIL_UPS_NEXT_DAY"
)

func NewCheckDeliveryMethodFromString(s string) (CheckDeliveryMethod, error) {
	switch s {
	case "PRINT":
		return CheckDeliveryMethodPrint, nil
	case "MAIL":
		return CheckDeliveryMethodMail, nil
	case "MAIL_PRIORITY":
		return CheckDeliveryMethodMailPriority, nil
	case "MAIL_UPS_NEXT_DAY":
		return CheckDeliveryMethodMailUpsNextDay, nil
	}
	var t CheckDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckDeliveryMethod) Ptr() *CheckDeliveryMethod {
	return &c
}

type CheckPaymentDestinationOptions struct {
	// Delivery method for check disbursements. Defaults to MAIL.
	Delivery *CheckDeliveryMethod `json:"delivery,omitempty" url:"delivery,omitempty"`
	// If true, prints the invoice description (noteToSelf) on the check note. Defaults to false.
	PrintDescription *bool `json:"printDescription,omitempty" url:"printDescription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckPaymentDestinationOptions) GetDelivery() *CheckDeliveryMethod {
	if c == nil {
		return nil
	}
	return c.Delivery
}

func (c *CheckPaymentDestinationOptions) GetPrintDescription() *bool {
	if c == nil {
		return nil
	}
	return c.PrintDescription
}

func (c *CheckPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckPaymentDestinationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentID = string

type CommentRequest struct {
	Text string `json:"text" url:"text"`
	// The ID or the Foreign ID of the user who created the comment.
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CommentRequest) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *CommentRequest) GetUserID() *EntityUserID {
	if c == nil {
		return nil
	}
	return c.UserID
}

func (c *CommentRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CommentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CommentResponse struct {
	ID   string              `json:"id" url:"id"`
	Text string              `json:"text" url:"text"`
	User *EntityUserResponse `json:"user,omitempty" url:"user,omitempty"`
	// If an approval action has triggered the generation of this comment, returns the associated approval action and actor
	AssociatedApprovalAction *AssociatedApprovalAction `json:"associatedApprovalAction,omitempty" url:"associatedApprovalAction,omitempty"`
	CreatedAt                time.Time                 `json:"createdAt" url:"createdAt"`
	UpdatedAt                time.Time                 `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CommentResponse) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CommentResponse) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *CommentResponse) GetUser() *EntityUserResponse {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *CommentResponse) GetAssociatedApprovalAction() *AssociatedApprovalAction {
	if c == nil {
		return nil
	}
	return c.AssociatedApprovalAction
}

func (c *CommentResponse) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CommentResponse) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CommentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommentResponse) UnmarshalJSON(data []byte) error {
	type embed CommentResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CommentResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommentResponse) MarshalJSON() ([]byte, error) {
	type embed CommentResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *CommentResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomPaymentDestinationOptions struct {
	// Map of field names to dynamic URL values that will be used for dynamicUrl fields in custom payment method schemas
	DynamicURLs map[string]string `json:"dynamicUrls,omitempty" url:"dynamicUrls,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomPaymentDestinationOptions) GetDynamicURLs() map[string]string {
	if c == nil {
		return nil
	}
	return c.DynamicURLs
}

func (c *CustomPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomPaymentDestinationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DayOfWeek string

const (
	DayOfWeekSunday    DayOfWeek = "0"
	DayOfWeekMonday    DayOfWeek = "1"
	DayOfWeekTuesday   DayOfWeek = "2"
	DayOfWeekWednesday DayOfWeek = "3"
	DayOfWeekThursday  DayOfWeek = "4"
	DayOfWeekFriday    DayOfWeek = "5"
	DayOfWeekSaturday  DayOfWeek = "6"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "0":
		return DayOfWeekSunday, nil
	case "1":
		return DayOfWeekMonday, nil
	case "2":
		return DayOfWeekTuesday, nil
	case "3":
		return DayOfWeekWednesday, nil
	case "4":
		return DayOfWeekThursday, nil
	case "5":
		return DayOfWeekFriday, nil
	case "6":
		return DayOfWeekSaturday, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

type FindInvoiceResponse struct {
	// Total number of notifications for the given start and end date filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more notifications available for the given start and end date filters.
	HasMore bool               `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindInvoiceResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindInvoiceResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindInvoiceResponse) GetData() []*InvoiceResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FindInvoiceTemplateResponse struct {
	// Total number of invoice templates for the given filters. This value is not limited by the limit parameter. It is provided so that you can determine how many pages of results are available.
	Count int `json:"count" url:"count"`
	// True if there are more invoice templates available for the given filters.
	HasMore bool                       `json:"hasMore" url:"hasMore"`
	Data    []*InvoiceTemplateResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FindInvoiceTemplateResponse) GetCount() int {
	if f == nil {
		return 0
	}
	return f.Count
}

func (f *FindInvoiceTemplateResponse) GetHasMore() bool {
	if f == nil {
		return false
	}
	return f.HasMore
}

func (f *FindInvoiceTemplateResponse) GetData() []*InvoiceTemplateResponse {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FindInvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FindInvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FindInvoiceTemplateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FindInvoiceTemplateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FindInvoiceTemplateResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type InvoiceCreationRequest struct {
	InvoiceCreationWithEntityRequest      *InvoiceCreationWithEntityRequest
	InvoiceCreationWithEntityGroupRequest *InvoiceCreationWithEntityGroupRequest

	typ string
}

func (i *InvoiceCreationRequest) GetInvoiceCreationWithEntityRequest() *InvoiceCreationWithEntityRequest {
	if i == nil {
		return nil
	}
	return i.InvoiceCreationWithEntityRequest
}

func (i *InvoiceCreationRequest) GetInvoiceCreationWithEntityGroupRequest() *InvoiceCreationWithEntityGroupRequest {
	if i == nil {
		return nil
	}
	return i.InvoiceCreationWithEntityGroupRequest
}

func (i *InvoiceCreationRequest) UnmarshalJSON(data []byte) error {
	valueInvoiceCreationWithEntityRequest := new(InvoiceCreationWithEntityRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityRequest); err == nil {
		i.typ = "InvoiceCreationWithEntityRequest"
		i.InvoiceCreationWithEntityRequest = valueInvoiceCreationWithEntityRequest
		return nil
	}
	valueInvoiceCreationWithEntityGroupRequest := new(InvoiceCreationWithEntityGroupRequest)
	if err := json.Unmarshal(data, &valueInvoiceCreationWithEntityGroupRequest); err == nil {
		i.typ = "InvoiceCreationWithEntityGroupRequest"
		i.InvoiceCreationWithEntityGroupRequest = valueInvoiceCreationWithEntityGroupRequest
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i InvoiceCreationRequest) MarshalJSON() ([]byte, error) {
	if i.typ == "InvoiceCreationWithEntityRequest" || i.InvoiceCreationWithEntityRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityRequest)
	}
	if i.typ == "InvoiceCreationWithEntityGroupRequest" || i.InvoiceCreationWithEntityGroupRequest != nil {
		return json.Marshal(i.InvoiceCreationWithEntityGroupRequest)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationRequestVisitor interface {
	VisitInvoiceCreationWithEntityRequest(*InvoiceCreationWithEntityRequest) error
	VisitInvoiceCreationWithEntityGroupRequest(*InvoiceCreationWithEntityGroupRequest) error
}

func (i *InvoiceCreationRequest) Accept(visitor InvoiceCreationRequestVisitor) error {
	if i.typ == "InvoiceCreationWithEntityRequest" || i.InvoiceCreationWithEntityRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityRequest(i.InvoiceCreationWithEntityRequest)
	}
	if i.typ == "InvoiceCreationWithEntityGroupRequest" || i.InvoiceCreationWithEntityGroupRequest != nil {
		return visitor.VisitInvoiceCreationWithEntityGroupRequest(i.InvoiceCreationWithEntityGroupRequest)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", i)
}

type InvoiceCreationWithEntityGroupRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms *int `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// Options for the payment source. Depending on the payment source, this may include things such as BNPL configuration.
	PaymentSourceOptions *PaymentSourceOptions `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	// Set to true if the payment destination has been confirmed by the vendor or if the payment destination should default to the selected payment destination on the vendor portal.
	PaymentDestinationConfirmed *bool                             `json:"paymentDestinationConfirmed,omitempty" url:"paymentDestinationConfirmed,omitempty"`
	LineItems                   []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity group who created this invoice.
	CreatorEntityGroupID EntityGroupID `json:"creatorEntityGroupId" url:"creatorEntityGroupId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreationWithEntityGroupRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceCreationWithEntityGroupRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceCreationWithEntityGroupRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceCreationWithEntityGroupRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceCreationWithEntityGroupRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceCreationWithEntityGroupRequest) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceCreationWithEntityGroupRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceCreationWithEntityGroupRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceCreationWithEntityGroupRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceCreationWithEntityGroupRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceCreationWithEntityGroupRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceCreationWithEntityGroupRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceCreationWithEntityGroupRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceCreationWithEntityGroupRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceCreationWithEntityGroupRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceCreationWithEntityGroupRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetPaymentDestinationConfirmed() *bool {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceCreationWithEntityGroupRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceCreationWithEntityGroupRequest) GetCreatorEntityGroupID() EntityGroupID {
	if i == nil {
		return ""
	}
	return i.CreatorEntityGroupID
}

func (i *InvoiceCreationWithEntityGroupRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityGroupRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityGroupRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityGroupRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityGroupRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityGroupRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityGroupRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreationWithEntityRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms *int `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// Options for the payment source. Depending on the payment source, this may include things such as BNPL configuration.
	PaymentSourceOptions *PaymentSourceOptions `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	// Set to true if the payment destination has been confirmed by the vendor or if the payment destination should default to the selected payment destination on the vendor portal.
	PaymentDestinationConfirmed *bool                             `json:"paymentDestinationConfirmed,omitempty" url:"paymentDestinationConfirmed,omitempty"`
	LineItems                   []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice.
	CreatorEntityID EntityID `json:"creatorEntityId" url:"creatorEntityId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreationWithEntityRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceCreationWithEntityRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceCreationWithEntityRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceCreationWithEntityRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceCreationWithEntityRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceCreationWithEntityRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceCreationWithEntityRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceCreationWithEntityRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceCreationWithEntityRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceCreationWithEntityRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceCreationWithEntityRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceCreationWithEntityRequest) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceCreationWithEntityRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceCreationWithEntityRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceCreationWithEntityRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceCreationWithEntityRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceCreationWithEntityRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceCreationWithEntityRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceCreationWithEntityRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceCreationWithEntityRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceCreationWithEntityRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceCreationWithEntityRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceCreationWithEntityRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceCreationWithEntityRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceCreationWithEntityRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceCreationWithEntityRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceCreationWithEntityRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceCreationWithEntityRequest) GetPaymentDestinationConfirmed() *bool {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceCreationWithEntityRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceCreationWithEntityRequest) GetCreatorEntityID() EntityID {
	if i == nil {
		return ""
	}
	return i.CreatorEntityID
}

func (i *InvoiceCreationWithEntityRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreationWithEntityRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceCreationWithEntityRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceCreationWithEntityRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreationWithEntityRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceCreationWithEntityRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceCreationWithEntityRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceDateFilter string

const (
	InvoiceDateFilterInvoiceDate    InvoiceDateFilter = "INVOICE_DATE"
	InvoiceDateFilterDeductionDate  InvoiceDateFilter = "DEDUCTION_DATE"
	InvoiceDateFilterDueDate        InvoiceDateFilter = "DUE_DATE"
	InvoiceDateFilterSettlementDate InvoiceDateFilter = "SETTLEMENT_DATE"
	InvoiceDateFilterCreatedAt      InvoiceDateFilter = "CREATED_AT"
	InvoiceDateFilterUpdatedAt      InvoiceDateFilter = "UPDATED_AT"
)

func NewInvoiceDateFilterFromString(s string) (InvoiceDateFilter, error) {
	switch s {
	case "INVOICE_DATE":
		return InvoiceDateFilterInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceDateFilterDeductionDate, nil
	case "DUE_DATE":
		return InvoiceDateFilterDueDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceDateFilterSettlementDate, nil
	case "CREATED_AT":
		return InvoiceDateFilterCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceDateFilterUpdatedAt, nil
	}
	var t InvoiceDateFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceDateFilter) Ptr() *InvoiceDateFilter {
	return &i
}

type InvoiceEvent struct {
	// The ID of the event
	ID InvoiceEventID `json:"id" url:"id"`
	// The data related to the invoice update
	Data *InvoiceUpdateRequest `json:"data,omitempty" url:"data,omitempty"`
	// The list of webhook IDs associated with this event
	WebhookIDs []string `json:"webhookIds,omitempty" url:"webhookIds,omitempty"`
	// The current status of the invoice event
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the user who triggered this event
	UserID *EntityUserID `json:"userId,omitempty" url:"userId,omitempty"`
	// The IP address of the user who triggered the event
	IPAddress *string `json:"ipAddress,omitempty" url:"ipAddress,omitempty"`
	// The timestamp when the event was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceEvent) GetID() InvoiceEventID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceEvent) GetData() *InvoiceUpdateRequest {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceEvent) GetWebhookIDs() []string {
	if i == nil {
		return nil
	}
	return i.WebhookIDs
}

func (i *InvoiceEvent) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceEvent) GetUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.UserID
}

func (i *InvoiceEvent) GetIPAddress() *string {
	if i == nil {
		return nil
	}
	return i.IPAddress
}

func (i *InvoiceEvent) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEvent) UnmarshalJSON(data []byte) error {
	type embed InvoiceEvent
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceEvent(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEvent) MarshalJSON() ([]byte, error) {
	type embed InvoiceEvent
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceEventID = string

type InvoiceEventsResponse struct {
	Data    []*InvoiceEvent `json:"data,omitempty" url:"data,omitempty"`
	Count   int             `json:"count" url:"count"`
	HasMore bool            `json:"hasMore" url:"hasMore"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceEventsResponse) GetData() []*InvoiceEvent {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceEventsResponse) GetCount() int {
	if i == nil {
		return 0
	}
	return i.Count
}

func (i *InvoiceEventsResponse) GetHasMore() bool {
	if i == nil {
		return false
	}
	return i.HasMore
}

func (i *InvoiceEventsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceEventsResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFailureType string

const (
	InvoiceFailureTypeSourcePaymentError      InvoiceFailureType = "SOURCE_PAYMENT_ERROR"
	InvoiceFailureTypeDestinationPaymentError InvoiceFailureType = "DESTINATION_PAYMENT_ERROR"
	InvoiceFailureTypeRejectedHighRisk        InvoiceFailureType = "REJECTED_HIGH_RISK"
	InvoiceFailureTypeInsufficientFunds       InvoiceFailureType = "INSUFFICIENT_FUNDS"
	InvoiceFailureTypeProcessingError         InvoiceFailureType = "PROCESSING_ERROR"
)

func NewInvoiceFailureTypeFromString(s string) (InvoiceFailureType, error) {
	switch s {
	case "SOURCE_PAYMENT_ERROR":
		return InvoiceFailureTypeSourcePaymentError, nil
	case "DESTINATION_PAYMENT_ERROR":
		return InvoiceFailureTypeDestinationPaymentError, nil
	case "REJECTED_HIGH_RISK":
		return InvoiceFailureTypeRejectedHighRisk, nil
	case "INSUFFICIENT_FUNDS":
		return InvoiceFailureTypeInsufficientFunds, nil
	case "PROCESSING_ERROR":
		return InvoiceFailureTypeProcessingError, nil
	}
	var t InvoiceFailureType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceFailureType) Ptr() *InvoiceFailureType {
	return &i
}

type InvoiceFeesRequest struct {
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceFeesRequest) GetSourcePlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePlatformMarkupFee
}

func (i *InvoiceFeesRequest) GetDestinationPlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPlatformMarkupFee
}

func (i *InvoiceFeesRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceFeesResponse struct {
	// Fee charged to the platform (C1) for processing the source payment method. For example, credit card interchange and acquiring fees.
	SourcePaymentMethodFee float64 `json:"sourcePaymentMethodFee" url:"sourcePaymentMethodFee"`
	// Fee charged to the payer (C2).
	SourcePlatformMarkupFee float64 `json:"sourcePlatformMarkupFee" url:"sourcePlatformMarkupFee"`
	// Fee charged to the platform (C1) for processing the destination payment method. For example, postage for a check payment.
	DestinationPaymentMethodFee float64 `json:"destinationPaymentMethodFee" url:"destinationPaymentMethodFee"`
	// Fee charged to the payee (C3).
	DestinationPlatformMarkupFee float64 `json:"destinationPlatformMarkupFee" url:"destinationPlatformMarkupFee"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceFeesResponse) GetSourcePaymentMethodFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePaymentMethodFee
}

func (i *InvoiceFeesResponse) GetSourcePlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.SourcePlatformMarkupFee
}

func (i *InvoiceFeesResponse) GetDestinationPaymentMethodFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPaymentMethodFee
}

func (i *InvoiceFeesResponse) GetDestinationPlatformMarkupFee() float64 {
	if i == nil {
		return 0
	}
	return i.DestinationPlatformMarkupFee
}

func (i *InvoiceFeesResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFeesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFeesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFeesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFeesResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceID = string

type InvoiceLineItemCreationRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	Description *string  `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemCreationRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemCreationRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemCreationRequest) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemCreationRequest) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemCreationRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemCreationRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemCreationRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemCreationRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemCreationRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemCreationRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemCreationRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemCreationRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemCreationRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemCreationRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemCreationRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemID = string

type InvoiceLineItemIndividualUpdateRequest struct {
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemIndividualUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemIndividualUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemIndividualUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemIndividualUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemIndividualUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemIndividualUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemIndividualUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemRequestBase struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemRequestBase) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemRequestBase) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemRequestBase) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemRequestBase) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemRequestBase) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemRequestBase
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemRequestBase(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemRequestBase
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemResponse struct {
	ID InvoiceLineItemID `json:"id" url:"id"`
	// Total amount of line item in major units.
	Amount      *float64     `json:"amount,omitempty" url:"amount,omitempty"`
	Currency    CurrencyCode `json:"currency" url:"currency"`
	Description *string      `json:"description,omitempty" url:"description,omitempty"`
	Name        *string      `json:"name,omitempty" url:"name,omitempty"`
	Quantity    *float64     `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of line item in major units.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item. Defaults to 'EXPENSE'.
	Category         string            `json:"category" url:"category"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string   `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	CreatedAt   time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt" url:"updatedAt"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemResponse) GetID() InvoiceLineItemID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceLineItemResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceLineItemResponse) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemResponse) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemResponse) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemResponse) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemResponse) GetCategory() string {
	if i == nil {
		return ""
	}
	return i.Category
}

func (i *InvoiceLineItemResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemResponse) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceLineItemResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceLineItemResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemResponse
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *internal.DateTime `json:"createdAt"`
		UpdatedAt        *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemResponse(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemResponse
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt        *internal.DateTime `json:"createdAt"`
		UpdatedAt        *internal.DateTime `json:"updatedAt"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:        internal.NewDateTime(i.CreatedAt),
		UpdatedAt:        internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceLineItemUpdateRequest struct {
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	Name     *string       `json:"name,omitempty" url:"name,omitempty"`
	Quantity *float64      `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Unit price of the line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	UnitPrice *float64 `json:"unitPrice,omitempty" url:"unitPrice,omitempty"`
	// Category of the line item.
	Category         *string           `json:"category,omitempty" url:"category,omitempty"`
	ServiceStartDate *time.Time        `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time        `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	Metadata         map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// ID of general ledger account associated with this line item.
	GlAccountID *string `json:"glAccountId,omitempty" url:"glAccountId,omitempty"`
	// If provided, will overwrite line item on the invoice with this ID. If not provided, will create a new line item.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Total amount of line item in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount      *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	Description *string  `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceLineItemUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceLineItemUpdateRequest) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

func (i *InvoiceLineItemUpdateRequest) GetQuantity() *float64 {
	if i == nil {
		return nil
	}
	return i.Quantity
}

func (i *InvoiceLineItemUpdateRequest) GetUnitPrice() *float64 {
	if i == nil {
		return nil
	}
	return i.UnitPrice
}

func (i *InvoiceLineItemUpdateRequest) GetCategory() *string {
	if i == nil {
		return nil
	}
	return i.Category
}

func (i *InvoiceLineItemUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceLineItemUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceLineItemUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceLineItemUpdateRequest) GetGlAccountID() *string {
	if i == nil {
		return nil
	}
	return i.GlAccountID
}

func (i *InvoiceLineItemUpdateRequest) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceLineItemUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceLineItemUpdateRequest) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *InvoiceLineItemUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceLineItemUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceLineItemUpdateRequest
	var unmarshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceLineItemUpdateRequest(unmarshaler.embed)
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceLineItemUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceLineItemUpdateRequest
	var marshaler = struct {
		embed
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceLineItemUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsGroupBy string

const (
	InvoiceMetricsGroupByStatus InvoiceMetricsGroupBy = "STATUS"
)

func NewInvoiceMetricsGroupByFromString(s string) (InvoiceMetricsGroupBy, error) {
	switch s {
	case "STATUS":
		return InvoiceMetricsGroupByStatus, nil
	}
	var t InvoiceMetricsGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsGroupBy) Ptr() *InvoiceMetricsGroupBy {
	return &i
}

type InvoiceMetricsPerDateFrequency string

const (
	InvoiceMetricsPerDateFrequencyDaily   InvoiceMetricsPerDateFrequency = "DAILY"
	InvoiceMetricsPerDateFrequencyWeekly  InvoiceMetricsPerDateFrequency = "WEEKLY"
	InvoiceMetricsPerDateFrequencyMonthly InvoiceMetricsPerDateFrequency = "MONTHLY"
	InvoiceMetricsPerDateFrequencyYearly  InvoiceMetricsPerDateFrequency = "YEARLY"
)

func NewInvoiceMetricsPerDateFrequencyFromString(s string) (InvoiceMetricsPerDateFrequency, error) {
	switch s {
	case "DAILY":
		return InvoiceMetricsPerDateFrequencyDaily, nil
	case "WEEKLY":
		return InvoiceMetricsPerDateFrequencyWeekly, nil
	case "MONTHLY":
		return InvoiceMetricsPerDateFrequencyMonthly, nil
	case "YEARLY":
		return InvoiceMetricsPerDateFrequencyYearly, nil
	}
	var t InvoiceMetricsPerDateFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateFrequency) Ptr() *InvoiceMetricsPerDateFrequency {
	return &i
}

type InvoiceMetricsPerDateGroupBy string

const (
	InvoiceMetricsPerDateGroupByCreationDate  InvoiceMetricsPerDateGroupBy = "CREATION_DATE"
	InvoiceMetricsPerDateGroupByDueDate       InvoiceMetricsPerDateGroupBy = "DUE_DATE"
	InvoiceMetricsPerDateGroupByInvoiceDate   InvoiceMetricsPerDateGroupBy = "INVOICE_DATE"
	InvoiceMetricsPerDateGroupByDeductionDate InvoiceMetricsPerDateGroupBy = "DEDUCTION_DATE"
)

func NewInvoiceMetricsPerDateGroupByFromString(s string) (InvoiceMetricsPerDateGroupBy, error) {
	switch s {
	case "CREATION_DATE":
		return InvoiceMetricsPerDateGroupByCreationDate, nil
	case "DUE_DATE":
		return InvoiceMetricsPerDateGroupByDueDate, nil
	case "INVOICE_DATE":
		return InvoiceMetricsPerDateGroupByInvoiceDate, nil
	case "DEDUCTION_DATE":
		return InvoiceMetricsPerDateGroupByDeductionDate, nil
	}
	var t InvoiceMetricsPerDateGroupBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceMetricsPerDateGroupBy) Ptr() *InvoiceMetricsPerDateGroupBy {
	return &i
}

type InvoiceMetricsPerDateResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string `json:"group,omitempty" url:"group,omitempty"`
	Date          time.Time           `json:"date" url:"date"`
	TotalAmount   float64             `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                 `json:"totalCount" url:"totalCount"`
	AverageAmount float64             `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode        `json:"currency" url:"currency"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceMetricsPerDateResponse) GetGroup() []map[string]string {
	if i == nil {
		return nil
	}
	return i.Group
}

func (i *InvoiceMetricsPerDateResponse) GetDate() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.Date
}

func (i *InvoiceMetricsPerDateResponse) GetTotalAmount() float64 {
	if i == nil {
		return 0
	}
	return i.TotalAmount
}

func (i *InvoiceMetricsPerDateResponse) GetTotalCount() int {
	if i == nil {
		return 0
	}
	return i.TotalCount
}

func (i *InvoiceMetricsPerDateResponse) GetAverageAmount() float64 {
	if i == nil {
		return 0
	}
	return i.AverageAmount
}

func (i *InvoiceMetricsPerDateResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceMetricsPerDateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsPerDateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceMetricsPerDateResponse
	var unmarshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceMetricsPerDateResponse(unmarshaler.embed)
	i.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsPerDateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceMetricsPerDateResponse
	var marshaler = struct {
		embed
		Date *internal.DateTime `json:"date"`
	}{
		embed: embed(*i),
		Date:  internal.NewDateTime(i.Date),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceMetricsPerDateResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceMetricsResponse struct {
	// If groupBy is provided, this will be the group by value.
	Group         []map[string]string                       `json:"group,omitempty" url:"group,omitempty"`
	TotalAmount   float64                                   `json:"totalAmount" url:"totalAmount"`
	TotalCount    int                                       `json:"totalCount" url:"totalCount"`
	AverageAmount float64                                   `json:"averageAmount" url:"averageAmount"`
	Currency      CurrencyCode                              `json:"currency" url:"currency"`
	Dates         map[string]*InvoiceMetricsPerDateResponse `json:"dates,omitempty" url:"dates,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceMetricsResponse) GetGroup() []map[string]string {
	if i == nil {
		return nil
	}
	return i.Group
}

func (i *InvoiceMetricsResponse) GetTotalAmount() float64 {
	if i == nil {
		return 0
	}
	return i.TotalAmount
}

func (i *InvoiceMetricsResponse) GetTotalCount() int {
	if i == nil {
		return 0
	}
	return i.TotalCount
}

func (i *InvoiceMetricsResponse) GetAverageAmount() float64 {
	if i == nil {
		return 0
	}
	return i.AverageAmount
}

func (i *InvoiceMetricsResponse) GetCurrency() CurrencyCode {
	if i == nil {
		return ""
	}
	return i.Currency
}

func (i *InvoiceMetricsResponse) GetDates() map[string]*InvoiceMetricsPerDateResponse {
	if i == nil {
		return nil
	}
	return i.Dates
}

func (i *InvoiceMetricsResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceMetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceMetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceMetricsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceMetricsResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceOrderByField string

const (
	InvoiceOrderByFieldAmount         InvoiceOrderByField = "AMOUNT"
	InvoiceOrderByFieldDueDate        InvoiceOrderByField = "DUE_DATE"
	InvoiceOrderByFieldCreatedAt      InvoiceOrderByField = "CREATED_AT"
	InvoiceOrderByFieldUpdatedAt      InvoiceOrderByField = "UPDATED_AT"
	InvoiceOrderByFieldDeductionDate  InvoiceOrderByField = "DEDUCTION_DATE"
	InvoiceOrderByFieldInvoiceDate    InvoiceOrderByField = "INVOICE_DATE"
	InvoiceOrderByFieldSettlementDate InvoiceOrderByField = "SETTLEMENT_DATE"
	InvoiceOrderByFieldInvoiceNumber  InvoiceOrderByField = "INVOICE_NUMBER"
	InvoiceOrderByFieldVendorName     InvoiceOrderByField = "VENDOR_NAME"
	InvoiceOrderByFieldPayerName      InvoiceOrderByField = "PAYER_NAME"
)

func NewInvoiceOrderByFieldFromString(s string) (InvoiceOrderByField, error) {
	switch s {
	case "AMOUNT":
		return InvoiceOrderByFieldAmount, nil
	case "DUE_DATE":
		return InvoiceOrderByFieldDueDate, nil
	case "CREATED_AT":
		return InvoiceOrderByFieldCreatedAt, nil
	case "UPDATED_AT":
		return InvoiceOrderByFieldUpdatedAt, nil
	case "DEDUCTION_DATE":
		return InvoiceOrderByFieldDeductionDate, nil
	case "INVOICE_DATE":
		return InvoiceOrderByFieldInvoiceDate, nil
	case "SETTLEMENT_DATE":
		return InvoiceOrderByFieldSettlementDate, nil
	case "INVOICE_NUMBER":
		return InvoiceOrderByFieldInvoiceNumber, nil
	case "VENDOR_NAME":
		return InvoiceOrderByFieldVendorName, nil
	case "PAYER_NAME":
		return InvoiceOrderByFieldPayerName, nil
	}
	var t InvoiceOrderByField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceOrderByField) Ptr() *InvoiceOrderByField {
	return &i
}

type InvoiceRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms *int `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// Options for the payment source. Depending on the payment source, this may include things such as BNPL configuration.
	PaymentSourceOptions *PaymentSourceOptions `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	// Set to true if the payment destination has been confirmed by the vendor or if the payment destination should default to the selected payment destination on the vendor portal.
	PaymentDestinationConfirmed *bool `json:"paymentDestinationConfirmed,omitempty" url:"paymentDestinationConfirmed,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRequestBase) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceRequestBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceRequestBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceRequestBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceRequestBase) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceRequestBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceRequestBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceRequestBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceRequestBase) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceRequestBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceRequestBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceRequestBase) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceRequestBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceRequestBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceRequestBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceRequestBase) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceRequestBase) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceRequestBase) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceRequestBase) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceRequestBase) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceRequestBase) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceRequestBase) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceRequestBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceRequestBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceRequestBase) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceRequestBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceRequestBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceRequestBase) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceRequestBase) GetPaymentDestinationConfirmed() *bool {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate          *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber    *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms                  *int                            `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	PayerID                   *EntityID                       `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse           `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse          `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID                `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	PaymentSourceOptions      *PaymentSourceOptions           `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	VendorID                  *EntityID                       `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse           `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse          `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID                `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions      `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	PaymentTiming             *CalculatePaymentTimingResponse `json:"paymentTiming,omitempty" url:"paymentTiming,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	ID       InvoiceID `json:"id" url:"id"`
	// Date when the invoice payment was processed.
	ProcessedAt *time.Time `json:"processedAt,omitempty" url:"processedAt,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// If the invoice failed to be paid, this field will be populated with the type of failure.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// Transactions associated with this invoice.
	Transactions []*TransactionResponseWithoutInvoices `json:"transactions,omitempty" url:"transactions,omitempty"`
	// The IDs of the vendor credits that are currently applied to this invoice.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceResponse) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceResponse) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceResponse) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceResponse) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceResponse) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceResponse) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceResponse) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceResponse) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceResponse) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceResponse) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceResponse) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceResponse) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceResponse) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceResponse) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceResponse) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceResponse) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceResponse) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceResponse) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceResponse) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceResponse) GetPaymentTiming() *CalculatePaymentTimingResponse {
	if i == nil {
		return nil
	}
	return i.PaymentTiming
}

func (i *InvoiceResponse) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceResponse) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceResponse) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceResponse) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceResponse) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceResponse) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceResponse) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceResponse) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceResponse) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceResponse) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceResponse) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceResponse) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceResponse) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceResponse) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceResponse) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceResponse) GetID() InvoiceID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceResponse) GetProcessedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.ProcessedAt
}

func (i *InvoiceResponse) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceResponse) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceResponse) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceResponse) GetTransactions() []*TransactionResponseWithoutInvoices {
	if i == nil {
		return nil
	}
	return i.Transactions
}

func (i *InvoiceResponse) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
		ProcessedAt       *internal.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *internal.DateTime `json:"settlementDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	i.ProcessedAt = unmarshaler.ProcessedAt.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponse
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
		ProcessedAt       *internal.DateTime `json:"processedAt,omitempty"`
		SettlementDate    *internal.DateTime `json:"settlementDate,omitempty"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
		ProcessedAt:       internal.NewOptionalDateTime(i.ProcessedAt),
		SettlementDate:    internal.NewOptionalDateTime(i.SettlementDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceResponseBase struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate          *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber    *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms                  *int                            `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	PayerID                   *EntityID                       `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse           `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse          `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID                `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	PaymentSourceOptions      *PaymentSourceOptions           `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	VendorID                  *EntityID                       `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse           `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse          `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID                `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions      `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	PaymentTiming             *CalculatePaymentTimingResponse `json:"paymentTiming,omitempty" url:"paymentTiming,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceResponseBase) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceResponseBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceResponseBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceResponseBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceResponseBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceResponseBase) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceResponseBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceResponseBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceResponseBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceResponseBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceResponseBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceResponseBase) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceResponseBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceResponseBase) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceResponseBase) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceResponseBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceResponseBase) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceResponseBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceResponseBase) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceResponseBase) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceResponseBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceResponseBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceResponseBase) GetPaymentTiming() *CalculatePaymentTimingResponse {
	if i == nil {
		return nil
	}
	return i.PaymentTiming
}

func (i *InvoiceResponseBase) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceResponseBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceResponseBase) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceResponseBase) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceResponseBase) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceResponseBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceResponseBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceResponseBase) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceResponseBase) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceResponseBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceResponseBase) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceResponseBase) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceResponseBase) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceResponseBase) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceResponseBase) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceResponseBase) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceResponseBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceResponseBase) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceResponseBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceResponseBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceResponseBase
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceResponseBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceResponseBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceResponseBase
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceResponseBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceStatus string

const (
	InvoiceStatusUnassigned InvoiceStatus = "UNASSIGNED"
	InvoiceStatusDraft      InvoiceStatus = "DRAFT"
	InvoiceStatusNew        InvoiceStatus = "NEW"
	InvoiceStatusApproved   InvoiceStatus = "APPROVED"
	InvoiceStatusScheduled  InvoiceStatus = "SCHEDULED"
	InvoiceStatusPending    InvoiceStatus = "PENDING"
	InvoiceStatusPaid       InvoiceStatus = "PAID"
	InvoiceStatusArchived   InvoiceStatus = "ARCHIVED"
	InvoiceStatusRefused    InvoiceStatus = "REFUSED"
	InvoiceStatusCanceled   InvoiceStatus = "CANCELED"
	InvoiceStatusFailed     InvoiceStatus = "FAILED"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "UNASSIGNED":
		return InvoiceStatusUnassigned, nil
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "NEW":
		return InvoiceStatusNew, nil
	case "APPROVED":
		return InvoiceStatusApproved, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PENDING":
		return InvoiceStatusPending, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "ARCHIVED":
		return InvoiceStatusArchived, nil
	case "REFUSED":
		return InvoiceStatusRefused, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

type InvoiceTemplateCreationRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                          `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	LineItems      []*InvoiceLineItemCreationRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID of the entity who created this invoice template.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateCreationRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateCreationRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateCreationRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateCreationRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateCreationRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateCreationRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateCreationRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateCreationRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateCreationRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateCreationRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateCreationRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateCreationRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateCreationRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateCreationRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateCreationRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateCreationRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateCreationRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateCreationRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateCreationRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateCreationRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateCreationRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateCreationRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateCreationRequest) GetLineItems() []*InvoiceLineItemCreationRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateCreationRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateCreationRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateCreationRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateCreationRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateCreationRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateCreationRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateCreationRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateCreationRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateID = string

type InvoiceTemplateRequestBase struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateRequestBase) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateRequestBase) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateRequestBase) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateRequestBase) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateRequestBase) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateRequestBase) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateRequestBase) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateRequestBase) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateRequestBase) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateRequestBase) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateRequestBase) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateRequestBase) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateRequestBase) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateRequestBase) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateRequestBase) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateRequestBase) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateRequestBase) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateRequestBase) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateRequestBase) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateRequestBase) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateRequestBase) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateRequestBase) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateRequestBase) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateRequestBase) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateRequestBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateRequestBase) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateRequestBase
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateRequestBase(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateRequestBase) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateRequestBase
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateRequestBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateResponse struct {
	Status InvoiceStatus `json:"status" url:"status"`
	// Total amount of invoice in major units
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account. The actual deduction date may differ from this date, and will be reflected in the processedAt field.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// For invoice templates, this is the date when the next recurring payment will be scheduled.
	NextDeductionDate *time.Time `json:"nextDeductionDate,omitempty" url:"nextDeductionDate,omitempty"`
	// Due date of invoice.
	DueDate          *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber    *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms                  *int                            `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	PayerID                   *EntityID                       `json:"payerId,omitempty" url:"payerId,omitempty"`
	Payer                     *CounterpartyResponse           `json:"payer,omitempty" url:"payer,omitempty"`
	PaymentSource             *PaymentMethodResponse          `json:"paymentSource,omitempty" url:"paymentSource,omitempty"`
	PaymentSourceID           *PaymentMethodID                `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	PaymentSourceOptions      *PaymentSourceOptions           `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	VendorID                  *EntityID                       `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	Vendor                    *CounterpartyResponse           `json:"vendor,omitempty" url:"vendor,omitempty"`
	PaymentDestination        *PaymentMethodResponse          `json:"paymentDestination,omitempty" url:"paymentDestination,omitempty"`
	PaymentDestinationID      *PaymentMethodID                `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	PaymentDestinationOptions *PaymentDestinationOptions      `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	PaymentTiming             *CalculatePaymentTimingResponse `json:"paymentTiming,omitempty" url:"paymentTiming,omitempty"`
	// True if the payment destination has been confirmed by the vendor. False if the payment destination has been set (for example, a check to an address) but has not been confirmed by the vendor.
	PaymentDestinationConfirmed bool `json:"paymentDestinationConfirmed" url:"paymentDestinationConfirmed"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// True if the invoice has documents attached.
	HasDocuments bool `json:"hasDocuments" url:"hasDocuments"`
	// True if the invoice was created by an incoming email.
	HasSourceEmail bool                       `json:"hasSourceEmail" url:"hasSourceEmail"`
	LineItems      []*InvoiceLineItemResponse `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                  `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	Approvers      []*ApprovalSlot           `json:"approvers,omitempty" url:"approvers,omitempty"`
	ApprovalPolicy []*ApprovalPolicyResponse `json:"approvalPolicy,omitempty" url:"approvalPolicy,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID of the entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// Entity user who created this invoice.
	CreatorUser *EntityUserResponse `json:"creatorUser,omitempty" url:"creatorUser,omitempty"`
	CreatedAt   time.Time           `json:"createdAt" url:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt" url:"updatedAt"`
	Comments    []*CommentResponse  `json:"comments,omitempty" url:"comments,omitempty"`
	// Fees associated with this invoice.
	Fees *InvoiceFeesResponse `json:"fees,omitempty" url:"fees,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID         `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	ID       InvoiceTemplateID `json:"id" url:"id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateResponse) GetStatus() InvoiceStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InvoiceTemplateResponse) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateResponse) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateResponse) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateResponse) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateResponse) GetNextDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.NextDeductionDate
}

func (i *InvoiceTemplateResponse) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateResponse) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateResponse) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateResponse) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateResponse) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateResponse) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceTemplateResponse) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateResponse) GetPayer() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Payer
}

func (i *InvoiceTemplateResponse) GetPaymentSource() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentSource
}

func (i *InvoiceTemplateResponse) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateResponse) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceTemplateResponse) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateResponse) GetVendor() *CounterpartyResponse {
	if i == nil {
		return nil
	}
	return i.Vendor
}

func (i *InvoiceTemplateResponse) GetPaymentDestination() *PaymentMethodResponse {
	if i == nil {
		return nil
	}
	return i.PaymentDestination
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateResponse) GetPaymentTiming() *CalculatePaymentTimingResponse {
	if i == nil {
		return nil
	}
	return i.PaymentTiming
}

func (i *InvoiceTemplateResponse) GetPaymentDestinationConfirmed() bool {
	if i == nil {
		return false
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceTemplateResponse) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateResponse) GetHasDocuments() bool {
	if i == nil {
		return false
	}
	return i.HasDocuments
}

func (i *InvoiceTemplateResponse) GetHasSourceEmail() bool {
	if i == nil {
		return false
	}
	return i.HasSourceEmail
}

func (i *InvoiceTemplateResponse) GetLineItems() []*InvoiceLineItemResponse {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateResponse) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateResponse) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateResponse) GetApprovers() []*ApprovalSlot {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateResponse) GetApprovalPolicy() []*ApprovalPolicyResponse {
	if i == nil {
		return nil
	}
	return i.ApprovalPolicy
}

func (i *InvoiceTemplateResponse) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateResponse) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateResponse) GetCreatorUser() *EntityUserResponse {
	if i == nil {
		return nil
	}
	return i.CreatorUser
}

func (i *InvoiceTemplateResponse) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InvoiceTemplateResponse) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InvoiceTemplateResponse) GetComments() []*CommentResponse {
	if i == nil {
		return nil
	}
	return i.Comments
}

func (i *InvoiceTemplateResponse) GetFees() *InvoiceFeesResponse {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateResponse) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateResponse) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceTemplateResponse) GetID() InvoiceTemplateID {
	if i == nil {
		return ""
	}
	return i.ID
}

func (i *InvoiceTemplateResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateResponse) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateResponse
	var unmarshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateResponse(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.NextDeductionDate = unmarshaler.NextDeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateResponse) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateResponse
	var marshaler = struct {
		embed
		InvoiceDate       *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate     *internal.DateTime `json:"deductionDate,omitempty"`
		NextDeductionDate *internal.DateTime `json:"nextDeductionDate,omitempty"`
		DueDate           *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate  *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate    *internal.DateTime `json:"serviceEndDate,omitempty"`
		CreatedAt         *internal.DateTime `json:"createdAt"`
		UpdatedAt         *internal.DateTime `json:"updatedAt"`
	}{
		embed:             embed(*i),
		InvoiceDate:       internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:     internal.NewOptionalDateTime(i.DeductionDate),
		NextDeductionDate: internal.NewOptionalDateTime(i.NextDeductionDate),
		DueDate:           internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate:  internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:    internal.NewOptionalDateTime(i.ServiceEndDate),
		CreatedAt:         internal.NewDateTime(i.CreatedAt),
		UpdatedAt:         internal.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceTemplateUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64                        `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	LineItems      []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceTemplateUpdateRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceTemplateUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceTemplateUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceTemplateUpdateRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceTemplateUpdateRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceTemplateUpdateRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceTemplateUpdateRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceTemplateUpdateRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceTemplateUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceTemplateUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceTemplateUpdateRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceTemplateUpdateRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceTemplateUpdateRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceTemplateUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceTemplateUpdateRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceTemplateUpdateRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceTemplateUpdateRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceTemplateUpdateRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceTemplateUpdateRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceTemplateUpdateRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceTemplateUpdateRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceTemplateUpdateRequest) GetLineItems() []*InvoiceLineItemUpdateRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceTemplateUpdateRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceTemplateUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceTemplateUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceTemplateUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceTemplateUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceTemplateUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceTemplateUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceTemplateUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdateRequest struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms *int `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// Options for the payment source. Depending on the payment source, this may include things such as BNPL configuration.
	PaymentSourceOptions *PaymentSourceOptions `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	// Set to true if the payment destination has been confirmed by the vendor or if the payment destination should default to the selected payment destination on the vendor portal.
	PaymentDestinationConfirmed *bool                           `json:"paymentDestinationConfirmed,omitempty" url:"paymentDestinationConfirmed,omitempty"`
	LineItems                   []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdateRequest) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceUpdateRequest) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceUpdateRequest) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceUpdateRequest) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceUpdateRequest) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceUpdateRequest) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceUpdateRequest) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceUpdateRequest) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceUpdateRequest) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceUpdateRequest) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceUpdateRequest) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceUpdateRequest) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceUpdateRequest) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceUpdateRequest) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceUpdateRequest) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceUpdateRequest) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceUpdateRequest) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceUpdateRequest) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceUpdateRequest) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceUpdateRequest) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceUpdateRequest) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceUpdateRequest) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceUpdateRequest) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceUpdateRequest) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceUpdateRequest) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceUpdateRequest) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceUpdateRequest) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceUpdateRequest) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceUpdateRequest) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceUpdateRequest) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceUpdateRequest) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceUpdateRequest) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceUpdateRequest) GetPaymentDestinationConfirmed() *bool {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceUpdateRequest) GetLineItems() []*InvoiceLineItemUpdateRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceUpdateRequest) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceUpdateRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdateRequest) UnmarshalJSON(data []byte) error {
	type embed InvoiceUpdateRequest
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceUpdateRequest(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdateRequest) MarshalJSON() ([]byte, error) {
	type embed InvoiceUpdateRequest
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceUpdateRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdateRequestWithID struct {
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// Total amount of invoice in major units. If the entered amount has more decimal places than the currency supports, trailing decimals will be truncated.
	Amount *float64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Currency code for the amount. Defaults to USD.
	Currency *CurrencyCode `json:"currency,omitempty" url:"currency,omitempty"`
	// Date the invoice was issued.
	InvoiceDate *time.Time `json:"invoiceDate,omitempty" url:"invoiceDate,omitempty"`
	// Initial date when funds are scheduled to be deducted from payer's account.
	DeductionDate *time.Time `json:"deductionDate,omitempty" url:"deductionDate,omitempty"`
	// Date of funds settlement.
	SettlementDate *time.Time `json:"settlementDate,omitempty" url:"settlementDate,omitempty"`
	// Due date of invoice.
	DueDate       *time.Time `json:"dueDate,omitempty" url:"dueDate,omitempty"`
	InvoiceNumber *string    `json:"invoiceNumber,omitempty" url:"invoiceNumber,omitempty"`
	// Note to self or memo on invoice.
	NoteToSelf       *string    `json:"noteToSelf,omitempty" url:"noteToSelf,omitempty"`
	ServiceStartDate *time.Time `json:"serviceStartDate,omitempty" url:"serviceStartDate,omitempty"`
	ServiceEndDate   *time.Time `json:"serviceEndDate,omitempty" url:"serviceEndDate,omitempty"`
	// Net terms in days. Must be a positive number.
	NetTerms *int `json:"netTerms,omitempty" url:"netTerms,omitempty"`
	// ID or foreign ID of the payer of this invoice.
	PayerID *EntityID `json:"payerId,omitempty" url:"payerId,omitempty"`
	// ID of payment source for this invoice. If not provided, will attempt to use the default payment source for the payer when creating an invoice if a default payment source exists for the payer.
	PaymentSourceID *PaymentMethodID `json:"paymentSourceId,omitempty" url:"paymentSourceId,omitempty"`
	// Options for the payment source. Depending on the payment source, this may include things such as BNPL configuration.
	PaymentSourceOptions *PaymentSourceOptions `json:"paymentSourceOptions,omitempty" url:"paymentSourceOptions,omitempty"`
	// ID or foreign ID of the vendor of this invoice.
	VendorID *EntityID `json:"vendorId,omitempty" url:"vendorId,omitempty"`
	// ID of payment destination for this invoice. If not provided, will attempt to use the default payment destination for the vendor when creating an invoice if a default payment destination exists for the vendor.
	PaymentDestinationID *PaymentMethodID `json:"paymentDestinationId,omitempty" url:"paymentDestinationId,omitempty"`
	// Options for the payment destination. Depending on the payment destination, this may include things such as check delivery method.
	PaymentDestinationOptions *PaymentDestinationOptions `json:"paymentDestinationOptions,omitempty" url:"paymentDestinationOptions,omitempty"`
	// Set approvers for this invoice.
	Approvers []*ApprovalSlotAssignment `json:"approvers,omitempty" url:"approvers,omitempty"`
	// Metadata associated with this invoice.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The ID used to identify this invoice in your system. This ID must be unique within each creatorEntity in your system, e.g. two invoices with the same creatorEntity may not have the same foreign ID.
	ForeignID *string `json:"foreignId,omitempty" url:"foreignId,omitempty"`
	// Base64-encoded string. Supported file types include PNG, JPG, WEBP, PDF, and all Microsoft Office formats (automatically converted to PDF). Max file size 10MB. If the invoice already has a document, this will add a new document to the invoice.
	Document *string `json:"document,omitempty" url:"document,omitempty"`
	// DEPRECATED. Use document field instead.
	UploadedImage *string `json:"uploadedImage,omitempty" url:"uploadedImage,omitempty"`
	// User ID or Foreign ID of entity user who created this invoice.
	CreatorUserID *EntityUserID `json:"creatorUserId,omitempty" url:"creatorUserId,omitempty"`
	// If the invoice failed to be paid, indicate the failure reason. Only applicable for invoices with custom payment methods.
	FailureType *InvoiceFailureType `json:"failureType,omitempty" url:"failureType,omitempty"`
	// If using a custom payment method, you can override the default fees for this invoice. If not provided, the default fees for the custom payment method will be used.
	Fees *InvoiceFeesRequest `json:"fees,omitempty" url:"fees,omitempty"`
	// If true, this invoice will be paid as a batch payment. Batches are automatically determined by Mercoa based on the payment source, destination, and scheduled payment date.
	BatchPayment *bool `json:"batchPayment,omitempty" url:"batchPayment,omitempty"`
	// If this is a recurring invoice, this will be the payment schedule for the invoice. If not provided, this will be a one-time invoice.
	PaymentSchedule *PaymentSchedule `json:"paymentSchedule,omitempty" url:"paymentSchedule,omitempty"`
	// The IDs of the vendor credits to be applied to this invoice. Passing this field will un-apply any previously applied vendor credits.
	VendorCreditIDs []VendorCreditID `json:"vendorCreditIds,omitempty" url:"vendorCreditIds,omitempty"`
	// Tax amount for this invoice.
	TaxAmount *float64 `json:"taxAmount,omitempty" url:"taxAmount,omitempty"`
	// Shipping amount for this invoice.
	ShippingAmount *float64 `json:"shippingAmount,omitempty" url:"shippingAmount,omitempty"`
	// ID of the OCR job that processed this invoice.
	OcrJobID *OcrJobID `json:"ocrJobId,omitempty" url:"ocrJobId,omitempty"`
	// Set to true if the payment destination has been confirmed by the vendor or if the payment destination should default to the selected payment destination on the vendor portal.
	PaymentDestinationConfirmed *bool                           `json:"paymentDestinationConfirmed,omitempty" url:"paymentDestinationConfirmed,omitempty"`
	LineItems                   []*InvoiceLineItemUpdateRequest `json:"lineItems,omitempty" url:"lineItems,omitempty"`
	// ID or foreign ID of entity who created this invoice. If creating a payable invoice (AP), this must be the same as the payerId. If creating a receivable invoice (AR), this must be the same as the vendorId.
	CreatorEntityID *EntityID `json:"creatorEntityId,omitempty" url:"creatorEntityId,omitempty"`
	// The ID or foreign ID of the invoice to update
	InvoiceID InvoiceID `json:"invoiceId" url:"invoiceId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdateRequestWithID) GetStatus() *InvoiceStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InvoiceUpdateRequestWithID) GetAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InvoiceUpdateRequestWithID) GetCurrency() *CurrencyCode {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InvoiceUpdateRequestWithID) GetInvoiceDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.InvoiceDate
}

func (i *InvoiceUpdateRequestWithID) GetDeductionDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DeductionDate
}

func (i *InvoiceUpdateRequestWithID) GetSettlementDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.SettlementDate
}

func (i *InvoiceUpdateRequestWithID) GetDueDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.DueDate
}

func (i *InvoiceUpdateRequestWithID) GetInvoiceNumber() *string {
	if i == nil {
		return nil
	}
	return i.InvoiceNumber
}

func (i *InvoiceUpdateRequestWithID) GetNoteToSelf() *string {
	if i == nil {
		return nil
	}
	return i.NoteToSelf
}

func (i *InvoiceUpdateRequestWithID) GetServiceStartDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceStartDate
}

func (i *InvoiceUpdateRequestWithID) GetServiceEndDate() *time.Time {
	if i == nil {
		return nil
	}
	return i.ServiceEndDate
}

func (i *InvoiceUpdateRequestWithID) GetNetTerms() *int {
	if i == nil {
		return nil
	}
	return i.NetTerms
}

func (i *InvoiceUpdateRequestWithID) GetPayerID() *EntityID {
	if i == nil {
		return nil
	}
	return i.PayerID
}

func (i *InvoiceUpdateRequestWithID) GetPaymentSourceID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentSourceID
}

func (i *InvoiceUpdateRequestWithID) GetPaymentSourceOptions() *PaymentSourceOptions {
	if i == nil {
		return nil
	}
	return i.PaymentSourceOptions
}

func (i *InvoiceUpdateRequestWithID) GetVendorID() *EntityID {
	if i == nil {
		return nil
	}
	return i.VendorID
}

func (i *InvoiceUpdateRequestWithID) GetPaymentDestinationID() *PaymentMethodID {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationID
}

func (i *InvoiceUpdateRequestWithID) GetPaymentDestinationOptions() *PaymentDestinationOptions {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationOptions
}

func (i *InvoiceUpdateRequestWithID) GetApprovers() []*ApprovalSlotAssignment {
	if i == nil {
		return nil
	}
	return i.Approvers
}

func (i *InvoiceUpdateRequestWithID) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InvoiceUpdateRequestWithID) GetForeignID() *string {
	if i == nil {
		return nil
	}
	return i.ForeignID
}

func (i *InvoiceUpdateRequestWithID) GetDocument() *string {
	if i == nil {
		return nil
	}
	return i.Document
}

func (i *InvoiceUpdateRequestWithID) GetUploadedImage() *string {
	if i == nil {
		return nil
	}
	return i.UploadedImage
}

func (i *InvoiceUpdateRequestWithID) GetCreatorUserID() *EntityUserID {
	if i == nil {
		return nil
	}
	return i.CreatorUserID
}

func (i *InvoiceUpdateRequestWithID) GetFailureType() *InvoiceFailureType {
	if i == nil {
		return nil
	}
	return i.FailureType
}

func (i *InvoiceUpdateRequestWithID) GetFees() *InvoiceFeesRequest {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InvoiceUpdateRequestWithID) GetBatchPayment() *bool {
	if i == nil {
		return nil
	}
	return i.BatchPayment
}

func (i *InvoiceUpdateRequestWithID) GetPaymentSchedule() *PaymentSchedule {
	if i == nil {
		return nil
	}
	return i.PaymentSchedule
}

func (i *InvoiceUpdateRequestWithID) GetVendorCreditIDs() []VendorCreditID {
	if i == nil {
		return nil
	}
	return i.VendorCreditIDs
}

func (i *InvoiceUpdateRequestWithID) GetTaxAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.TaxAmount
}

func (i *InvoiceUpdateRequestWithID) GetShippingAmount() *float64 {
	if i == nil {
		return nil
	}
	return i.ShippingAmount
}

func (i *InvoiceUpdateRequestWithID) GetOcrJobID() *OcrJobID {
	if i == nil {
		return nil
	}
	return i.OcrJobID
}

func (i *InvoiceUpdateRequestWithID) GetPaymentDestinationConfirmed() *bool {
	if i == nil {
		return nil
	}
	return i.PaymentDestinationConfirmed
}

func (i *InvoiceUpdateRequestWithID) GetLineItems() []*InvoiceLineItemUpdateRequest {
	if i == nil {
		return nil
	}
	return i.LineItems
}

func (i *InvoiceUpdateRequestWithID) GetCreatorEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.CreatorEntityID
}

func (i *InvoiceUpdateRequestWithID) GetInvoiceID() InvoiceID {
	if i == nil {
		return ""
	}
	return i.InvoiceID
}

func (i *InvoiceUpdateRequestWithID) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdateRequestWithID) UnmarshalJSON(data []byte) error {
	type embed InvoiceUpdateRequestWithID
	var unmarshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InvoiceUpdateRequestWithID(unmarshaler.embed)
	i.InvoiceDate = unmarshaler.InvoiceDate.TimePtr()
	i.DeductionDate = unmarshaler.DeductionDate.TimePtr()
	i.SettlementDate = unmarshaler.SettlementDate.TimePtr()
	i.DueDate = unmarshaler.DueDate.TimePtr()
	i.ServiceStartDate = unmarshaler.ServiceStartDate.TimePtr()
	i.ServiceEndDate = unmarshaler.ServiceEndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdateRequestWithID) MarshalJSON() ([]byte, error) {
	type embed InvoiceUpdateRequestWithID
	var marshaler = struct {
		embed
		InvoiceDate      *internal.DateTime `json:"invoiceDate,omitempty"`
		DeductionDate    *internal.DateTime `json:"deductionDate,omitempty"`
		SettlementDate   *internal.DateTime `json:"settlementDate,omitempty"`
		DueDate          *internal.DateTime `json:"dueDate,omitempty"`
		ServiceStartDate *internal.DateTime `json:"serviceStartDate,omitempty"`
		ServiceEndDate   *internal.DateTime `json:"serviceEndDate,omitempty"`
	}{
		embed:            embed(*i),
		InvoiceDate:      internal.NewOptionalDateTime(i.InvoiceDate),
		DeductionDate:    internal.NewOptionalDateTime(i.DeductionDate),
		SettlementDate:   internal.NewOptionalDateTime(i.SettlementDate),
		DueDate:          internal.NewOptionalDateTime(i.DueDate),
		ServiceStartDate: internal.NewOptionalDateTime(i.ServiceStartDate),
		ServiceEndDate:   internal.NewOptionalDateTime(i.ServiceEndDate),
	}
	return json.Marshal(marshaler)
}

func (i *InvoiceUpdateRequestWithID) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MetadataFilter struct {
	Key string `json:"key" url:"key"`
	// If multiple values are provided, the filter will match if any of the values match (OR filter). To filter for the absence of a key, use the value 'NULL'. To filter for the presence of a key, use the value 'NOT NULL'.
	Value *StringOrStringArray `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetadataFilter) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MetadataFilter) GetValue() *StringOrStringArray {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MetadataFilter) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataFilter) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaymentDestinationOptions struct {
	Type        string
	Check       *CheckPaymentDestinationOptions
	BankAccount *BankAccountPaymentDestinationOptions
	Utility     *UtilityPaymentDestinationOptions
	Custom      *CustomPaymentDestinationOptions
}

func (p *PaymentDestinationOptions) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentDestinationOptions) GetCheck() *CheckPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.Check
}

func (p *PaymentDestinationOptions) GetBankAccount() *BankAccountPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.BankAccount
}

func (p *PaymentDestinationOptions) GetUtility() *UtilityPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.Utility
}

func (p *PaymentDestinationOptions) GetCustom() *CustomPaymentDestinationOptions {
	if p == nil {
		return nil
	}
	return p.Custom
}

func (p *PaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "check":
		value := new(CheckPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Check = value
	case "bankAccount":
		value := new(BankAccountPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.BankAccount = value
	case "utility":
		value := new(UtilityPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Utility = value
	case "custom":
		value := new(CustomPaymentDestinationOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Custom = value
	}
	return nil
}

func (p PaymentDestinationOptions) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Check != nil {
		return internal.MarshalJSONWithExtraProperty(p.Check, "type", "check")
	}
	if p.BankAccount != nil {
		return internal.MarshalJSONWithExtraProperty(p.BankAccount, "type", "bankAccount")
	}
	if p.Utility != nil {
		return internal.MarshalJSONWithExtraProperty(p.Utility, "type", "utility")
	}
	if p.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(p.Custom, "type", "custom")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentDestinationOptionsVisitor interface {
	VisitCheck(*CheckPaymentDestinationOptions) error
	VisitBankAccount(*BankAccountPaymentDestinationOptions) error
	VisitUtility(*UtilityPaymentDestinationOptions) error
	VisitCustom(*CustomPaymentDestinationOptions) error
}

func (p *PaymentDestinationOptions) Accept(visitor PaymentDestinationOptionsVisitor) error {
	if p.Check != nil {
		return visitor.VisitCheck(p.Check)
	}
	if p.BankAccount != nil {
		return visitor.VisitBankAccount(p.BankAccount)
	}
	if p.Utility != nil {
		return visitor.VisitUtility(p.Utility)
	}
	if p.Custom != nil {
		return visitor.VisitCustom(p.Custom)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentDestinationOptions) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Check != nil {
		fields = append(fields, "check")
	}
	if p.BankAccount != nil {
		fields = append(fields, "bankAccount")
	}
	if p.Utility != nil {
		fields = append(fields, "utility")
	}
	if p.Custom != nil {
		fields = append(fields, "custom")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentMonthSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// deprecated. will be removed in the future and will always be 0.
	DayOffset *int `json:"dayOffset,omitempty" url:"dayOffset,omitempty"`
	// Day of the month to repeat on. Positive values (1-31): Represent the day of the month counting from the start (e.g., 10 is the 10th day of the month). Negative values (-1 to -31): Represent the day of the month counting backward from the end (e.g., -1 is the last day of the month, -2 is the second-to-last day).
	RepeatOnDay int `json:"repeatOnDay" url:"repeatOnDay"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMonthSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentMonthSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentMonthSchedule) GetDayOffset() *int {
	if p == nil {
		return nil
	}
	return p.DayOffset
}

func (p *PaymentMonthSchedule) GetRepeatOnDay() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnDay
}

func (p *PaymentMonthSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMonthSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMonthSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMonthSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMonthSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentSchedule struct {
	Type    string
	OneTime *PaymentScheduleBase
	Daily   *PaymentScheduleBase
	Weekly  *PaymentWeekSchedule
	Monthly *PaymentMonthSchedule
	Yearly  *PaymentYearSchedule
}

func (p *PaymentSchedule) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentSchedule) GetOneTime() *PaymentScheduleBase {
	if p == nil {
		return nil
	}
	return p.OneTime
}

func (p *PaymentSchedule) GetDaily() *PaymentScheduleBase {
	if p == nil {
		return nil
	}
	return p.Daily
}

func (p *PaymentSchedule) GetWeekly() *PaymentWeekSchedule {
	if p == nil {
		return nil
	}
	return p.Weekly
}

func (p *PaymentSchedule) GetMonthly() *PaymentMonthSchedule {
	if p == nil {
		return nil
	}
	return p.Monthly
}

func (p *PaymentSchedule) GetYearly() *PaymentYearSchedule {
	if p == nil {
		return nil
	}
	return p.Yearly
}

func (p *PaymentSchedule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "oneTime":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.OneTime = value
	case "daily":
		value := new(PaymentScheduleBase)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Daily = value
	case "weekly":
		value := new(PaymentWeekSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Weekly = value
	case "monthly":
		value := new(PaymentMonthSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Monthly = value
	case "yearly":
		value := new(PaymentYearSchedule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Yearly = value
	}
	return nil
}

func (p PaymentSchedule) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.OneTime != nil {
		return internal.MarshalJSONWithExtraProperty(p.OneTime, "type", "oneTime")
	}
	if p.Daily != nil {
		return internal.MarshalJSONWithExtraProperty(p.Daily, "type", "daily")
	}
	if p.Weekly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Weekly, "type", "weekly")
	}
	if p.Monthly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Monthly, "type", "monthly")
	}
	if p.Yearly != nil {
		return internal.MarshalJSONWithExtraProperty(p.Yearly, "type", "yearly")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentScheduleVisitor interface {
	VisitOneTime(*PaymentScheduleBase) error
	VisitDaily(*PaymentScheduleBase) error
	VisitWeekly(*PaymentWeekSchedule) error
	VisitMonthly(*PaymentMonthSchedule) error
	VisitYearly(*PaymentYearSchedule) error
}

func (p *PaymentSchedule) Accept(visitor PaymentScheduleVisitor) error {
	if p.OneTime != nil {
		return visitor.VisitOneTime(p.OneTime)
	}
	if p.Daily != nil {
		return visitor.VisitDaily(p.Daily)
	}
	if p.Weekly != nil {
		return visitor.VisitWeekly(p.Weekly)
	}
	if p.Monthly != nil {
		return visitor.VisitMonthly(p.Monthly)
	}
	if p.Yearly != nil {
		return visitor.VisitYearly(p.Yearly)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentSchedule) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.OneTime != nil {
		fields = append(fields, "oneTime")
	}
	if p.Daily != nil {
		fields = append(fields, "daily")
	}
	if p.Weekly != nil {
		fields = append(fields, "weekly")
	}
	if p.Monthly != nil {
		fields = append(fields, "monthly")
	}
	if p.Yearly != nil {
		fields = append(fields, "yearly")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentScheduleBase struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentScheduleBase) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentScheduleBase) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentScheduleBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentScheduleBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentScheduleBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentScheduleBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentScheduleBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentScheduleEndCondition struct {
	Integer  int
	DateTime time.Time

	typ string
}

func (p *PaymentScheduleEndCondition) GetInteger() int {
	if p == nil {
		return 0
	}
	return p.Integer
}

func (p *PaymentScheduleEndCondition) GetDateTime() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.DateTime
}

func (p *PaymentScheduleEndCondition) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		p.typ = "Integer"
		p.Integer = valueInteger
		return nil
	}
	var valueDateTime *internal.DateTime
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		p.typ = "DateTime"
		p.DateTime = valueDateTime.Time()
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p PaymentScheduleEndCondition) MarshalJSON() ([]byte, error) {
	if p.typ == "Integer" || p.Integer != 0 {
		return json.Marshal(p.Integer)
	}
	if p.typ == "DateTime" || !p.DateTime.IsZero() {
		return json.Marshal(internal.NewDateTime(p.DateTime))
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentScheduleEndConditionVisitor interface {
	VisitInteger(int) error
	VisitDateTime(time.Time) error
}

func (p *PaymentScheduleEndCondition) Accept(visitor PaymentScheduleEndConditionVisitor) error {
	if p.typ == "Integer" || p.Integer != 0 {
		return visitor.VisitInteger(p.Integer)
	}
	if p.typ == "DateTime" || !p.DateTime.IsZero() {
		return visitor.VisitDateTime(p.DateTime)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

type PaymentSourceOptions struct {
	Type string
	Bnpl *BnplPaymentSourceOptions
}

func (p *PaymentSourceOptions) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentSourceOptions) GetBnpl() *BnplPaymentSourceOptions {
	if p == nil {
		return nil
	}
	return p.Bnpl
}

func (p *PaymentSourceOptions) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "bnpl":
		value := new(BnplPaymentSourceOptions)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Bnpl = value
	}
	return nil
}

func (p PaymentSourceOptions) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Bnpl != nil {
		return internal.MarshalJSONWithExtraProperty(p.Bnpl, "type", "bnpl")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentSourceOptionsVisitor interface {
	VisitBnpl(*BnplPaymentSourceOptions) error
}

func (p *PaymentSourceOptions) Accept(visitor PaymentSourceOptionsVisitor) error {
	if p.Bnpl != nil {
		return visitor.VisitBnpl(p.Bnpl)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentSourceOptions) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Bnpl != nil {
		fields = append(fields, "bnpl")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PaymentType string

const (
	PaymentTypeOneTime   PaymentType = "oneTime"
	PaymentTypeRecurring PaymentType = "recurring"
)

func NewPaymentTypeFromString(s string) (PaymentType, error) {
	switch s {
	case "oneTime":
		return PaymentTypeOneTime, nil
	case "recurring":
		return PaymentTypeRecurring, nil
	}
	var t PaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentType) Ptr() *PaymentType {
	return &p
}

type PaymentWeekSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends     *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	RepeatOn []DayOfWeek                  `json:"repeatOn,omitempty" url:"repeatOn,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentWeekSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentWeekSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentWeekSchedule) GetRepeatOn() []DayOfWeek {
	if p == nil {
		return nil
	}
	return p.RepeatOn
}

func (p *PaymentWeekSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentWeekSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentWeekSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentWeekSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentWeekSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentYearSchedule struct {
	// How often to repeat the payments. Defaults to 1. Must be greater than 0. For example, if repeatEvery is set to 2 and this is a daily payment, the payment will be made every other day. If repeatEvery is set to 3 and this is a weekly payment, the payment will be made every third week.
	RepeatEvery *int `json:"repeatEvery,omitempty" url:"repeatEvery,omitempty"`
	// When to end the payments, either a number of occurrences or a date. Defaults to never ending if not specified
	Ends *PaymentScheduleEndCondition `json:"ends,omitempty" url:"ends,omitempty"`
	// Day of the month to repeat on. Positive values (1-31): Represent the day of the month counting from the start (e.g., 10 is the 10th day of the month). Negative values (-1 to -31): Represent the day of the month counting backward from the end (e.g., -1 is the last day of the month, -2 is the second-to-last day).
	RepeatOnDay int `json:"repeatOnDay" url:"repeatOnDay"`
	// Month to repeat on (1-12).
	RepeatOnMonth int `json:"repeatOnMonth" url:"repeatOnMonth"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentYearSchedule) GetRepeatEvery() *int {
	if p == nil {
		return nil
	}
	return p.RepeatEvery
}

func (p *PaymentYearSchedule) GetEnds() *PaymentScheduleEndCondition {
	if p == nil {
		return nil
	}
	return p.Ends
}

func (p *PaymentYearSchedule) GetRepeatOnDay() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnDay
}

func (p *PaymentYearSchedule) GetRepeatOnMonth() int {
	if p == nil {
		return 0
	}
	return p.RepeatOnMonth
}

func (p *PaymentYearSchedule) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentYearSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentYearSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentYearSchedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentYearSchedule) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UtilityPaymentDestinationOptions struct {
	// The ID for the utility account to pay with. Links to accounts listed on payor/payee relationship.
	AccountID string `json:"accountId" url:"accountId"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UtilityPaymentDestinationOptions) GetAccountID() string {
	if u == nil {
		return ""
	}
	return u.AccountID
}

func (u *UtilityPaymentDestinationOptions) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UtilityPaymentDestinationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilityPaymentDestinationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilityPaymentDestinationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilityPaymentDestinationOptions) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
